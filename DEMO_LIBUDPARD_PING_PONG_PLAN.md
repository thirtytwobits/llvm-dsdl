# LibUDPard + llvm-dsdl C++ Ping-Pong Demo Plan

## Goal

Build and demo two Cyphal/UDP nodes ("A" and "B") that exchange ping/pong RPC traffic using:

1. C++ types generated by `dsdlc`.
2. `libudpard` as the transport layer.
3. A small POSIX UDP shim that works on Linux and macOS.

This plan is CLI-first for build/run, with no CMake requirement for the demo execution path.

## Demo Story (<= 5 minutes)

1. Show one service definition in DSDL (`PingPong.1.0.dsdl`).
2. Generate C++ types from that DSDL with `dsdlc cpp`.
3. Show generated header snippets (`serialize`/`deserialize`, constants).
4. Build one node executable and run it twice (node A + node B).
5. Show live ping/pong RTT logs and (optional) packet capture on UDP/9382.

## Planned Files

```
examples/cyphal_ping_pong/
  dsdl/demo/ping/PingPong.1.0.dsdl
  src/net/udp_posix.h
  src/net/udp_posix.c
  src/ping_pong_node.cpp
```

Notes:
- Keep `udp_posix` in C (`.c`) so it is easy to reuse and test with plain POSIX calls.
- Keep node logic in C++ for generated type ergonomics.

## DSDL Type (Service)

`examples/cyphal_ping_pong/dsdl/demo/ping/PingPong.1.0.dsdl`

```dsdl
uint64 sequence
uint64 sent_usec
@sealed
---
uint64 sequence
uint64 echoed_sent_usec
uint64 responder_usec
@sealed
```

## CLI Build/Run Plan

### 1) Generate C++ types

```bash
cd /Users/thirtytwobits/workspace/github/thirtytwobits/llvm-dsdl

DSDLC="${DSDLC:-build/dev-homebrew/tools/dsdlc/dsdlc}"
OUT_GEN="build/pingpong/gen"
ROOT_DSDL="examples/cyphal_ping_pong/dsdl"

rm -rf "$OUT_GEN"
mkdir -p "$OUT_GEN"

"$DSDLC" cpp \
  --root-namespace-dir "$ROOT_DSDL" \
  --cpp-profile std \
  --out-dir "$OUT_GEN"
```

Expected generated artifacts:
- `build/pingpong/gen/dsdl/demo/ping/PingPong_1_0.hpp`
- `build/pingpong/gen/dsdl_runtime.h`
- `build/pingpong/gen/dsdl_runtime.hpp`

### 2) Build transport + demo binary (no CMake)

```bash
cd /Users/thirtytwobits/workspace/github/thirtytwobits/llvm-dsdl

BUILD_DIR="build/pingpong/bin"
mkdir -p "$BUILD_DIR"

# Build libudpard core as C object.
cc -std=c11 -O2 -Wall -Wextra \
  -Ilibudpard/libudpard \
  -c libudpard/libudpard/udpard.c \
  -o "$BUILD_DIR/udpard.o"

# Build portable UDP shim as C object.
cc -std=c11 -O2 -Wall -Wextra \
  -Iexamples/cyphal_ping_pong/src/net \
  -c examples/cyphal_ping_pong/src/net/udp_posix.c \
  -o "$BUILD_DIR/udp_posix.o"

# Build and link node app as C++.
clang++ -std=c++23 -O2 -Wall -Wextra \
  examples/cyphal_ping_pong/src/ping_pong_node.cpp \
  "$BUILD_DIR/udpard.o" \
  "$BUILD_DIR/udp_posix.o" \
  -Ibuild/pingpong/gen \
  -Ilibudpard/libudpard \
  -Iexamples/cyphal_ping_pong/src/net \
  -o "$BUILD_DIR/cyphal_ping_pong_node"
```

### 3) Run two nodes

Terminal A:

```bash
cd /Users/thirtytwobits/workspace/github/thirtytwobits/llvm-dsdl
build/pingpong/bin/cyphal_ping_pong_node \
  --name A \
  --node-id 42 \
  --peer-node-id 43 \
  --service-id 300 \
  --iface 127.0.0.1 \
  --period-ms 500
```

Terminal B:

```bash
cd /Users/thirtytwobits/workspace/github/thirtytwobits/llvm-dsdl
build/pingpong/bin/cyphal_ping_pong_node \
  --name B \
  --node-id 43 \
  --peer-node-id 42 \
  --service-id 300 \
  --iface 127.0.0.1 \
  --period-ms 500
```

Expected output:
- Requests sent with incrementing sequence IDs.
- Responses matched by sequence ID.
- RTT estimate per response.

### 4) Optional packet proof

macOS:
```bash
sudo tcpdump -ni lo0 udp port 9382
```

Linux:
```bash
sudo tcpdump -ni lo udp port 9382
```

### 5) Generated-code proof on screen

```bash
sed -n '1,120p' build/pingpong/gen/dsdl/demo/ping/PingPong_1_0.hpp
rg -n "serialize\\(|deserialize\\(|SERIALIZATION_BUFFER_SIZE_BYTES" \
  build/pingpong/gen/dsdl/demo/ping/PingPong_1_0.hpp
```

## Node Logic Plan

Each node does all of the following:

1. Initializes one `UdpardTx` pipeline (iface index `0`).
2. Initializes one `UdpardRxRPCDispatcher`.
3. Calls `udpardRxRPCDispatcherStart(local_node_id, &rpc_endpoint)`.
4. Registers one RPC port for request and one for response (`service_id=300`).
5. Uses generated C++ request/response types for payload encode/decode.
6. Uses `udpardTxRequest` for ping and `udpardTxRespond` for pong.
7. Uses `udpardGather` + generated `deserialize` on RX payload.
8. Frees RX fragments with `udpardRxFragmentFree`.
9. Uses monotonic microseconds for timestamps/deadlines.

## Semi-Portable Linux/macOS Network Layer Design

Use the same API style as OpenCyphal demos `shared/udp/udp.[ch]` and keep it transport-only:

1. `udpTxInit/udpTxSend/udpTxClose`
2. `udpRxInit/udpRxReceive/udpRxClose`
3. `udpWait` (with `poll`)
4. `udpParseIfaceAddress`

### Implementation Details

Common (both OSes):

1. `socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)`
2. `fcntl(fd, F_SETFL, O_NONBLOCK)`
3. `SO_REUSEADDR=1` on RX sockets
4. `IP_MULTICAST_IF` on TX sockets (selected local interface IPv4)
5. `IP_MULTICAST_TTL=16`
6. `IP_TOS` DSCP best-effort on send
7. `IP_ADD_MEMBERSHIP` with `{group, local_iface}` for RX join
8. `poll()` for readiness multiplexing

Linux/macOS branch points:

1. `SO_REUSEPORT`:
   - enable when available (`#ifdef SO_REUSEPORT`).
2. RX bind strategy:
   - attempt bind to multicast group+port first;
   - if that fails, retry `INADDR_ANY`+port;
   - always join target group via `IP_ADD_MEMBERSHIP`.
3. Interface selection:
   - first version: accept IPv4 address string only (`127.0.0.1`, etc.).
   - later: add interface-name resolution via `getifaddrs`.

### Why This Is Semi-Portable

1. Uses only POSIX sockets + `poll`, supported on Linux and macOS.
2. Avoids Linux-only mechanisms (`epoll`, `IP_PKTINFO` requirement for basic flow).
3. Keeps OS-specific logic isolated to a few `#ifdef` blocks in one C file.

## Validation Plan

1. Compile-only gate for generated C++ include + `libudpard` link.
2. Two-process local loopback ping/pong run for 60 seconds without errors.
3. RTT logs stable and sequence monotonic.
4. Optional packet capture confirms UDP/9382 traffic.
5. Optional sanitizer run (`-fsanitize=address,undefined`) for smoke coverage.

## Reference Baseline

The network shim design above is based on OpenCyphal demos:

- `libudpard_demo/src/main.c` (transport integration pattern)
- `shared/udp/udp.h` (socket shim API)
- `shared/udp/udp.c` (POSIX implementation with multicast + poll)
