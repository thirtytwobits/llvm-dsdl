// Template source for tools/runtime/generate_runtime_semantic_wrappers.py.
// Edit this file, then regenerate `dsdl_runtime_semantic_wrappers.rs`.

#[cfg(feature = "std")]
type DsdlBackingVec<T> = std::vec::Vec<T>;

#[cfg(not(feature = "std"))]
type DsdlBackingVec<T> = alloc::vec::Vec<T>;

/// Runtime memory strategy selected for variable-length fields.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DsdlMemoryMode {
    /// Uses only inline capacity semantics (deterministic, no pool path).
    MaxInline,
    /// Uses inline capacity below threshold and pool allocation above threshold.
    InlineThenPool,
}

/// Stable class identifier for per-type/per-field allocation groups.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
pub struct AllocationClassId(pub u32);

/// Memory contract associated with a variable-length runtime container.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct VarArrayMemoryContract {
    /// Configured memory mode.
    pub mode: DsdlMemoryMode,
    /// Inline threshold in bytes for [`DsdlMemoryMode::InlineThenPool`].
    pub inline_threshold_bytes: usize,
    /// Allocation class for pool requests.
    pub allocation_class: AllocationClassId,
}

impl VarArrayMemoryContract {
    /// Creates a memory contract.
    pub const fn new(
        mode: DsdlMemoryMode,
        inline_threshold_bytes: usize,
        allocation_class: AllocationClassId,
    ) -> Self {
        Self {
            mode,
            inline_threshold_bytes,
            allocation_class,
        }
    }
}

impl Default for VarArrayMemoryContract {
    fn default() -> Self {
        Self {
            mode: DsdlMemoryMode::MaxInline,
            inline_threshold_bytes: usize::MAX,
            allocation_class: AllocationClassId(0),
        }
    }
}

/// Allocation failure categories used by pool-backed memory mode handling.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AllocationErrorKind {
    /// Requested allocation exceeds pool capacity.
    OutOfMemory,
    /// Allocation parameters are invalid (for example bad alignment).
    InvalidRequest,
    /// No pool implementation is available for the requested mode.
    PoolUnavailable,
}

impl AllocationErrorKind {
    /// Returns the stable textual identifier for this allocation error kind.
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::OutOfMemory => "out_of_memory",
            Self::InvalidRequest => "invalid_request",
            Self::PoolUnavailable => "pool_unavailable",
        }
    }
}

impl fmt::Display for AllocationErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

/// Stable allocation failure payload for generated/runtime diagnostics.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct AllocationError {
    /// Failure category.
    pub kind: AllocationErrorKind,
    /// Associated allocation class.
    pub class_id: AllocationClassId,
    /// Requested allocation size in bytes.
    pub requested_bytes: usize,
}

impl AllocationError {
    fn new(kind: AllocationErrorKind, class_id: AllocationClassId, requested_bytes: usize) -> Self {
        Self {
            kind,
            class_id,
            requested_bytes,
        }
    }
}

impl fmt::Display for AllocationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "allocation_error(kind={}, class_id={}, requested_bytes={})",
            self.kind.as_str(),
            self.class_id.0,
            self.requested_bytes
        )
    }
}

/// Runtime success code.
pub const DSDL_RUNTIME_SUCCESS: i8 = 0;
/// API usage error code for invalid arguments.
pub const DSDL_RUNTIME_ERROR_INVALID_ARGUMENT: i8 = 2;
/// API usage error code for insufficient serialization buffer size.
pub const DSDL_RUNTIME_ERROR_SERIALIZATION_BUFFER_TOO_SMALL: i8 = 3;
/// Representation error code for malformed array-length values.
pub const DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_ARRAY_LENGTH: i8 = 10;
/// Representation error code for malformed union-tag values.
pub const DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_UNION_TAG: i8 = 11;
/// Representation error code for malformed delimiter headers.
pub const DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_DELIMITER_HEADER: i8 = 12;
/// Runtime error code for pool allocation failures.
pub const DSDL_RUNTIME_ERROR_ALLOCATION_OUT_OF_MEMORY: i8 = 13;
/// Runtime error code for missing/disabled pool provider.
pub const DSDL_RUNTIME_ERROR_ALLOCATION_POOL_UNAVAILABLE: i8 = 14;
/// Runtime error code for invalid pool allocation request parameters.
pub const DSDL_RUNTIME_ERROR_ALLOCATION_INVALID_REQUEST: i8 = 15;

/// Maps a stable allocation error into a runtime error code.
pub fn allocation_error_to_runtime_code(error: AllocationError) -> i8 {
    match error.kind {
        AllocationErrorKind::OutOfMemory => DSDL_RUNTIME_ERROR_ALLOCATION_OUT_OF_MEMORY,
        AllocationErrorKind::InvalidRequest => DSDL_RUNTIME_ERROR_ALLOCATION_INVALID_REQUEST,
        AllocationErrorKind::PoolUnavailable => DSDL_RUNTIME_ERROR_ALLOCATION_POOL_UNAVAILABLE,
    }
}

/// Returns troubleshooting guidance for allocation failure categories.
pub const fn allocation_error_hint(kind: AllocationErrorKind) -> &'static str {
    match kind {
        AllocationErrorKind::OutOfMemory => {
            "Increase per-type pool budget or use max-inline mode for deterministic pre-allocation."
        }
        AllocationErrorKind::InvalidRequest => {
            "Verify allocation request size/alignment and generated pool contract metadata."
        }
        AllocationErrorKind::PoolUnavailable => {
            "Enable/configure a pool provider for inline-then-pool mode, or switch to max-inline mode."
        }
    }
}

/// Allocator interface used by pool-backed variable-length storage strategies.
pub trait PoolProvider {
    /// Provider-specific allocation handle.
    type Handle: Copy;

    /// Allocates `bytes` at `align` for `class_id`.
    fn alloc(
        &mut self,
        class_id: AllocationClassId,
        bytes: usize,
        align: usize,
    ) -> Result<Self::Handle, AllocationError>;

    /// Releases a previously-issued handle.
    fn dealloc(&mut self, class_id: AllocationClassId, handle: Self::Handle);
}

/// Handle type for [`NullPoolProvider`].
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct NullPoolHandle;

/// Reference pool provider that always reports pool unavailability.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct NullPoolProvider;

impl PoolProvider for NullPoolProvider {
    type Handle = NullPoolHandle;

    fn alloc(
        &mut self,
        class_id: AllocationClassId,
        bytes: usize,
        _align: usize,
    ) -> Result<Self::Handle, AllocationError> {
        Err(AllocationError::new(
            AllocationErrorKind::PoolUnavailable,
            class_id,
            bytes,
        ))
    }

    fn dealloc(&mut self, _class_id: AllocationClassId, _handle: Self::Handle) {}
}

/// Handle type for [`PassthroughPoolProvider`].
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct PassthroughPoolHandle(pub u64);

/// Reference pool provider that accepts all allocation requests.
///
/// This provider is useful for preserving existing generated behavior while
/// still exercising pool allocation routes in code paths.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct PassthroughPoolProvider {
    next_handle: u64,
}

impl PoolProvider for PassthroughPoolProvider {
    type Handle = PassthroughPoolHandle;

    fn alloc(
        &mut self,
        class_id: AllocationClassId,
        bytes: usize,
        align: usize,
    ) -> Result<Self::Handle, AllocationError> {
        if align == 0 || !align.is_power_of_two() {
            return Err(AllocationError::new(
                AllocationErrorKind::InvalidRequest,
                class_id,
                bytes,
            ));
        }
        let handle = PassthroughPoolHandle(self.next_handle);
        self.next_handle = self.next_handle.wrapping_add(1);
        Ok(handle)
    }

    fn dealloc(&mut self, _class_id: AllocationClassId, _handle: Self::Handle) {}
}

/// Handle type for [`BudgetPoolProvider`].
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct BudgetPoolHandle(pub u64);

/// Reference pool provider with a fixed byte budget.
///
/// This provider enforces deterministic boundary behavior for tests and
/// embedded bring-up. Deallocation is intentionally a no-op in this reference
/// implementation.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct BudgetPoolProvider {
    remaining_bytes: usize,
    total_allocated_bytes: usize,
    allocations: u64,
    next_handle: u64,
}

impl BudgetPoolProvider {
    /// Constructs a provider with the specified total budget.
    pub fn new(total_budget_bytes: usize) -> Self {
        Self {
            remaining_bytes: total_budget_bytes,
            total_allocated_bytes: 0,
            allocations: 0,
            next_handle: 1,
        }
    }

    /// Returns the remaining byte budget.
    pub fn remaining_bytes(&self) -> usize {
        self.remaining_bytes
    }

    /// Returns the total number of successful allocation calls.
    pub fn allocations(&self) -> u64 {
        self.allocations
    }

    /// Returns the total bytes consumed by successful allocations.
    pub fn total_allocated_bytes(&self) -> usize {
        self.total_allocated_bytes
    }
}

fn align_up(value: usize, align: usize) -> Option<usize> {
    if align == 0 || !align.is_power_of_two() {
        return None;
    }
    let mask = align - 1;
    value.checked_add(mask).map(|v| v & !mask)
}

impl PoolProvider for BudgetPoolProvider {
    type Handle = BudgetPoolHandle;

    fn alloc(
        &mut self,
        class_id: AllocationClassId,
        bytes: usize,
        align: usize,
    ) -> Result<Self::Handle, AllocationError> {
        let aligned_bytes = match align_up(bytes, align) {
            Some(v) => v,
            None => {
                return Err(AllocationError::new(
                    AllocationErrorKind::InvalidRequest,
                    class_id,
                    bytes,
                ));
            }
        };
        if aligned_bytes > self.remaining_bytes {
            return Err(AllocationError::new(
                AllocationErrorKind::OutOfMemory,
                class_id,
                aligned_bytes,
            ));
        }
        self.remaining_bytes -= aligned_bytes;
        self.total_allocated_bytes += aligned_bytes;
        self.allocations += 1;
        let handle = BudgetPoolHandle(self.next_handle);
        self.next_handle = self.next_handle.wrapping_add(1);
        Ok(handle)
    }

    fn dealloc(&mut self, _class_id: AllocationClassId, _handle: Self::Handle) {}
}

/// Variable-length storage wrapper used by generated Rust bindings.
///
/// This wrapper preserves the historical `Vec`-like API used by generated
/// code, while adding memory-mode contract metadata and optional pool-aware
/// capacity reservation hooks.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct VarArray<T> {
    inner: DsdlBackingVec<T>,
    contract: VarArrayMemoryContract,
}

impl<T> VarArray<T> {
    /// Constructs an empty array with default memory contract.
    pub fn new() -> Self {
        Self {
            inner: DsdlBackingVec::new(),
            contract: VarArrayMemoryContract::default(),
        }
    }

    /// Constructs an empty array with default contract and capacity.
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            inner: DsdlBackingVec::with_capacity(capacity),
            contract: VarArrayMemoryContract::default(),
        }
    }

    /// Constructs an empty array using an explicit memory contract.
    pub fn with_contract(contract: VarArrayMemoryContract) -> Self {
        Self {
            inner: DsdlBackingVec::new(),
            contract,
        }
    }

    /// Constructs an array with explicit memory contract and capacity.
    pub fn with_contract_and_capacity(contract: VarArrayMemoryContract, capacity: usize) -> Self {
        Self {
            inner: DsdlBackingVec::with_capacity(capacity),
            contract,
        }
    }

    /// Returns the current memory contract.
    pub fn memory_contract(&self) -> VarArrayMemoryContract {
        self.contract
    }

    /// Replaces the memory contract.
    pub fn set_memory_contract(&mut self, contract: VarArrayMemoryContract) {
        self.contract = contract;
    }

    /// Returns number of elements.
    pub fn len(&self) -> usize {
        self.inner.len()
    }

    /// Returns true when empty.
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }

    /// Returns current backing capacity.
    pub fn capacity(&self) -> usize {
        self.inner.capacity()
    }

    /// Removes all elements.
    pub fn clear(&mut self) {
        self.inner.clear();
    }

    /// Appends one element.
    pub fn push(&mut self, value: T) {
        self.inner.push(value);
    }

    /// Ensures capacity for at least `additional` extra elements.
    pub fn reserve(&mut self, additional: usize) {
        self.inner.reserve(additional);
    }

    /// Ensures capacity while honoring pool-mode allocation contract.
    ///
    /// In `max-inline` mode this behaves like [`VarArray::reserve`]. In
    /// `inline-then-pool` mode, crossing the inline threshold triggers a pool
    /// allocation request before reserving backing storage.
    pub fn reserve_with_pool<P: PoolProvider>(
        &mut self,
        additional: usize,
        pool: &mut P,
    ) -> Result<(), AllocationError> {
        if self.contract.mode == DsdlMemoryMode::InlineThenPool {
            let elem_bytes = core::mem::size_of::<T>();
            if elem_bytes != 0 {
                let target_len = self.inner.len().saturating_add(additional);
                let target_bytes = target_len.saturating_mul(elem_bytes);
                if target_bytes > self.contract.inline_threshold_bytes {
                    let requested = target_bytes - self.contract.inline_threshold_bytes;
                    let align = core::mem::align_of::<T>().max(1);
                    let _ = pool.alloc(self.contract.allocation_class, requested, align)?;
                }
            }
        }
        self.inner.reserve(additional);
        Ok(())
    }

    /// Resizes the array to `new_len`, cloning `value` when needed.
    pub fn resize(&mut self, new_len: usize, value: T)
    where
        T: Clone,
    {
        self.inner.resize(new_len, value);
    }

    /// Truncates the array to `len` elements.
    pub fn truncate(&mut self, len: usize) {
        self.inner.truncate(len);
    }

    /// Returns immutable slice view.
    pub fn as_slice(&self) -> &[T] {
        &self.inner
    }

    /// Returns mutable slice view.
    pub fn as_mut_slice(&mut self) -> &mut [T] {
        &mut self.inner
    }

    /// Consumes the wrapper and returns the backing vector.
    pub fn into_inner(self) -> DsdlBackingVec<T> {
        self.inner
    }
}

impl<T> Default for VarArray<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T> Deref for VarArray<T> {
    type Target = [T];

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl<T> DerefMut for VarArray<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl<T> Index<usize> for VarArray<T> {
    type Output = T;

    fn index(&self, index: usize) -> &Self::Output {
        &self.inner[index]
    }
}

impl<T> IndexMut<usize> for VarArray<T> {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.inner[index]
    }
}

impl<T> AsRef<[T]> for VarArray<T> {
    fn as_ref(&self) -> &[T] {
        self.as_slice()
    }
}

impl<T> AsMut<[T]> for VarArray<T> {
    fn as_mut(&mut self) -> &mut [T] {
        self.as_mut_slice()
    }
}

/// Vector wrapper used by generated code.
pub type DsdlVec<T> = VarArray<T>;
