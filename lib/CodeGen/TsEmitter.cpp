//===----------------------------------------------------------------------===//
//
// Part of the OpenCyphal project, under the MIT licence
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
///
/// @file
/// Implements TypeScript backend code emission from lowered DSDL modules.
///
/// This file emits TypeScript models, codec entry points, and runtime wiring from lowering contracts.
///
//===----------------------------------------------------------------------===//

#include "llvmdsdl/CodeGen/TsEmitter.h"

#include <llvm/ADT/StringRef.h>
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <map>
#include <optional>
#include <set>
#include <sstream>
#include <unordered_map>
#include <vector>
#include <cstddef>
#include <cstdint>
#include <system_error>
#include <utility>
#include <variant>

#include "llvmdsdl/CodeGen/MlirLoweredFacts.h"
#include "llvmdsdl/CodeGen/CodegenDiagnosticText.h"
#include "llvmdsdl/CodeGen/CompositeImportGraph.h"
#include "llvmdsdl/CodeGen/ConstantLiteralRender.h"
#include "llvmdsdl/CodeGen/DefinitionIndex.h"
#include "llvmdsdl/CodeGen/DefinitionPathProjection.h"
#include "llvmdsdl/CodeGen/NamingPolicy.h"
#include "llvmdsdl/CodeGen/HelperBindingNaming.h"
#include "llvmdsdl/CodeGen/HelperBindingRender.h"
#include "llvmdsdl/CodeGen/LoweredFactsLookup.h"
#include "llvmdsdl/CodeGen/RuntimeHelperBindings.h"
#include "llvmdsdl/CodeGen/ScriptedOperationPlan.h"
#include "llvmdsdl/CodeGen/SectionHelperBindingPlan.h"
#include "llvmdsdl/CodeGen/RuntimeLoweredPlan.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/raw_ostream.h"
#include "llvmdsdl/Frontend/AST.h"
#include "llvmdsdl/Semantics/Evaluator.h"
#include "llvmdsdl/Semantics/Model.h"
#include "llvmdsdl/Support/Rational.h"
#include "llvmdsdl/Version.h"
#include "mlir/IR/BuiltinOps.h"

namespace llvmdsdl
{
class DiagnosticEngine;

namespace
{

std::string tsConstValue(const Value& value)
{
    return renderConstantLiteral(ConstantLiteralLanguage::TypeScript, value);
}

void emitLine(std::ostringstream& out, const int indent, const std::string& line)
{
    out << std::string(static_cast<std::size_t>(indent) * 2U, ' ') << line << '\n';
}

std::string generatedCommentLine(llvm::StringRef detail)
{
    return "// Generated by llvmdsdl " + std::string(llvmdsdl::kVersionString) + " (" + detail.str() + ").";
}

class EmitterContext final
{
public:
    explicit EmitterContext(const SemanticModule& semantic)
        : index_(semantic)
    {
    }

    const SemanticDefinition* find(const SemanticTypeRef& ref) const
    {
        return index_.find(ref);
    }

    std::string namespacePath(const DiscoveredDefinition& info) const
    {
        return renderNamespaceRelativePath(CodegenNamingLanguage::TypeScript, info.namespaceComponents)
            .generic_string();
    }

    std::string typeName(const DiscoveredDefinition& info) const
    {
        return renderVersionedTypeName(CodegenNamingLanguage::TypeScript,
                                       info.shortName,
                                       info.majorVersion,
                                       info.minorVersion);
    }

    std::string typeName(const SemanticTypeRef& ref) const
    {
        if (const auto* def = find(ref))
        {
            return typeName(def->info);
        }

        DiscoveredDefinition tmp;
        tmp.shortName    = ref.shortName;
        tmp.majorVersion = ref.majorVersion;
        tmp.minorVersion = ref.minorVersion;
        return typeName(tmp);
    }

    std::string fileStem(const DiscoveredDefinition& info) const
    {
        return renderVersionedFileStem(CodegenNamingLanguage::TypeScript,
                                       info.shortName,
                                       info.majorVersion,
                                       info.minorVersion);
    }

    std::filesystem::path relativeFilePath(const DiscoveredDefinition& info) const
    {
        return renderRelativeTypeFilePath(CodegenNamingLanguage::TypeScript, info, "ts");
    }

    std::filesystem::path relativeFilePath(const SemanticTypeRef& ref) const
    {
        if (const auto* def = find(ref))
        {
            return relativeFilePath(def->info);
        }

        return renderRelativeTypeFilePath(CodegenNamingLanguage::TypeScript, ref, "ts");
    }

private:
    DefinitionIndex index_;
};

std::string tsFieldBaseType(const SemanticFieldType& type, const EmitterContext& ctx)
{
    switch (type.scalarCategory)
    {
    case SemanticScalarCategory::Bool:
        return "boolean";
    case SemanticScalarCategory::Byte:
    case SemanticScalarCategory::Utf8:
        return "number";
    case SemanticScalarCategory::UnsignedInt:
    case SemanticScalarCategory::SignedInt:
        if (type.bitLength > 53U)
        {
            return "bigint";
        }
        return "number";
    case SemanticScalarCategory::Float:
    case SemanticScalarCategory::Void:
        return "number";
    case SemanticScalarCategory::Composite:
        if (type.compositeType)
        {
            return ctx.typeName(*type.compositeType);
        }
        return "unknown";
    }
    return "unknown";
}

std::string tsFieldType(const SemanticFieldType& type, const EmitterContext& ctx)
{
    const auto base = tsFieldBaseType(type, ctx);
    if (type.arrayKind == ArrayKind::None)
    {
        return base;
    }
    return "Array<" + base + ">";
}

std::string relativeImportPath(const std::filesystem::path& fromFile, const std::filesystem::path& toFile)
{
    const auto  fromDir    = fromFile.parent_path();
    auto        rel        = toFile.lexically_relative(fromDir);
    std::string importPath = rel.generic_string();
    if (importPath.size() >= 3 && importPath.ends_with(".ts"))
    {
        importPath.resize(importPath.size() - 3);
    }
    if (!importPath.empty() && importPath.front() != '.')
    {
        importPath = "./" + importPath;
    }
    return importPath;
}

std::string moduleAliasFromPath(const std::string& modulePath)
{
    std::string alias;
    alias.reserve(modulePath.size() + 8);
    for (char c : modulePath)
    {
        if (std::isalnum(static_cast<unsigned char>(c)) || c == '_')
        {
            alias.push_back(static_cast<char>(std::tolower(static_cast<unsigned char>(c))));
        }
        else
        {
            alias.push_back('_');
        }
    }
    return codegenSanitizeIdentifier(CodegenNamingLanguage::TypeScript, alias.empty() ? "module" : alias);
}

void emitSectionConstants(std::ostringstream& out, const std::string& prefix, const SemanticSection& section)
{
    for (const auto& constant : section.constants)
    {
        const auto constName = codegenToUpperSnakeCaseIdentifier(CodegenNamingLanguage::TypeScript, prefix) + "_" +
                               codegenToUpperSnakeCaseIdentifier(CodegenNamingLanguage::TypeScript, constant.name);
        emitLine(out, 0, "export const " + constName + " = " + tsConstValue(constant.value) + ";");
    }
}

void emitStructSectionType(std::ostringstream&    out,
                           const std::string&     typeName,
                           const SemanticSection& section,
                           const EmitterContext&  ctx)
{
    emitLine(out, 0, "export interface " + typeName + " {");
    for (const auto& field : section.fields)
    {
        if (field.isPadding)
        {
            continue;
        }
        const auto fieldName =
            codegenSanitizeIdentifier(CodegenNamingLanguage::TypeScript,
                                      codegenToSnakeCaseIdentifier(CodegenNamingLanguage::TypeScript, field.name));
        emitLine(out, 1, fieldName + ": " + tsFieldType(field.resolvedType, ctx) + ";");
    }
    emitLine(out, 0, "}");
}

void emitUnionSectionType(std::ostringstream&    out,
                          const std::string&     typeName,
                          const SemanticSection& section,
                          const EmitterContext&  ctx)
{
    std::vector<const SemanticField*> options;
    for (const auto& field : section.fields)
    {
        if (!field.isPadding)
        {
            options.push_back(&field);
        }
    }

    if (options.empty())
    {
        emitLine(out, 0, "export type " + typeName + " = { _tag: number };");
        return;
    }

    emitLine(out, 0, "export type " + typeName + " =");
    for (std::size_t i = 0; i < options.size(); ++i)
    {
        const auto* field = options[i];
        const auto  fieldName =
            codegenSanitizeIdentifier(CodegenNamingLanguage::TypeScript,
                                      codegenToSnakeCaseIdentifier(CodegenNamingLanguage::TypeScript, field->name));
        std::ostringstream variant;
        variant << "{ _tag: " << field->unionOptionIndex << "; " << fieldName << ": "
                << tsFieldType(field->resolvedType, ctx) << "; }";
        const auto prefix = i == 0 ? "  | " : "  | ";
        emitLine(out, 0, prefix + variant.str() + (i + 1 == options.size() ? ";" : ""));
    }
}

void emitSectionType(std::ostringstream&    out,
                     const std::string&     typeName,
                     const SemanticSection& section,
                     const EmitterContext&  ctx)
{
    if (section.isUnion)
    {
        emitUnionSectionType(out, typeName, section, ctx);
    }
    else
    {
        emitStructSectionType(out, typeName, section, ctx);
    }
}

std::string tsRuntimeSerializeFn(const std::string& typeName)
{
    return "serialize" + typeName;
}

std::string tsRuntimeDeserializeFn(const std::string& typeName)
{
    return "deserialize" + typeName;
}

std::string compositeTypeName(const RuntimeFieldPlan& field, const EmitterContext& ctx)
{
    return field.compositeType ? ctx.typeName(*field.compositeType) : std::string{"unknown_composite"};
}

std::string helperBindingNameTs(const std::string& helperSymbol)
{
    return renderHelperBindingIdentifier(CodegenNamingLanguage::TypeScript, helperSymbol);
}

std::string normalizeTsDeserScalarExpr(const RuntimeFieldPlan&        field,
                                       const RuntimeFieldHelperNames& helpers,
                                       const std::string&             rawExpr)
{
    if (helpers.deserScalar.empty())
    {
        return rawExpr;
    }
    const auto helperCall = helpers.deserScalar + "(" + rawExpr + ")";
    if (field.kind == RuntimeFieldKind::Unsigned || field.kind == RuntimeFieldKind::Signed)
    {
        return field.useBigInt ? ("BigInt(" + helperCall + ")") : ("Number(" + helperCall + ")");
    }
    return helperCall;
}

void emitTsRuntimeSerializeCompositeValue(std::ostringstream&     out,
                                          int                     indent,
                                          const RuntimeFieldPlan& field,
                                          const std::string&      valueExpr,
                                          const EmitterContext&   ctx)
{
    const auto nestedVar = field.fieldName + "Bytes";
    const auto typeName  = compositeTypeName(field, ctx);
    emitLine(out, indent, "const " + nestedVar + " = " + tsRuntimeSerializeFn(typeName) + "(" + valueExpr + ");");
    if (field.compositeSealed)
    {
        emitLine(out,
                 indent,
                 "dsdlRuntime.copyBits(out, offsetBits, " + nestedVar + ", 0, " + std::to_string(field.bitLength) +
                     ");");
        emitLine(out, indent, "offsetBits += " + std::to_string(field.bitLength) + ";");
        return;
    }

    const auto sizeVar         = field.fieldName + "SizeBytes";
    const auto remainingVar    = field.fieldName + "RemainingBytes";
    const auto maxPayloadBytes = std::to_string((field.compositePayloadMaxBits + 7) / 8);
    emitLine(out, indent, "const " + sizeVar + " = " + nestedVar + ".length;");
    emitLine(out, indent, "if (" + sizeVar + " > " + maxPayloadBytes + ") {");
    emitLine(out,
             indent + 1,
             "throw new Error(\"" +
                 codegen_diagnostic_text::encodedCompositePayloadExceedsMaxPayloadBytes(field.fieldName,
                                                                                        maxPayloadBytes) +
                 "\");");
    emitLine(out, indent, "}");
    emitLine(out,
             indent,
             "const " + remainingVar + " = out.length - Math.min(Math.trunc(offsetBits / 8), out.length);");
    emitLine(out, indent, "if (" + sizeVar + " > " + remainingVar + ") {");
    emitLine(out,
             indent + 1,
             "throw new Error(\"" +
                 codegen_diagnostic_text::encodedCompositePayloadExceedsRemainingBufferSpace(field.fieldName) + "\");");
    emitLine(out, indent, "}");
    emitLine(out, indent, "dsdlRuntime.writeUnsigned(out, offsetBits, 32, " + sizeVar + ", false);");
    emitLine(out, indent, "offsetBits += 32;");
    emitLine(out, indent, "dsdlRuntime.copyBits(out, offsetBits, " + nestedVar + ", 0, " + sizeVar + " * 8);");
    emitLine(out, indent, "offsetBits += " + sizeVar + " * 8;");
}

void emitTsRuntimeDeserializeCompositeValue(std::ostringstream&     out,
                                            int                     indent,
                                            const RuntimeFieldPlan& field,
                                            const std::string&      targetExpr,
                                            const EmitterContext&   ctx,
                                            const std::string&      delimiterValidateHelper = {})
{
    const auto typeName = compositeTypeName(field, ctx);
    if (field.compositeSealed)
    {
        const auto nestedVar = field.fieldName + "Bytes";
        emitLine(out,
                 indent,
                 "const " + nestedVar + " = dsdlRuntime.extractBits(bytes, offsetBits, " +
                     std::to_string(field.bitLength) + ");");
        emitLine(out, indent, targetExpr + " = " + tsRuntimeDeserializeFn(typeName) + "(" + nestedVar + ").value;");
        emitLine(out, indent, "offsetBits += " + std::to_string(field.bitLength) + ";");
        return;
    }

    const auto sizeVar      = field.fieldName + "SizeBytes";
    const auto remainingVar = field.fieldName + "RemainingBytes";
    const auto startVar     = field.fieldName + "StartByte";
    const auto endVar       = field.fieldName + "EndByte";
    const auto nestedVar    = field.fieldName + "Bytes";
    emitLine(out, indent, "const " + sizeVar + " = Math.trunc(dsdlRuntime.readUnsigned(bytes, offsetBits, 32));");
    emitLine(out, indent, "offsetBits += 32;");
    emitLine(out,
             indent,
             "const " + remainingVar + " = bytes.length - Math.min(Math.trunc(offsetBits / 8), bytes.length);");
    if (!delimiterValidateHelper.empty())
    {
        emitLine(out, indent, "if (!" + delimiterValidateHelper + "(" + sizeVar + ", " + remainingVar + ")) {");
    }
    else
    {
        emitLine(out, indent, "if (" + sizeVar + " < 0 || " + sizeVar + " > " + remainingVar + ") {");
    }
    emitLine(out,
             indent + 1,
             "throw new Error(\"" +
                 codegen_diagnostic_text::decodedCompositePayloadExceedsRemainingBufferSpace(field.fieldName) + "\");");
    emitLine(out, indent, "}");
    emitLine(out, indent, "const " + startVar + " = Math.min(Math.trunc(offsetBits / 8), bytes.length);");
    emitLine(out, indent, "const " + endVar + " = Math.min(" + startVar + " + " + sizeVar + ", bytes.length);");
    emitLine(out, indent, "const " + nestedVar + " = bytes.subarray(" + startVar + ", " + endVar + ");");
    emitLine(out, indent, targetExpr + " = " + tsRuntimeDeserializeFn(typeName) + "(" + nestedVar + ").value;");
    emitLine(out, indent, "offsetBits += " + sizeVar + " * 8;");
}

void emitTsRuntimeAlignSerialize(std::ostringstream& out,
                                 int                 indent,
                                 std::int64_t        alignmentBits,
                                 const std::string&  prefix)
{
    if (alignmentBits <= 1)
    {
        return;
    }
    const auto alignedVar = prefix + "AlignedOffsetBits";
    const auto bitVar     = prefix + "AlignBit";
    emitLine(out,
             indent,
             "const " + alignedVar + " = Math.trunc((offsetBits + " + std::to_string(alignmentBits - 1) + ") / " +
                 std::to_string(alignmentBits) + ") * " + std::to_string(alignmentBits) + ";");
    emitLine(out,
             indent,
             "for (let " + bitVar + " = offsetBits; " + bitVar + " < " + alignedVar + "; ++" + bitVar + ") {");
    emitLine(out, indent + 1, "dsdlRuntime.setBit(out, " + bitVar + ", false);");
    emitLine(out, indent, "}");
    emitLine(out, indent, "offsetBits = " + alignedVar + ";");
}

void emitTsRuntimeAlignDeserialize(std::ostringstream& out, int indent, std::int64_t alignmentBits)
{
    if (alignmentBits <= 1)
    {
        return;
    }
    emitLine(out,
             indent,
             "offsetBits = Math.trunc((offsetBits + " + std::to_string(alignmentBits - 1) + ") / " +
                 std::to_string(alignmentBits) + ") * " + std::to_string(alignmentBits) + ";");
}

void emitTsRuntimeSerializePadding(std::ostringstream&     out,
                                   int                     indent,
                                   const RuntimeFieldPlan& field,
                                   const std::string&      prefix)
{
    if (field.bitLength <= 0)
    {
        return;
    }
    const auto bitVar = prefix + "PaddingBit";
    emitLine(out,
             indent,
             "for (let " + bitVar + " = 0; " + bitVar + " < " + std::to_string(field.bitLength) + "; ++" + bitVar +
                 ") {");
    emitLine(out, indent + 1, "dsdlRuntime.setBit(out, offsetBits + " + bitVar + ", false);");
    emitLine(out, indent, "}");
    emitLine(out, indent, "offsetBits += " + std::to_string(field.bitLength) + ";");
}

void emitTsRuntimeDeserializePadding(std::ostringstream& out, int indent, const RuntimeFieldPlan& field)
{
    if (field.bitLength <= 0)
    {
        return;
    }
    emitLine(out, indent, "offsetBits += " + std::to_string(field.bitLength) + ";");
}

void emitTsRuntimeFunctions(std::ostringstream&        out,
                            const std::string&         typeName,
                            const RuntimeSectionPlan&  plan,
                            const EmitterContext&      ctx,
                            const SemanticSection&     section,
                            const LoweredSectionFacts* sectionFacts)
{
    const auto serializeFn   = tsRuntimeSerializeFn(typeName);
    const auto deserializeFn = tsRuntimeDeserializeFn(typeName);
    const auto maxByteLength = (plan.maxBits + 7) / 8;
    const auto serializeHelpers =
        buildSectionHelperBindingPlan(section, sectionFacts, HelperBindingDirection::Serialize);
    const auto deserializeHelpers =
        buildSectionHelperBindingPlan(section, sectionFacts, HelperBindingDirection::Deserialize);

    const RuntimeHelperNameResolver helperNameResolver = [](const std::string& symbol) {
        return helperBindingNameTs(symbol);
    };
    auto operationPlan = buildScriptedSectionOperationPlan(section, plan, sectionFacts, helperNameResolver);
    for (auto& scriptedField : operationPlan.fields)
    {
        auto&       field        = scriptedField.body.field;
        const auto& semanticName = field.semanticFieldName.empty() ? field.fieldName : field.semanticFieldName;
        field.fieldName =
            codegenSanitizeIdentifier(CodegenNamingLanguage::TypeScript,
                                      codegenToSnakeCaseIdentifier(CodegenNamingLanguage::TypeScript, semanticName));
    }
    const auto& sectionHelperNames = operationPlan.sectionHelpers;

    const auto emitSerializeHelperBindings = [&]() {
        const auto lines = renderSectionHelperBindings(serializeHelpers,
                                                       HelperBindingRenderLanguage::TypeScript,
                                                       ScalarBindingRenderDirection::Serialize,
                                                       helperNameResolver,
                                                       /*emitCapacityCheck=*/true);
        for (const auto& line : lines)
        {
            emitLine(out, 1, line);
        }
        if (!lines.empty())
        {
            emitLine(out, 1, "");
        }
    };

    const auto emitDeserializeHelperBindings = [&]() {
        const auto lines = renderSectionHelperBindings(deserializeHelpers,
                                                       HelperBindingRenderLanguage::TypeScript,
                                                       ScalarBindingRenderDirection::Deserialize,
                                                       helperNameResolver,
                                                       /*emitCapacityCheck=*/false);
        for (const auto& line : lines)
        {
            emitLine(out, 1, line);
        }
        if (!lines.empty())
        {
            emitLine(out, 1, "");
        }
    };

    if (operationPlan.isUnion)
    {
        const auto tagBits = std::to_string(operationPlan.unionTagBits);
        emitLine(out, 0, "export function " + serializeFn + "(value: " + typeName + "): Uint8Array {");
        emitLine(out, 1, "const out = new Uint8Array(" + std::to_string(maxByteLength) + ");");
        emitLine(out, 1, "let offsetBits = 0;");
        emitSerializeHelperBindings();
        if (!sectionHelperNames.capacityCheck.empty())
        {
            emitLine(out, 1, "if (!" + sectionHelperNames.capacityCheck + "(out.length * 8)) {");
            emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::serializationBufferTooSmall() + "\");");
            emitLine(out, 1, "}");
        }
        emitLine(out, 1, "let tag = Math.trunc((value as { _tag: number })._tag);");
        if (!sectionHelperNames.unionTagValidate.empty())
        {
            emitLine(out, 1, "if (!" + sectionHelperNames.unionTagValidate + "(tag)) {");
            emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::invalidUnionTagPrefix() + "\" + tag);");
            emitLine(out, 1, "}");
        }
        if (!sectionHelperNames.serUnionTagMask.empty())
        {
            emitLine(out, 1, "tag = Number(" + sectionHelperNames.serUnionTagMask + "(tag));");
        }
        emitLine(out, 1, "dsdlRuntime.writeUnsigned(out, offsetBits, " + tagBits + ", tag, false);");
        emitLine(out, 1, "offsetBits += " + tagBits + ";");
        emitLine(out, 1, "switch (tag) {");
        for (const auto& scriptedField : operationPlan.fields)
        {
            const auto& field       = scriptedField.body.field;
            const auto& helpers     = scriptedField.body.helpers;
            const auto  cardinality = scriptedField.cardinality;
            const auto  bits        = std::to_string(field.bitLength);
            const auto  optionTag   = std::to_string(field.unionOptionIndex);
            const auto  saturating  = field.castMode == CastMode::Saturated ? "true" : "false";
            const auto  cap         = std::to_string(field.arrayCapacity);
            const auto  prefixBits  = std::to_string(field.arrayLengthPrefixBits);
            emitLine(out, 1, "case " + optionTag + ": {");
            emitLine(out, 2, "const optionValue = (value as Record<string, unknown>)." + field.fieldName + ";");
            emitLine(out, 2, "if (optionValue === undefined) {");
            emitLine(out,
                     3,
                     "throw new Error(\"" +
                         codegen_diagnostic_text::unionFieldMissingForTag(field.fieldName, optionTag) + "\");");
            emitLine(out, 2, "}");
            emitTsRuntimeAlignSerialize(out, 2, field.alignmentBits, field.fieldName + "Option");
            if (cardinality == ScriptedFieldCardinality::Scalar)
            {
                if (field.kind == RuntimeFieldKind::Padding)
                {
                    emitTsRuntimeSerializePadding(out, 2, field, field.fieldName + "Option");
                }
                else if (field.kind == RuntimeFieldKind::Bool)
                {
                    emitLine(out, 2, "dsdlRuntime.setBit(out, offsetBits, !!optionValue);");
                }
                else if (field.kind == RuntimeFieldKind::Composite)
                {
                    emitTsRuntimeSerializeCompositeValue(out,
                                                         2,
                                                         field,
                                                         "optionValue as " + compositeTypeName(field, ctx),
                                                         ctx);
                }
                else if (field.kind == RuntimeFieldKind::Unsigned)
                {
                    std::string scalarExpr = "optionValue as number | bigint";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             2,
                             "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                else if (field.kind == RuntimeFieldKind::Float)
                {
                    std::string scalarExpr = "optionValue as number";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out, 2, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
                }
                else
                {
                    std::string scalarExpr = "optionValue as number | bigint";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             2,
                             "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
                {
                    emitLine(out, 2, "offsetBits += " + bits + ";");
                }
            }
            else if (cardinality == ScriptedFieldCardinality::FixedArray)
            {
                const auto optionArray = field.fieldName + "Array";
                emitLine(out, 2, "const " + optionArray + " = optionValue;");
                emitLine(out,
                         2,
                         "if (!Array.isArray(" + optionArray + ") || " + optionArray + ".length !== " + cap + ") {");
                emitLine(out,
                         3,
                         "throw new Error(\"" +
                             codegen_diagnostic_text::fieldExpectsExactlyElements(field.fieldName, cap, true) + "\");");
                emitLine(out, 2, "}");
                emitLine(out, 2, "for (let i = 0; i < " + cap + "; ++i) {");
                if (field.kind == RuntimeFieldKind::Bool)
                {
                    emitLine(out, 3, "dsdlRuntime.setBit(out, offsetBits, " + optionArray + "[i]);");
                }
                else if (field.kind == RuntimeFieldKind::Composite)
                {
                    emitTsRuntimeSerializeCompositeValue(out,
                                                         3,
                                                         field,
                                                         optionArray + "[i] as " + compositeTypeName(field, ctx),
                                                         ctx);
                }
                else if (field.kind == RuntimeFieldKind::Unsigned)
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             3,
                             "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                else if (field.kind == RuntimeFieldKind::Float)
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out, 3, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
                }
                else
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             3,
                             "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
                {
                    emitLine(out, 3, "offsetBits += " + bits + ";");
                }
                emitLine(out, 2, "}");
            }
            else
            {
                const auto optionArray = field.fieldName + "Array";
                emitLine(out, 2, "const " + optionArray + " = optionValue;");
                emitLine(out, 2, "if (!Array.isArray(" + optionArray + ")) {");
                emitLine(out,
                         3,
                         "throw new Error(\"" + codegen_diagnostic_text::fieldExpectsArray(field.fieldName, true) +
                             "\");");
                emitLine(out, 2, "}");
                if (!helpers.arrayValidate.empty())
                {
                    emitLine(out, 2, "if (!" + helpers.arrayValidate + "(" + optionArray + ".length)) {");
                    emitLine(out,
                             3,
                             "throw new Error(\"" +
                                 codegen_diagnostic_text::fieldExceedsMaxLength(field.fieldName, cap, true) + "\");");
                    emitLine(out, 2, "}");
                }
                else
                {
                    emitLine(out, 2, "if (" + optionArray + ".length > " + cap + ") {");
                    emitLine(out,
                             3,
                             "throw new Error(\"" +
                                 codegen_diagnostic_text::fieldExceedsMaxLength(field.fieldName, cap, true) + "\");");
                    emitLine(out, 2, "}");
                }
                std::string prefixExpr = optionArray + ".length";
                if (!helpers.serArrayPrefix.empty())
                {
                    prefixExpr = "Number(" + helpers.serArrayPrefix + "(" + prefixExpr + "))";
                }
                emitLine(out,
                         2,
                         "dsdlRuntime.writeUnsigned(out, offsetBits, " + prefixBits + ", " + prefixExpr + ", false);");
                emitLine(out, 2, "offsetBits += " + prefixBits + ";");
                emitLine(out, 2, "for (let i = 0; i < " + optionArray + ".length; ++i) {");
                if (field.kind == RuntimeFieldKind::Bool)
                {
                    emitLine(out, 3, "dsdlRuntime.setBit(out, offsetBits, " + optionArray + "[i]);");
                }
                else if (field.kind == RuntimeFieldKind::Composite)
                {
                    emitTsRuntimeSerializeCompositeValue(out,
                                                         3,
                                                         field,
                                                         optionArray + "[i] as " + compositeTypeName(field, ctx),
                                                         ctx);
                }
                else if (field.kind == RuntimeFieldKind::Unsigned)
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             3,
                             "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                else if (field.kind == RuntimeFieldKind::Float)
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out, 3, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
                }
                else
                {
                    std::string scalarExpr = optionArray + "[i]";
                    if (!helpers.serScalar.empty())
                    {
                        scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                    }
                    emitLine(out,
                             3,
                             "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " +
                                 saturating + ");");
                }
                if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
                {
                    emitLine(out, 3, "offsetBits += " + bits + ";");
                }
                emitLine(out, 2, "}");
            }
            emitLine(out, 2, "break;");
            emitLine(out, 1, "}");
        }
        emitLine(out, 1, "default:");
        emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::invalidUnionTagPrefix() + "\" + tag);");
        emitLine(out, 1, "}");
        emitLine(out, 1, "const alignedOffsetBits = dsdlRuntime.byteLengthForBits(offsetBits) * 8;");
        emitLine(out, 1, "for (let bit = offsetBits; bit < alignedOffsetBits; ++bit) {");
        emitLine(out, 2, "dsdlRuntime.setBit(out, bit, false);");
        emitLine(out, 1, "}");
        emitLine(out, 1, "offsetBits = alignedOffsetBits;");
        emitLine(out, 1, "const usedBytes = dsdlRuntime.byteLengthForBits(offsetBits);");
        emitLine(out, 1, "return out.subarray(0, usedBytes);");
        emitLine(out, 0, "}");
        emitLine(out, 0, "");

        emitLine(out,
                 0,
                 "export function " + deserializeFn + "(bytes: Uint8Array): { value: " + typeName +
                     "; consumed: number } {");
        emitDeserializeHelperBindings();
        emitLine(out, 1, "let offsetBits = 0;");
        emitLine(out, 1, "let tag = Math.trunc(dsdlRuntime.readUnsigned(bytes, offsetBits, " + tagBits + "));");
        emitLine(out, 1, "offsetBits += " + tagBits + ";");
        if (!sectionHelperNames.deserUnionTagMask.empty())
        {
            emitLine(out, 1, "tag = Number(" + sectionHelperNames.deserUnionTagMask + "(tag));");
        }
        if (!sectionHelperNames.unionTagValidate.empty())
        {
            emitLine(out, 1, "if (!" + sectionHelperNames.unionTagValidate + "(tag)) {");
            emitLine(out,
                     2,
                     "throw new Error(\"" + codegen_diagnostic_text::decodedInvalidUnionTagPrefix() + "\" + tag);");
            emitLine(out, 1, "}");
        }
        emitLine(out, 1, "let value: " + typeName + ";");
        emitLine(out, 1, "switch (tag) {");
        for (const auto& scriptedField : operationPlan.fields)
        {
            const auto& field       = scriptedField.body.field;
            const auto& helpers     = scriptedField.body.helpers;
            const auto  cardinality = scriptedField.cardinality;
            const auto  bits        = std::to_string(field.bitLength);
            const auto  optionTag   = std::to_string(field.unionOptionIndex);
            const auto  cap         = std::to_string(field.arrayCapacity);
            const auto  prefixBits  = std::to_string(field.arrayLengthPrefixBits);
            const auto  arrayElemType =
                field.kind == RuntimeFieldKind::Bool
                     ? "boolean"
                     : (field.kind == RuntimeFieldKind::Composite ? compositeTypeName(field, ctx)
                                                                  : (field.useBigInt ? "bigint" : "number"));
            emitLine(out, 1, "case " + optionTag + ": {");
            emitTsRuntimeAlignDeserialize(out, 2, field.alignmentBits);
            if (cardinality == ScriptedFieldCardinality::Scalar)
            {
                if (field.kind == RuntimeFieldKind::Padding)
                {
                    emitTsRuntimeDeserializePadding(out, 2, field);
                    emitLine(out, 2, "const optionValue = undefined;");
                }
                else if (field.kind == RuntimeFieldKind::Bool)
                {
                    emitLine(out, 2, "const optionValue = dsdlRuntime.getBit(bytes, offsetBits);");
                }
                else if (field.kind == RuntimeFieldKind::Composite)
                {
                    emitLine(out, 2, "let optionValue: " + compositeTypeName(field, ctx) + ";");
                    emitTsRuntimeDeserializeCompositeValue(out,
                                                           2,
                                                           field,
                                                           "optionValue",
                                                           ctx,
                                                           helpers.delimiterValidate);
                }
                else if (field.kind == RuntimeFieldKind::Unsigned)
                {
                    const std::string fn     = field.useBigInt ? "readUnsignedBigInt" : "readUnsigned";
                    const auto        rawVar = field.fieldName + "OptionRaw";
                    emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                    emitLine(out, 2, "const optionValue = " + normalizeTsDeserScalarExpr(field, helpers, rawVar) + ";");
                }
                else if (field.kind == RuntimeFieldKind::Float)
                {
                    const auto rawVar = field.fieldName + "OptionRaw";
                    emitLine(out, 2, "const " + rawVar + " = dsdlRuntime.readFloat(bytes, offsetBits, " + bits + ");");
                    emitLine(out, 2, "const optionValue = " + normalizeTsDeserScalarExpr(field, helpers, rawVar) + ";");
                }
                else
                {
                    const std::string fn     = field.useBigInt ? "readSignedBigInt" : "readSigned";
                    const auto        rawVar = field.fieldName + "OptionRaw";
                    emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                    emitLine(out, 2, "const optionValue = " + normalizeTsDeserScalarExpr(field, helpers, rawVar) + ";");
                }
                if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
                {
                    emitLine(out, 2, "offsetBits += " + bits + ";");
                }
            }
            else
            {
                std::string arrayLenExpr = cap;
                if (cardinality == ScriptedFieldCardinality::VariableArray)
                {
                    const auto rawLen = field.fieldName + "LengthRaw";
                    emitLine(out,
                             2,
                             "const " + rawLen + " = Math.trunc(dsdlRuntime.readUnsigned(bytes, offsetBits, " +
                                 prefixBits + "));");
                    emitLine(out, 2, "offsetBits += " + prefixBits + ";");
                    const auto normalizedLen = field.fieldName + "Length";
                    if (!helpers.deserArrayPrefix.empty())
                    {
                        emitLine(out,
                                 2,
                                 "const " + normalizedLen + " = Number(" + helpers.deserArrayPrefix + "(" + rawLen +
                                     "));");
                    }
                    else
                    {
                        emitLine(out, 2, "const " + normalizedLen + " = " + rawLen + ";");
                    }
                    if (!helpers.arrayValidate.empty())
                    {
                        emitLine(out, 2, "if (!" + helpers.arrayValidate + "(" + normalizedLen + ")) {");
                    }
                    else
                    {
                        emitLine(out, 2, "if (" + normalizedLen + " < 0 || " + normalizedLen + " > " + cap + ") {");
                    }
                    emitLine(out,
                             3,
                             "throw new Error(\"" +
                                 codegen_diagnostic_text::decodedLengthExceedsMaxLength(field.fieldName, cap, true) +
                                 "\");");
                    emitLine(out, 2, "}");
                    arrayLenExpr = normalizedLen;
                }
                const auto optionArray = field.fieldName + "Array";
                emitLine(out,
                         2,
                         "const " + optionArray + ": Array<" + arrayElemType + "> = new Array(" + arrayLenExpr + ");");
                emitLine(out, 2, "for (let i = 0; i < " + arrayLenExpr + "; ++i) {");
                if (field.kind == RuntimeFieldKind::Bool)
                {
                    emitLine(out, 3, optionArray + "[i] = dsdlRuntime.getBit(bytes, offsetBits);");
                }
                else if (field.kind == RuntimeFieldKind::Composite)
                {
                    emitTsRuntimeDeserializeCompositeValue(out,
                                                           3,
                                                           field,
                                                           optionArray + "[i]",
                                                           ctx,
                                                           helpers.delimiterValidate);
                }
                else if (field.kind == RuntimeFieldKind::Unsigned)
                {
                    const std::string fn     = field.useBigInt ? "readUnsignedBigInt" : "readUnsigned";
                    const auto        rawVar = field.fieldName + "ItemRaw";
                    emitLine(out, 3, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                    std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                    emitLine(out, 3, optionArray + "[i] = " + valueExpr + ";");
                }
                else if (field.kind == RuntimeFieldKind::Float)
                {
                    const auto rawVar = field.fieldName + "ItemRaw";
                    emitLine(out, 3, "const " + rawVar + " = dsdlRuntime.readFloat(bytes, offsetBits, " + bits + ");");
                    std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                    emitLine(out, 3, optionArray + "[i] = " + valueExpr + ";");
                }
                else
                {
                    const std::string fn     = field.useBigInt ? "readSignedBigInt" : "readSigned";
                    const auto        rawVar = field.fieldName + "ItemRaw";
                    emitLine(out, 3, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                    std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                    emitLine(out, 3, optionArray + "[i] = " + valueExpr + ";");
                }
                if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
                {
                    emitLine(out, 3, "offsetBits += " + bits + ";");
                }
                emitLine(out, 2, "}");
                emitLine(out, 2, "const optionValue = " + optionArray + ";");
            }
            emitLine(out,
                     2,
                     "value = { _tag: " + optionTag + ", " + field.fieldName + ": optionValue } as " + typeName + ";");
            emitLine(out, 2, "break;");
            emitLine(out, 1, "}");
        }
        emitLine(out, 1, "default:");
        emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::decodedInvalidUnionTagPrefix() + "\" + tag);");
        emitLine(out, 1, "}");
        emitLine(out, 1, "offsetBits = dsdlRuntime.byteLengthForBits(offsetBits) * 8;");
        emitLine(out, 1, "const consumed = Math.min(bytes.length, dsdlRuntime.byteLengthForBits(offsetBits));");
        emitLine(out, 1, "return { value, consumed };");
        emitLine(out, 0, "}");
        return;
    }

    emitLine(out, 0, "export function " + serializeFn + "(value: " + typeName + "): Uint8Array {");
    emitLine(out, 1, "const out = new Uint8Array(" + std::to_string(maxByteLength) + ");");
    emitLine(out, 1, "let offsetBits = 0;");
    emitSerializeHelperBindings();
    if (!sectionHelperNames.capacityCheck.empty())
    {
        emitLine(out, 1, "if (!" + sectionHelperNames.capacityCheck + "(out.length * 8)) {");
        emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::serializationBufferTooSmall() + "\");");
        emitLine(out, 1, "}");
    }
    for (const auto& scriptedField : operationPlan.fields)
    {
        const auto& field       = scriptedField.body.field;
        const auto& helpers     = scriptedField.body.helpers;
        const auto  cardinality = scriptedField.cardinality;
        const auto  bits        = std::to_string(field.bitLength);
        const auto  saturating  = field.castMode == CastMode::Saturated ? "true" : "false";
        emitTsRuntimeAlignSerialize(out, 1, field.alignmentBits, field.fieldName);

        if (cardinality == ScriptedFieldCardinality::Scalar)
        {
            if (field.kind == RuntimeFieldKind::Padding)
            {
                emitTsRuntimeSerializePadding(out, 1, field, field.fieldName);
            }
            else if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 1, "dsdlRuntime.setBit(out, offsetBits, value." + field.fieldName + ");");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeSerializeCompositeValue(out, 1, field, "value." + field.fieldName, ctx);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                std::string scalarExpr = "value." + field.fieldName;
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         1,
                         "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                std::string scalarExpr = "value." + field.fieldName;
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out, 1, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
            }
            else
            {
                std::string scalarExpr = "value." + field.fieldName;
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         1,
                         "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 1, "offsetBits += " + bits + ";");
            }
        }
        else if (cardinality == ScriptedFieldCardinality::FixedArray)
        {
            const auto cap      = std::to_string(field.arrayCapacity);
            const auto fieldArr = field.fieldName + "Array";
            emitLine(out, 1, "const " + fieldArr + " = value." + field.fieldName + ";");
            emitLine(out, 1, "if (!Array.isArray(" + fieldArr + ") || " + fieldArr + ".length !== " + cap + ") {");
            emitLine(out,
                     2,
                     "throw new Error(\"" +
                         codegen_diagnostic_text::fieldExpectsExactlyElements(field.fieldName, cap, false) + "\");");
            emitLine(out, 1, "}");
            emitLine(out, 1, "for (let i = 0; i < " + cap + "; ++i) {");
            if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 2, "dsdlRuntime.setBit(out, offsetBits, " + fieldArr + "[i]);");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeSerializeCompositeValue(out, 2, field, fieldArr + "[i]", ctx);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         2,
                         "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out, 2, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
            }
            else
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         2,
                         "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 2, "offsetBits += " + bits + ";");
            }
            emitLine(out, 1, "}");
        }
        else
        {
            const auto cap        = std::to_string(field.arrayCapacity);
            const auto prefixBits = std::to_string(field.arrayLengthPrefixBits);
            const auto fieldArr   = field.fieldName + "Array";
            emitLine(out, 1, "const " + fieldArr + " = value." + field.fieldName + ";");
            emitLine(out, 1, "if (!Array.isArray(" + fieldArr + ")) {");
            emitLine(out,
                     2,
                     "throw new Error(\"" + codegen_diagnostic_text::fieldExpectsArray(field.fieldName, false) +
                         "\");");
            emitLine(out, 1, "}");
            if (!helpers.arrayValidate.empty())
            {
                emitLine(out, 1, "if (!" + helpers.arrayValidate + "(" + fieldArr + ".length)) {");
                emitLine(out,
                         2,
                         "throw new Error(\"" +
                             codegen_diagnostic_text::fieldExceedsMaxLength(field.fieldName, cap, false) + "\");");
                emitLine(out, 1, "}");
            }
            else
            {
                emitLine(out, 1, "if (" + fieldArr + ".length > " + cap + ") {");
                emitLine(out,
                         2,
                         "throw new Error(\"" +
                             codegen_diagnostic_text::fieldExceedsMaxLength(field.fieldName, cap, false) + "\");");
                emitLine(out, 1, "}");
            }
            std::string prefixExpr = fieldArr + ".length";
            if (!helpers.serArrayPrefix.empty())
            {
                prefixExpr = "Number(" + helpers.serArrayPrefix + "(" + prefixExpr + "))";
            }
            emitLine(out,
                     1,
                     "dsdlRuntime.writeUnsigned(out, offsetBits, " + prefixBits + ", " + prefixExpr + ", false);");
            emitLine(out, 1, "offsetBits += " + prefixBits + ";");
            emitLine(out, 1, "for (let i = 0; i < " + fieldArr + ".length; ++i) {");
            if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 2, "dsdlRuntime.setBit(out, offsetBits, " + fieldArr + "[i]);");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeSerializeCompositeValue(out, 2, field, fieldArr + "[i]", ctx);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         2,
                         "dsdlRuntime.writeUnsigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out, 2, "dsdlRuntime.writeFloat(out, offsetBits, " + bits + ", " + scalarExpr + ");");
            }
            else
            {
                std::string scalarExpr = fieldArr + "[i]";
                if (!helpers.serScalar.empty())
                {
                    scalarExpr = helpers.serScalar + "(" + scalarExpr + ")";
                }
                emitLine(out,
                         2,
                         "dsdlRuntime.writeSigned(out, offsetBits, " + bits + ", " + scalarExpr + ", " + saturating +
                             ");");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 2, "offsetBits += " + bits + ";");
            }
            emitLine(out, 1, "}");
        }
    }
    emitLine(out, 1, "const usedBytes = dsdlRuntime.byteLengthForBits(offsetBits);");
    emitLine(out, 1, "return out.subarray(0, usedBytes);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");

    emitLine(out,
             0,
             "export function " + deserializeFn + "(bytes: Uint8Array): { value: " + typeName +
                 "; consumed: number } {");
    emitDeserializeHelperBindings();
    emitLine(out, 1, "const value = {} as " + typeName + ";");
    emitLine(out, 1, "let offsetBits = 0;");
    for (const auto& scriptedField : operationPlan.fields)
    {
        const auto& field       = scriptedField.body.field;
        const auto& helpers     = scriptedField.body.helpers;
        const auto  cardinality = scriptedField.cardinality;
        const auto  bits        = std::to_string(field.bitLength);
        emitTsRuntimeAlignDeserialize(out, 1, field.alignmentBits);
        if (cardinality == ScriptedFieldCardinality::Scalar)
        {
            if (field.kind == RuntimeFieldKind::Padding)
            {
                emitTsRuntimeDeserializePadding(out, 1, field);
            }
            else if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 1, "value." + field.fieldName + " = dsdlRuntime.getBit(bytes, offsetBits);");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeDeserializeCompositeValue(out,
                                                       1,
                                                       field,
                                                       "value." + field.fieldName,
                                                       ctx,
                                                       helpers.delimiterValidate);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                const std::string fn     = field.useBigInt ? "readUnsignedBigInt" : "readUnsigned";
                const auto        rawVar = field.fieldName + "Raw";
                emitLine(out, 1, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 1, "value." + field.fieldName + " = " + valueExpr + ";");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                const auto rawVar = field.fieldName + "Raw";
                emitLine(out, 1, "const " + rawVar + " = dsdlRuntime.readFloat(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 1, "value." + field.fieldName + " = " + valueExpr + ";");
            }
            else
            {
                const std::string fn     = field.useBigInt ? "readSignedBigInt" : "readSigned";
                const auto        rawVar = field.fieldName + "Raw";
                emitLine(out, 1, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 1, "value." + field.fieldName + " = " + valueExpr + ";");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 1, "offsetBits += " + bits + ";");
            }
            continue;
        }

        if (cardinality == ScriptedFieldCardinality::FixedArray)
        {
            const auto cap      = std::to_string(field.arrayCapacity);
            const auto fieldArr = field.fieldName + "Array";
            const auto arrayElemType =
                field.kind == RuntimeFieldKind::Bool
                    ? "boolean"
                    : (field.kind == RuntimeFieldKind::Composite ? compositeTypeName(field, ctx)
                                                                 : (field.useBigInt ? "bigint" : "number"));
            emitLine(out, 1, "const " + fieldArr + ": Array<" + arrayElemType + "> = new Array(" + cap + ");");
            emitLine(out, 1, "for (let i = 0; i < " + cap + "; ++i) {");
            if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 2, fieldArr + "[i] = dsdlRuntime.getBit(bytes, offsetBits);");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeDeserializeCompositeValue(out, 2, field, fieldArr + "[i]", ctx, helpers.delimiterValidate);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                const std::string fn     = field.useBigInt ? "readUnsignedBigInt" : "readUnsigned";
                const auto        rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                const auto rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime.readFloat(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            else
            {
                const std::string fn     = field.useBigInt ? "readSignedBigInt" : "readSigned";
                const auto        rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 2, "offsetBits += " + bits + ";");
            }
            emitLine(out, 1, "}");
            emitLine(out, 1, "value." + field.fieldName + " = " + fieldArr + ";");
        }
        else
        {
            const auto cap        = std::to_string(field.arrayCapacity);
            const auto prefixBits = std::to_string(field.arrayLengthPrefixBits);
            const auto fieldArr   = field.fieldName + "Array";
            const auto arrayElemType =
                field.kind == RuntimeFieldKind::Bool
                    ? "boolean"
                    : (field.kind == RuntimeFieldKind::Composite ? compositeTypeName(field, ctx)
                                                                 : (field.useBigInt ? "bigint" : "number"));
            const auto rawLen = field.fieldName + "LengthRaw";
            emitLine(out,
                     1,
                     "const " + rawLen + " = Math.trunc(dsdlRuntime.readUnsigned(bytes, offsetBits, " + prefixBits +
                         "));");
            emitLine(out, 1, "offsetBits += " + prefixBits + ";");
            const auto normalizedLen = field.fieldName + "Length";
            if (!helpers.deserArrayPrefix.empty())
            {
                emitLine(out,
                         1,
                         "const " + normalizedLen + " = Number(" + helpers.deserArrayPrefix + "(" + rawLen + "));");
            }
            else
            {
                emitLine(out, 1, "const " + normalizedLen + " = " + rawLen + ";");
            }
            if (!helpers.arrayValidate.empty())
            {
                emitLine(out, 1, "if (!" + helpers.arrayValidate + "(" + normalizedLen + ")) {");
            }
            else
            {
                emitLine(out, 1, "if (" + normalizedLen + " < 0 || " + normalizedLen + " > " + cap + ") {");
            }
            emitLine(out,
                     2,
                     "throw new Error(\"" +
                         codegen_diagnostic_text::decodedLengthExceedsMaxLength(field.fieldName, cap, false) + "\");");
            emitLine(out, 1, "}");
            emitLine(out,
                     1,
                     "const " + fieldArr + ": Array<" + arrayElemType + "> = new Array(" + field.fieldName +
                         "Length);");
            emitLine(out, 1, "for (let i = 0; i < " + normalizedLen + "; ++i) {");
            if (field.kind == RuntimeFieldKind::Bool)
            {
                emitLine(out, 2, fieldArr + "[i] = dsdlRuntime.getBit(bytes, offsetBits);");
            }
            else if (field.kind == RuntimeFieldKind::Composite)
            {
                emitTsRuntimeDeserializeCompositeValue(out, 2, field, fieldArr + "[i]", ctx, helpers.delimiterValidate);
            }
            else if (field.kind == RuntimeFieldKind::Unsigned)
            {
                const std::string fn     = field.useBigInt ? "readUnsignedBigInt" : "readUnsigned";
                const auto        rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            else if (field.kind == RuntimeFieldKind::Float)
            {
                const auto rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime.readFloat(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            else
            {
                const std::string fn     = field.useBigInt ? "readSignedBigInt" : "readSigned";
                const auto        rawVar = field.fieldName + "ItemRaw";
                emitLine(out, 2, "const " + rawVar + " = dsdlRuntime." + fn + "(bytes, offsetBits, " + bits + ");");
                std::string valueExpr = normalizeTsDeserScalarExpr(field, helpers, rawVar);
                emitLine(out, 2, fieldArr + "[i] = " + valueExpr + ";");
            }
            if (field.kind != RuntimeFieldKind::Composite && field.kind != RuntimeFieldKind::Padding)
            {
                emitLine(out, 2, "offsetBits += " + bits + ";");
            }
            emitLine(out, 1, "}");
            emitLine(out, 1, "value." + field.fieldName + " = " + fieldArr + ";");
        }
    }
    emitLine(out, 1, "const consumed = Math.min(bytes.length, dsdlRuntime.byteLengthForBits(offsetBits));");
    emitLine(out, 1, "return { value, consumed };");
    emitLine(out, 0, "}");
}

llvm::Expected<std::string> renderDefinitionFile(const SemanticDefinition& def,
                                                 const EmitterContext&     ctx,
                                                 const LoweredFactsMap&    loweredFacts)
{
    std::ostringstream out;
    emitLine(out, 0, generatedCommentLine("TypeScript backend"));
    emitLine(out,
             0,
             "// Source: " + def.info.fullName + "." + std::to_string(def.info.majorVersion) + "." +
                 std::to_string(def.info.minorVersion));

    const llvm::StringRef      requestSectionKey   = def.isService ? "request" : "";
    const LoweredSectionFacts* requestSectionFacts = lookupLoweredSectionFacts(loweredFacts, def, requestSectionKey);
    auto                       requestRuntimePlan  = buildRuntimeSectionPlan(def.request, requestSectionFacts);
    if (!requestRuntimePlan)
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                       "failed to build TypeScript request runtime plan for '%s': %s",
                                       def.info.fullName.c_str(),
                                       llvm::toString(requestRuntimePlan.takeError()).c_str());
    }
    std::optional<RuntimeSectionPlan> responseRuntimePlanStorage;
    const RuntimeSectionPlan*         responseRuntimePlan = nullptr;
    if (def.response)
    {
        const auto* const responseSectionFacts = lookupLoweredSectionFacts(loweredFacts, def, "response");
        auto              responsePlanOrErr    = buildRuntimeSectionPlan(*def.response, responseSectionFacts);
        if (!responsePlanOrErr)
        {
            return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                           "failed to build TypeScript response runtime plan for '%s': %s",
                                           def.info.fullName.c_str(),
                                           llvm::toString(responsePlanOrErr.takeError()).c_str());
        }
        responseRuntimePlanStorage = std::move(*responsePlanOrErr);
        responseRuntimePlan        = &(*responseRuntimePlanStorage);
    }

    std::map<std::string, std::set<std::string>> importsByModule;
    const auto                                   ownerPath         = ctx.relativeFilePath(def.info);
    const auto                                   addSectionImports = [&](const SemanticSection& section) {
        const auto dependencies = collectCompositeDependencies(section, def.info);
        const auto imports      = projectCompositeImports(
            dependencies,
            [&](const SemanticTypeRef& ref) { return relativeImportPath(ownerPath, ctx.relativeFilePath(ref)); },
            [&](const SemanticTypeRef& ref) { return ctx.typeName(ref); });
        for (const auto& importSpec : imports)
        {
            importsByModule[importSpec.modulePath].insert(importSpec.typeName);
        }
    };
    addSectionImports(def.request);
    if (def.response)
    {
        addSectionImports(*def.response);
    }

    std::map<std::string, std::set<std::string>> runtimeImportsByModule;
    const auto                                   addRuntimeImportsForPlan = [&](const RuntimeSectionPlan* const plan) {
        if (plan == nullptr)
        {
            return;
        }
        for (const auto& field : plan->fields)
        {
            if (field.kind != RuntimeFieldKind::Composite || !field.compositeType)
            {
                continue;
            }
            const auto targetPath = ctx.relativeFilePath(*field.compositeType);
            if (targetPath == ownerPath)
            {
                continue;
            }
            const auto modulePath = relativeImportPath(ownerPath, targetPath);
            const auto typeName   = compositeTypeName(field, ctx);
            runtimeImportsByModule[modulePath].insert(tsRuntimeSerializeFn(typeName));
            runtimeImportsByModule[modulePath].insert(tsRuntimeDeserializeFn(typeName));
        }
    };
    addRuntimeImportsForPlan(&(*requestRuntimePlan));
    addRuntimeImportsForPlan(responseRuntimePlan);

    const auto runtimePath = relativeImportPath(ownerPath, std::filesystem::path("dsdl_runtime.ts"));
    emitLine(out, 0, "import * as dsdlRuntime from \"" + runtimePath + "\";");
    emitLine(out, 0, "");

    for (const auto& [modulePath, names] : runtimeImportsByModule)
    {
        std::string importNames;
        for (const auto& name : names)
        {
            if (!importNames.empty())
            {
                importNames += ", ";
            }
            importNames += name;
        }
        emitLine(out, 0, "import { " + importNames + " } from \"" + modulePath + "\";");
    }

    for (const auto& [modulePath, names] : importsByModule)
    {
        std::string importNames;
        for (const auto& name : names)
        {
            if (!importNames.empty())
            {
                importNames += ", ";
            }
            importNames += name;
        }
        emitLine(out, 0, "import type { " + importNames + " } from \"" + modulePath + "\";");
    }
    const auto baseType = ctx.typeName(def.info);
    emitLine(out, 0, "export const LLVMDSDL_GENERATOR_VERSION = \"" + std::string(llvmdsdl::kVersionString) + "\";");
    emitLine(out, 0, "export const DSDL_FULL_NAME = \"" + def.info.fullName + "\";");
    emitLine(out, 0, "export const DSDL_VERSION_MAJOR = " + std::to_string(def.info.majorVersion) + ";");
    emitLine(out, 0, "export const DSDL_VERSION_MINOR = " + std::to_string(def.info.minorVersion) + ";");
    emitLine(out, 0, "");

    if (!def.isService)
    {
        emitSectionType(out, baseType, def.request, ctx);
        emitLine(out, 0, "");
        emitSectionConstants(out, baseType, def.request);
        emitLine(out, 0, "");
        emitTsRuntimeFunctions(out, baseType, *requestRuntimePlan, ctx, def.request, requestSectionFacts);
        return out.str();
    }

    const auto reqType  = baseType + "_Request";
    const auto respType = baseType + "_Response";

    emitSectionType(out, reqType, def.request, ctx);
    emitLine(out, 0, "");
    emitSectionConstants(out, reqType, def.request);
    emitLine(out, 0, "");
    emitTsRuntimeFunctions(out, reqType, *requestRuntimePlan, ctx, def.request, requestSectionFacts);
    emitLine(out, 0, "");

    if (def.response)
    {
        emitSectionType(out, respType, *def.response, ctx);
        emitLine(out, 0, "");
        emitSectionConstants(out, respType, *def.response);
        emitLine(out, 0, "");
        emitTsRuntimeFunctions(out,
                               respType,
                               *responseRuntimePlan,
                               ctx,
                               *def.response,
                               lookupLoweredSectionFacts(loweredFacts, def, "response"));
        emitLine(out, 0, "");
    }

    emitLine(out, 0, "export type " + baseType + " = " + reqType + ";");
    return out.str();
}

std::string renderPackageJson(const TsEmitOptions& options)
{
    const auto runtimeSpecialization =
        options.runtimeSpecialization == TsRuntimeSpecialization::Fast ? "fast" : "portable";
    std::ostringstream out;
    out << "{\n";
    out << "  \"name\": \"" << options.moduleName << "\",\n";
    out << "  \"version\": \"" << llvmdsdl::kVersionString << "\",\n";
    out << "  \"type\": \"module\",\n";
    out << "  \"llvmdsdl\": {\n";
    out << "    \"generatorVersion\": \"" << llvmdsdl::kVersionString << "\",\n";
    out << "    \"tsRuntimeSpecialization\": \"" << runtimeSpecialization << "\"\n";
    out << "  }\n";
    out << "}\n";
    return out.str();
}

std::string renderTsRuntimeModule(const TsRuntimeSpecialization runtimeSpecialization)
{
    std::ostringstream out;
    emitLine(out, 0, generatedCommentLine("TypeScript runtime scaffold"));
    emitLine(out, 0, "");
    emitLine(out, 0, "function toBigIntValue(value: number | bigint): bigint {");
    emitLine(out, 1, "if (typeof value === \"bigint\") {");
    emitLine(out, 2, "return value;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (!Number.isFinite(value)) {");
    emitLine(out, 2, "return 0n;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return BigInt(Math.trunc(value));");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function maskBits(lenBits: number): bigint {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return 0n;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return (1n << BigInt(lenBits)) - 1n;");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function byteLengthForBits(totalBits: number): number {");
    emitLine(out, 1, "if (totalBits <= 0) {");
    emitLine(out, 2, "return 0;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return Math.floor((totalBits + 7) / 8);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function setRawBit(buf: Uint8Array, offBits: number, bit: boolean): void {");
    emitLine(out, 1, "const byteIndex = Math.floor(offBits / 8);");
    emitLine(out, 1, "const bitIndex = offBits % 8;");
    emitLine(out, 1, "if (byteIndex < 0 || byteIndex >= buf.length) {");
    emitLine(out, 2, "throw new Error(\"" + codegen_diagnostic_text::serializationBufferTooSmall() + "\");");
    emitLine(out, 1, "}");
    emitLine(out, 1, "const mask = 1 << bitIndex;");
    emitLine(out, 1, "if (bit) {");
    emitLine(out, 2, "buf[byteIndex] = (buf[byteIndex] | mask) & 0xff;");
    emitLine(out, 1, "} else {");
    emitLine(out, 2, "buf[byteIndex] = (buf[byteIndex] & (~mask)) & 0xff;");
    emitLine(out, 1, "}");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function getRawBit(buf: Uint8Array, offBits: number): boolean {");
    emitLine(out, 1, "const byteIndex = Math.floor(offBits / 8);");
    emitLine(out, 1, "const bitIndex = offBits % 8;");
    emitLine(out, 1, "if (byteIndex < 0 || byteIndex >= buf.length) {");
    emitLine(out, 2, "return false;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return ((buf[byteIndex] >> bitIndex) & 1) === 1;");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function writeUnsignedBits(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number,");
    emitLine(out, 1, "value: bigint");
    emitLine(out, 0, "): void {");
    emitLine(out, 1, "for (let i = 0; i < lenBits; ++i) {");
    emitLine(out, 2, "const bit = ((value >> BigInt(i)) & 1n) === 1n;");
    emitLine(out, 2, "setRawBit(buf, offBits + i, bit);");
    emitLine(out, 1, "}");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function readUnsignedBits(buf: Uint8Array, offBits: number, lenBits: number): bigint {");
    emitLine(out, 1, "let out = 0n;");
    emitLine(out, 1, "for (let i = 0; i < lenBits; ++i) {");
    emitLine(out, 2, "if (getRawBit(buf, offBits + i)) {");
    emitLine(out, 3, "out |= (1n << BigInt(i));");
    emitLine(out, 2, "}");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return out;");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function setBit(buf: Uint8Array, offBits: number, value: boolean): void {");
    emitLine(out, 1, "setRawBit(buf, offBits, !!value);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function getBit(buf: Uint8Array, offBits: number): boolean {");
    emitLine(out, 1, "return getRawBit(buf, offBits);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function copyBits(");
    emitLine(out, 1, "dst: Uint8Array,");
    emitLine(out, 1, "dstOffBits: number,");
    emitLine(out, 1, "src: Uint8Array,");
    emitLine(out, 1, "srcOffBits: number,");
    emitLine(out, 1, "lenBits: number");
    emitLine(out, 0, "): void {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    if (runtimeSpecialization == TsRuntimeSpecialization::Fast)
    {
        emitLine(out, 1, "if (dst !== src && dstOffBits % 8 === 0 && srcOffBits % 8 === 0 && lenBits % 8 === 0) {");
        emitLine(out, 2, "const dstStart = Math.floor(dstOffBits / 8);");
        emitLine(out, 2, "const srcStart = Math.floor(srcOffBits / 8);");
        emitLine(out, 2, "const byteLen = Math.floor(lenBits / 8);");
        emitLine(out, 2, "if (dstStart >= 0 && srcStart >= 0 &&");
        emitLine(out, 3, "dstStart + byteLen <= dst.length && srcStart + byteLen <= src.length) {");
        emitLine(out, 3, "dst.set(src.subarray(srcStart, srcStart + byteLen), dstStart);");
        emitLine(out, 3, "return;");
        emitLine(out, 2, "}");
        emitLine(out, 1, "}");
    }
    emitLine(out, 1, "for (let i = 0; i < lenBits; ++i) {");
    emitLine(out, 2, "setRawBit(dst, dstOffBits + i, getRawBit(src, srcOffBits + i));");
    emitLine(out, 1, "}");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function extractBits(");
    emitLine(out, 1, "src: Uint8Array,");
    emitLine(out, 1, "srcOffBits: number,");
    emitLine(out, 1, "lenBits: number");
    emitLine(out, 0, "): Uint8Array {");
    if (runtimeSpecialization == TsRuntimeSpecialization::Fast)
    {
        emitLine(out, 1, "if (srcOffBits % 8 === 0 && lenBits % 8 === 0) {");
        emitLine(out, 2, "const srcStart = Math.floor(srcOffBits / 8);");
        emitLine(out, 2, "const byteLen = Math.floor(lenBits / 8);");
        emitLine(out, 2, "if (srcStart >= 0 && srcStart + byteLen <= src.length) {");
        emitLine(out, 3, "return src.slice(srcStart, srcStart + byteLen);");
        emitLine(out, 2, "}");
        emitLine(out, 1, "}");
    }
    emitLine(out, 1, "const out = new Uint8Array(byteLengthForBits(lenBits));");
    emitLine(out, 1, "copyBits(out, 0, src, srcOffBits, lenBits);");
    emitLine(out, 1, "return out;");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function writeUnsigned(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number,");
    emitLine(out, 1, "value: number | bigint,");
    emitLine(out, 1, "saturating: boolean");
    emitLine(out, 0, "): void {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "const max = maskBits(lenBits);");
    emitLine(out, 1, "let inValue = toBigIntValue(value);");
    emitLine(out, 1, "if (saturating) {");
    emitLine(out, 2, "if (inValue < 0n) {");
    emitLine(out, 3, "inValue = 0n;");
    emitLine(out, 2, "} else if (inValue > max) {");
    emitLine(out, 3, "inValue = max;");
    emitLine(out, 2, "}");
    emitLine(out, 1, "} else {");
    emitLine(out, 2, "inValue = BigInt.asUintN(lenBits, inValue);");
    emitLine(out, 1, "}");
    emitLine(out, 1, "writeUnsignedBits(buf, offBits, lenBits, inValue);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function writeSigned(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number,");
    emitLine(out, 1, "value: number | bigint,");
    emitLine(out, 1, "saturating: boolean");
    emitLine(out, 0, "): void {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "let inValue = toBigIntValue(value);");
    emitLine(out, 1, "if (saturating) {");
    emitLine(out, 2, "const min = -(1n << BigInt(lenBits - 1));");
    emitLine(out, 2, "const max = (1n << BigInt(lenBits - 1)) - 1n;");
    emitLine(out, 2, "if (inValue < min) {");
    emitLine(out, 3, "inValue = min;");
    emitLine(out, 2, "} else if (inValue > max) {");
    emitLine(out, 3, "inValue = max;");
    emitLine(out, 2, "}");
    emitLine(out, 1, "}");
    emitLine(out, 1, "writeUnsignedBits(buf, offBits, lenBits, BigInt.asUintN(lenBits, inValue));");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function float32ToBits(value: number): number {");
    emitLine(out, 1, "const bytes = new ArrayBuffer(4);");
    emitLine(out, 1, "const view = new DataView(bytes);");
    emitLine(out, 1, "view.setFloat32(0, value, true);");
    emitLine(out, 1, "return view.getUint32(0, true);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function bitsToFloat32(bits: number): number {");
    emitLine(out, 1, "const bytes = new ArrayBuffer(4);");
    emitLine(out, 1, "const view = new DataView(bytes);");
    emitLine(out, 1, "view.setUint32(0, bits >>> 0, true);");
    emitLine(out, 1, "return view.getFloat32(0, true);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function float64ToBits(value: number): bigint {");
    emitLine(out, 1, "const bytes = new ArrayBuffer(8);");
    emitLine(out, 1, "const view = new DataView(bytes);");
    emitLine(out, 1, "view.setFloat64(0, value, true);");
    emitLine(out, 1, "return view.getBigUint64(0, true);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function bitsToFloat64(bits: bigint): number {");
    emitLine(out, 1, "const bytes = new ArrayBuffer(8);");
    emitLine(out, 1, "const view = new DataView(bytes);");
    emitLine(out, 1, "view.setBigUint64(0, bits, true);");
    emitLine(out, 1, "return view.getFloat64(0, true);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function float16ToBits(value: number): number {");
    emitLine(out, 1, "if (Number.isNaN(value)) {");
    emitLine(out, 2, "return 0x7e00;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (value === Infinity) {");
    emitLine(out, 2, "return 0x7c00;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (value === -Infinity) {");
    emitLine(out, 2, "return 0xfc00;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "const bits = float32ToBits(value);");
    emitLine(out, 1, "const sign = (bits >>> 16) & 0x8000;");
    emitLine(out, 1, "let exp = ((bits >>> 23) & 0xff) - 127 + 15;");
    emitLine(out, 1, "let mant = bits & 0x7fffff;");
    emitLine(out, 1, "if (exp <= 0) {");
    emitLine(out, 2, "if (exp < -10) {");
    emitLine(out, 3, "return sign;");
    emitLine(out, 2, "}");
    emitLine(out, 2, "mant = (mant | 0x800000) >>> (1 - exp);");
    emitLine(out, 2, "if ((mant & 0x1000) !== 0) {");
    emitLine(out, 3, "mant += 0x2000;");
    emitLine(out, 2, "}");
    emitLine(out, 2, "return sign | (mant >>> 13);");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (exp >= 0x1f) {");
    emitLine(out, 2, "return sign | 0x7c00;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if ((mant & 0x1000) !== 0) {");
    emitLine(out, 2, "mant += 0x2000;");
    emitLine(out, 2, "if ((mant & 0x800000) !== 0) {");
    emitLine(out, 3, "mant = 0;");
    emitLine(out, 3, "exp += 1;");
    emitLine(out, 3, "if (exp >= 0x1f) {");
    emitLine(out, 4, "return sign | 0x7c00;");
    emitLine(out, 3, "}");
    emitLine(out, 2, "}");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return sign | (exp << 10) | (mant >>> 13);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "function bitsToFloat16(bits: number): number {");
    emitLine(out, 1, "const sign = (bits & 0x8000) !== 0 ? -1 : 1;");
    emitLine(out, 1, "const exp = (bits >>> 10) & 0x1f;");
    emitLine(out, 1, "const mant = bits & 0x03ff;");
    emitLine(out, 1, "if (exp === 0) {");
    emitLine(out, 2, "if (mant === 0) {");
    emitLine(out, 3, "return sign * 0;");
    emitLine(out, 2, "}");
    emitLine(out, 2, "return sign * Math.pow(2, -14) * (mant / 1024);");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (exp === 0x1f) {");
    emitLine(out, 2, "return mant === 0 ? sign * Infinity : Number.NaN;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return sign * Math.pow(2, exp - 15) * (1 + (mant / 1024));");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function writeFloat(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number,");
    emitLine(out, 1, "value: number");
    emitLine(out, 0, "): void {");
    emitLine(out, 1, "if (lenBits === 16) {");
    emitLine(out, 2, "writeUnsignedBits(buf, offBits, lenBits, BigInt(float16ToBits(value)));");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (lenBits === 32) {");
    emitLine(out, 2, "writeUnsignedBits(buf, offBits, lenBits, BigInt(float32ToBits(value)));");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (lenBits === 64) {");
    emitLine(out, 2, "writeUnsignedBits(buf, offBits, lenBits, float64ToBits(value));");
    emitLine(out, 2, "return;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "throw new Error(\"unsupported float bit length \" + lenBits);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function readFloat(buf: Uint8Array, offBits: number, lenBits: number): number {");
    emitLine(out, 1, "if (lenBits === 16) {");
    emitLine(out, 2, "return bitsToFloat16(Number(readUnsignedBits(buf, offBits, lenBits)));");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (lenBits === 32) {");
    emitLine(out, 2, "return bitsToFloat32(Number(readUnsignedBits(buf, offBits, lenBits)));");
    emitLine(out, 1, "}");
    emitLine(out, 1, "if (lenBits === 64) {");
    emitLine(out, 2, "return bitsToFloat64(readUnsignedBits(buf, offBits, lenBits));");
    emitLine(out, 1, "}");
    emitLine(out, 1, "throw new Error(\"unsupported float bit length \" + lenBits);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function readUnsignedBigInt(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number");
    emitLine(out, 0, "): bigint {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return 0n;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return readUnsignedBits(buf, offBits, lenBits);");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function readSignedBigInt(");
    emitLine(out, 1, "buf: Uint8Array,");
    emitLine(out, 1, "offBits: number,");
    emitLine(out, 1, "lenBits: number");
    emitLine(out, 0, "): bigint {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return 0n;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "const raw = readUnsignedBits(buf, offBits, lenBits);");
    emitLine(out, 1, "const signBit = 1n << BigInt(lenBits - 1);");
    emitLine(out, 1, "if ((raw & signBit) !== 0n) {");
    emitLine(out, 2, "return raw - (1n << BigInt(lenBits));");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return raw;");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function readUnsigned(buf: Uint8Array, offBits: number, lenBits: number): number {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return 0;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return Number(readUnsignedBigInt(buf, offBits, lenBits));");
    emitLine(out, 0, "}");
    emitLine(out, 0, "");
    emitLine(out, 0, "export function readSigned(buf: Uint8Array, offBits: number, lenBits: number): number {");
    emitLine(out, 1, "if (lenBits <= 0) {");
    emitLine(out, 2, "return 0;");
    emitLine(out, 1, "}");
    emitLine(out, 1, "return Number(readSignedBigInt(buf, offBits, lenBits));");
    emitLine(out, 0, "}");
    return out.str();
}

}  // namespace

llvm::Error emitTs(const SemanticModule& semantic,
                   mlir::ModuleOp        module,
                   const TsEmitOptions&  options,
                   DiagnosticEngine&     diagnostics)
{
    if (options.outDir.empty())
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "output directory is required");
    }

    LoweredFactsMap loweredFacts;
    if (!collectLoweredFactsFromMlir(semantic,
                                     module,
                                     diagnostics,
                                     "TypeScript",
                                     &loweredFacts,
                                     options.optimizeLoweredSerDes))
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                       "MLIR schema coverage validation failed for TypeScript emission");
    }

    std::filesystem::path outRoot(options.outDir);
    const auto            selectedTypeKeys = makeTypeKeySet(options.selectedTypeKeys);

    if (options.emitPackageJson)
    {
        if (auto err = writeGeneratedFile(outRoot / "package.json", renderPackageJson(options), options.writePolicy))
        {
            return err;
        }
    }
    if (auto err = writeGeneratedFile(outRoot / "dsdl_runtime.ts",
                                      renderTsRuntimeModule(options.runtimeSpecialization),
                                      options.writePolicy))
    {
        return err;
    }

    EmitterContext ctx(semantic);

    std::vector<const SemanticDefinition*> ordered;
    ordered.reserve(semantic.definitions.size());
    for (const auto& def : semantic.definitions)
    {
        if (!shouldEmitDefinition(def.info, selectedTypeKeys))
        {
            continue;
        }
        ordered.push_back(&def);
    }
    std::sort(ordered.begin(), ordered.end(), [](const auto* lhs, const auto* rhs) {
        if (lhs->info.fullName != rhs->info.fullName)
        {
            return lhs->info.fullName < rhs->info.fullName;
        }
        if (lhs->info.majorVersion != rhs->info.majorVersion)
        {
            return lhs->info.majorVersion < rhs->info.majorVersion;
        }
        return lhs->info.minorVersion < rhs->info.minorVersion;
    });

    std::vector<std::filesystem::path> generatedRelativePaths;
    generatedRelativePaths.reserve(ordered.size());

    for (const auto* def : ordered)
    {
        const auto relPath = ctx.relativeFilePath(def->info);
        generatedRelativePaths.push_back(relPath);

        const auto fullPath = outRoot / relPath;
        auto       rendered = renderDefinitionFile(*def, ctx, loweredFacts);
        if (!rendered)
        {
            return rendered.takeError();
        }

        if (auto err = writeGeneratedFile(fullPath, *rendered, options.writePolicy))
        {
            return err;
        }
    }

    std::ostringstream index;
    emitLine(index, 0, generatedCommentLine("TypeScript backend index"));
    std::map<std::string, unsigned> aliasUseCount;
    for (const auto& relPath : generatedRelativePaths)
    {
        std::string modulePath = relPath.generic_string();
        if (modulePath.size() >= 3 && modulePath.ends_with(".ts"))
        {
            modulePath.resize(modulePath.size() - 3);
        }
        std::string alias    = moduleAliasFromPath(modulePath);
        unsigned&   useCount = aliasUseCount[alias];
        if (useCount > 0)
        {
            alias += "_" + std::to_string(useCount);
        }
        ++useCount;

        emitLine(index, 0, "export * as " + alias + " from \"./" + modulePath + "\";");
    }

    if (auto err = writeGeneratedFile(outRoot / "index.ts", index.str(), options.writePolicy))
    {
        return err;
    }

    return llvm::Error::success();
}

}  // namespace llvmdsdl
