//===----------------------------------------------------------------------===//
//
// Part of the OpenCyphal project, under the MIT licence
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
///
/// @file
/// Implements C++ backend code emission from lowered DSDL modules.
///
/// The implementation translates lowered section plans into C++ encode and decode routines plus supporting type
/// wrappers.
///
//===----------------------------------------------------------------------===//

#include "llvmdsdl/CodeGen/CppEmitter.h"

#include <llvm/ADT/StringRef.h>
#include <llvm/Support/Error.h>
#include <cassert>
#include <cctype>
#include <filesystem>
#include <fstream>
#include <optional>
#include <sstream>
#include <unordered_map>
#include <vector>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <system_error>
#include <variant>

#include "llvmdsdl/CodeGen/ArrayWirePlan.h"
#include "llvmdsdl/CodeGen/CodegenDiagnosticText.h"
#include "llvmdsdl/CodeGen/ConstantLiteralRender.h"
#include "llvmdsdl/CodeGen/DefinitionDependencies.h"
#include "llvmdsdl/CodeGen/DefinitionIndex.h"
#include "llvmdsdl/CodeGen/HelperBindingRender.h"
#include "llvmdsdl/CodeGen/HelperSymbolResolver.h"
#include "llvmdsdl/CodeGen/LoweredRenderIR.h"
#include "llvmdsdl/CodeGen/LoweredFactsLookup.h"
#include "llvmdsdl/CodeGen/MlirLoweredFacts.h"
#include "llvmdsdl/CodeGen/NamingPolicy.h"
#include "llvmdsdl/CodeGen/HelperBindingNaming.h"
#include "llvmdsdl/CodeGen/NativeEmitterTraversal.h"
#include "llvmdsdl/CodeGen/NativeFunctionSkeleton.h"
#include "llvmdsdl/CodeGen/SerDesHelperDescriptors.h"
#include "llvmdsdl/CodeGen/StorageTypeTokens.h"
#include "llvmdsdl/CodeGen/TypeStorage.h"
#include "llvmdsdl/CodeGen/WireLayoutFacts.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Support/raw_ostream.h"
#include "llvmdsdl/CodeGen/SectionHelperBindingPlan.h"
#include "llvmdsdl/CodeGen/SerDesStatementPlan.h"
#include "llvmdsdl/Frontend/AST.h"
#include "llvmdsdl/Semantics/BitLengthSet.h"
#include "llvmdsdl/Semantics/Evaluator.h"
#include "llvmdsdl/Semantics/Model.h"
#include "llvmdsdl/Support/Rational.h"
#include "llvmdsdl/Version.h"
#include "mlir/IR/BuiltinOps.h"

namespace llvmdsdl
{
class DiagnosticEngine;

namespace
{

std::string sanitizeMacroToken(std::string token)
{
    for (char& c : token)
    {
        if (!(std::isalnum(static_cast<unsigned char>(c)) || c == '_'))
        {
            c = '_';
        }
        else
        {
            c = static_cast<char>(std::toupper(static_cast<unsigned char>(c)));
        }
    }
    if (!token.empty() && std::isdigit(static_cast<unsigned char>(token.front())))
    {
        token.insert(token.begin(), '_');
    }
    return token;
}

std::string headerFileName(const DiscoveredDefinition& info)
{
    return llvm::formatv("{0}_{1}_{2}.hpp", info.shortName, info.majorVersion, info.minorVersion).str();
}

std::string headerGuard(const DiscoveredDefinition& info)
{
    std::string g = "LLVMDSDL_CPP_" + info.fullName + "_" + std::to_string(info.majorVersion) + "_" +
                    std::to_string(info.minorVersion) + "_HPP";
    for (char& c : g)
    {
        if (!std::isalnum(static_cast<unsigned char>(c)))
        {
            c = '_';
        }
        else
        {
            c = static_cast<char>(std::toupper(static_cast<unsigned char>(c)));
        }
    }
    return g;
}

std::string valueToCppExpr(const Value& value)
{
    return renderConstantLiteral(ConstantLiteralLanguage::Cpp, value);
}

std::string unsignedStorageType(const std::uint32_t bitLength)
{
    return renderUnsignedStorageToken(StorageTokenLanguage::Cpp, bitLength);
}

std::string signedStorageType(const std::uint32_t bitLength)
{
    return renderSignedStorageToken(StorageTokenLanguage::Cpp, bitLength);
}

std::string unsignedGetter(const std::uint32_t bitLength)
{
    return "dsdl_runtime_get_u" + std::string(scalarWidthSuffix(bitLength));
}

std::string generatedCommentLine(llvm::StringRef detail)
{
    return llvm::formatv("// Generated by llvmdsdl {0} ({1}).", llvmdsdl::kVersionString, detail).str();
}

void emitAttachedDocCpp(std::ostringstream& out, const int indent, const AttachedDoc& doc)
{
    for (const auto& line : doc.lines)
    {
        out << std::string(static_cast<std::size_t>(indent) * 2U, ' ') << "// " << line.text << '\n';
    }
}

std::string cppNamespacePath(const std::vector<std::string>& components)
{
    std::string out;
    for (const auto& component : components)
    {
        if (!out.empty())
        {
            out += "::";
        }
        out += codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, component);
    }
    return out;
}

void emitNamespaceOpen(std::ostringstream& out, const std::vector<std::string>& components)
{
    if (components.empty())
    {
        return;
    }
    for (const auto& component : components)
    {
        out << "namespace " << codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, component) << " {\n";
    }
    out << "\n";
}

void emitNamespaceClose(std::ostringstream& out, const std::vector<std::string>& components)
{
    if (components.empty())
    {
        return;
    }
    out << "\n";
    for (auto it = components.rbegin(); it != components.rend(); ++it)
    {
        out << "} // namespace " << codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, *it) << "\n";
    }
}

class EmitterContext final
{
public:
    explicit EmitterContext(const SemanticModule& semantic)
        : index_(semantic)
    {
        for (const auto& def : semantic.definitions)
        {
            versionCountByFullName_[def.info.fullName] += 1U;
        }
    }

    const SemanticDefinition* find(const SemanticTypeRef& ref) const
    {
        return index_.find(ref);
    }

    std::string cppTypeName(const DiscoveredDefinition& info) const
    {
        std::string out = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, info.shortName);
        const auto  it  = versionCountByFullName_.find(info.fullName);
        if (it != versionCountByFullName_.end() && it->second > 1U)
        {
            out += "_" + std::to_string(info.majorVersion) + "_" + std::to_string(info.minorVersion);
        }
        return out;
    }

    std::string cppTypeName(const SemanticDefinition& def) const
    {
        return cppTypeName(def.info);
    }

    std::string cppTypeName(const SemanticTypeRef& ref) const
    {
        if (const auto* def = find(ref))
        {
            return cppTypeName(*def);
        }

        std::string out = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, ref.shortName);
        out += "_" + std::to_string(ref.majorVersion) + "_" + std::to_string(ref.minorVersion);
        return out;
    }

    std::string cppQualifiedTypeName(const SemanticDefinition& def) const
    {
        std::string out = "::";
        const auto  ns  = cppNamespacePath(def.info.namespaceComponents);
        if (!ns.empty())
        {
            out += ns + "::";
        }
        out += cppTypeName(def);
        return out;
    }

    std::string cppQualifiedTypeName(const SemanticTypeRef& ref) const
    {
        if (const auto* def = find(ref))
        {
            return cppQualifiedTypeName(*def);
        }

        std::string out = "::";
        const auto  ns  = cppNamespacePath(ref.namespaceComponents);
        if (!ns.empty())
        {
            out += ns + "::";
        }
        out += cppTypeName(ref);
        return out;
    }

    std::string relativeHeaderPath(const SemanticDefinition& def) const
    {
        std::filesystem::path p;
        for (const auto& ns : def.info.namespaceComponents)
        {
            p /= ns;
        }
        p /= headerFileName(def.info);
        return p.generic_string();
    }

private:
    DefinitionIndex                              index_;
    std::unordered_map<std::string, std::size_t> versionCountByFullName_;
};

void emitLine(std::ostringstream& out, const int indent, const std::string& line)
{
    out << std::string(static_cast<std::size_t>(indent) * 2U, ' ') << line << '\n';
}

enum class CppFlavor
{
    Std,
    Pmr,
    Autosar,
};

bool isPmrFlavor(const CppFlavor flavor)
{
    return flavor == CppFlavor::Pmr;
}

bool isAutosarFlavor(const CppFlavor flavor)
{
    return flavor == CppFlavor::Autosar;
}

class FunctionBodyEmitter final
{
public:
    explicit FunctionBodyEmitter(const EmitterContext& ctx, const CppFlavor flavor)
        : ctx_(ctx)
        , flavor_(flavor)
    {
    }

    void emitSerializeFunction(std::ostringstream&              out,
                               const std::string&               typeName,
                               const SemanticSection&           section,
                               const LoweredSectionFacts* const sectionFacts)
    {
        emitLine(out,
                 0,
                 "inline std::int8_t " + typeName + "__serialize_(const " + typeName +
                     "* const obj, std::uint8_t* const buffer, std::size_t* const "
                     "inout_buffer_size_bytes" +
                     (isPmrFlavor(flavor_) ? ", ::llvmdsdl::cpp::MemoryResource* const memory_resource" : "") + ")");
        emitLine(out, 0, "{");
        emitLine(out, 1, "if ((obj == nullptr) || (buffer == nullptr) || (inout_buffer_size_bytes == nullptr)) {");
        emitLine(out, 2, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
        emitLine(out, 1, "}");
        if (isPmrFlavor(flavor_))
        {
            emitLine(out,
                     1,
                     "::llvmdsdl::cpp::MemoryResource* const effective_memory_resource = "
                     "(memory_resource != nullptr) ? memory_resource : obj->_memory_resource;");
            emitLine(out, 1, "(void)effective_memory_resource;");
        }
        emitLine(out, 1, "const std::size_t capacity_bytes = *inout_buffer_size_bytes;");
        emitLine(out, 1, "std::size_t offset_bits = 0U;");
        const auto emitted = emitNativeFunctionSkeleton(
            section,
            sectionFacts,
            HelperBindingDirection::Serialize,
            NativeFunctionSkeletonCallbacks{
                [this, &out](const SectionHelperBindingPlan& helperBindings) {
                    emitSerializeMlirHelperBindings(out, helperBindings, 1);
                },
                [&out](const std::string& missingHelperRequirement) {
                    emitLine(out, 1, "/* missing lowered helper contract: " + missingHelperRequirement + " */");
                    emitLine(out,
                             1,
                             "return static_cast<std::int8_t>("
                             "-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
                },
                [this, &out](const SectionHelperBindingPlan& helperBindings) {
                    const auto capacityHelper = helperBindingName(helperBindings.capacityCheck->symbol);
                    const auto errCapacity    = nextName("err_capacity");
                    emitLine(out,
                             1,
                             "const std::int8_t " + errCapacity + " = " + capacityHelper +
                                 "(static_cast<std::int64_t>(capacity_bytes * 8U));");
                    emitLine(out, 1, "if (" + errCapacity + " != static_cast<std::int8_t>(DSDL_RUNTIME_SUCCESS)) {");
                    emitLine(out, 2, "return " + errCapacity + ";");
                    emitLine(out, 1, "}");
                },
                [this, &out, &section, sectionFacts](const LoweredBodyRenderIR& renderIR) {
                    NativeEmitterTraversalCallbacks callbacks;
                    callbacks.onUnionDispatch = [this, &out, &section, sectionFacts, &renderIR](
                                                    const std::vector<PlannedFieldStep>& unionBranches) {
                        emitSerializeUnion(out,
                                           section,
                                           unionBranches,
                                           "obj",
                                           1,
                                           sectionFacts,
                                           renderIR.helperBindings);
                    };
                    callbacks.onFieldAlignment = [this, &out](const std::int64_t alignmentBits) {
                        emitAlignSerialize(out, alignmentBits, 1);
                    };
                    callbacks.onField = [this, &out](const PlannedFieldStep& fieldStep) {
                        const auto* const field = fieldStep.field;
                        emitSerializeValue(out,
                                           field->resolvedType,
                                           "obj->" + codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, field->name),
                                           1,
                                           fieldStep.arrayLengthPrefixBits,
                                           fieldStep.fieldFacts);
                    };
                    callbacks.onPaddingAlignment = [this, &out](const std::int64_t alignmentBits) {
                        emitAlignSerialize(out, alignmentBits, 1);
                    };
                    callbacks.onPadding = [this, &out](const PlannedFieldStep& fieldStep) {
                        const auto* const field = fieldStep.field;
                        emitSerializePadding(out, field->resolvedType, 1);
                    };
                    return callbacks;
                },
                [this, &out]() {
                    emitAlignSerialize(out, 8, 1);
                    emitLine(out,
                             1,
                             "*inout_buffer_size_bytes = "
                             "static_cast<std::size_t>(offset_bits / 8U);");
                    emitLine(out, 1, "return static_cast<std::int8_t>(DSDL_RUNTIME_SUCCESS);");
                }});
        if (!emitted)
        {
            emitLine(out, 0, "}");
            out << "\n";
            return;
        }
        emitLine(out, 0, "}");
        out << "\n";
    }

    void emitDeserializeFunction(std::ostringstream&              out,
                                 const std::string&               typeName,
                                 const SemanticSection&           section,
                                 const LoweredSectionFacts* const sectionFacts)
    {
        emitLine(out,
                 0,
                 "inline std::int8_t " + typeName + "__deserialize_(" + typeName +
                     "* const out_obj, const std::uint8_t* buffer, std::size_t* const "
                     "inout_buffer_size_bytes" +
                     (isPmrFlavor(flavor_) ? ", ::llvmdsdl::cpp::MemoryResource* const memory_resource" : "") + ")");
        emitLine(out, 0, "{");
        emitLine(out,
                 1,
                 "if ((out_obj == nullptr) || (inout_buffer_size_bytes == nullptr) || ((buffer == nullptr) && (0U != "
                 "*inout_buffer_size_bytes))) {");
        emitLine(out, 2, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
        emitLine(out, 1, "}");
        if (isPmrFlavor(flavor_))
        {
            emitLine(out,
                     1,
                     "::llvmdsdl::cpp::MemoryResource* const effective_memory_resource = "
                     "(memory_resource != nullptr) ? memory_resource : out_obj->_memory_resource;");
            emitLine(out, 1, "(void)effective_memory_resource;");
            emitLine(out,
                     1,
                     "if (effective_memory_resource != nullptr) { "
                     "out_obj->set_memory_resource(effective_memory_resource); }");
        }
        emitLine(out, 1, "if (buffer == nullptr) {");
        emitLine(out, 2, "buffer = reinterpret_cast<const std::uint8_t*>(\"\");");
        emitLine(out, 1, "}");
        emitLine(out, 1, "const std::size_t capacity_bytes = *inout_buffer_size_bytes;");
        emitLine(out, 1, "const std::size_t capacity_bits = capacity_bytes * 8U;");
        emitLine(out, 1, "std::size_t offset_bits = 0U;");
        const auto emitted = emitNativeFunctionSkeleton(
            section,
            sectionFacts,
            HelperBindingDirection::Deserialize,
            NativeFunctionSkeletonCallbacks{
                [this, &out](const SectionHelperBindingPlan& helperBindings) {
                    emitDeserializeMlirHelperBindings(out, helperBindings, 1);
                },
                [&out](const std::string& missingHelperRequirement) {
                    emitLine(out, 1, "/* missing lowered helper contract: " + missingHelperRequirement + " */");
                    emitLine(out,
                             1,
                             "return static_cast<std::int8_t>("
                             "-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
                },
                nullptr,
                [this, &out, &section, sectionFacts](const LoweredBodyRenderIR& renderIR) {
                    NativeEmitterTraversalCallbacks callbacks;
                    callbacks.onUnionDispatch = [this, &out, &section, sectionFacts, &renderIR](
                                                    const std::vector<PlannedFieldStep>& unionBranches) {
                        emitDeserializeUnion(out,
                                             section,
                                             unionBranches,
                                             "out_obj",
                                             1,
                                             sectionFacts,
                                             renderIR.helperBindings);
                    };
                    callbacks.onFieldAlignment = [this, &out](const std::int64_t alignmentBits) {
                        emitAlignDeserialize(out, alignmentBits, 1);
                    };
                    callbacks.onField = [this, &out](const PlannedFieldStep& fieldStep) {
                        const auto* const field = fieldStep.field;
                        emitDeserializeValue(out,
                                             field->resolvedType,
                                             "out_obj->" +
                                                 codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, field->name),
                                             1,
                                             fieldStep.arrayLengthPrefixBits,
                                             fieldStep.fieldFacts);
                    };
                    callbacks.onPaddingAlignment = [this, &out](const std::int64_t alignmentBits) {
                        emitAlignDeserialize(out, alignmentBits, 1);
                    };
                    callbacks.onPadding = [this, &out](const PlannedFieldStep& fieldStep) {
                        const auto* const field = fieldStep.field;
                        emitDeserializePadding(out, field->resolvedType, 1);
                    };
                    return callbacks;
                },
                [this, &out]() {
                    emitAlignDeserialize(out, 8, 1);
                    emitLine(out,
                             1,
                             "*inout_buffer_size_bytes = "
                             "static_cast<std::size_t>(dsdl_runtime_choose_min(offset_bits, "
                             "capacity_bits) / 8U);");
                    emitLine(out, 1, "return static_cast<std::int8_t>(DSDL_RUNTIME_SUCCESS);");
                }});
        if (!emitted)
        {
            emitLine(out, 0, "}");
            out << "\n";
            return;
        }
        emitLine(out, 0, "}");
        out << "\n";
    }

private:
    const EmitterContext& ctx_;
    CppFlavor             flavor_{CppFlavor::Std};
    std::size_t           id_{0};

    std::string nextName(const std::string& prefix)
    {
        return "_" + prefix + std::to_string(id_++) + "_";
    }

    std::string helperBindingName(const std::string& helperSymbol) const
    {
        return renderHelperBindingIdentifier(CodegenNamingLanguage::Cpp, helperSymbol);
    }

    void emitSerializeMlirHelperBindings(std::ostringstream&             out,
                                         const SectionHelperBindingPlan& plan,
                                         const int                       indent)
    {
        for (const auto& line : renderSectionHelperBindings(
                 plan,
                 HelperBindingRenderLanguage::Cpp,
                 ScalarBindingRenderDirection::Serialize,
                 [this](const std::string& symbol) { return helperBindingName(symbol); },
                 /*emitCapacityCheck=*/true))
        {
            emitLine(out, indent, line);
        }
    }

    void emitDeserializeMlirHelperBindings(std::ostringstream&             out,
                                           const SectionHelperBindingPlan& plan,
                                           const int                       indent)
    {
        for (const auto& line : renderSectionHelperBindings(
                 plan,
                 HelperBindingRenderLanguage::Cpp,
                 ScalarBindingRenderDirection::Deserialize,
                 [this](const std::string& symbol) { return helperBindingName(symbol); },
                 /*emitCapacityCheck=*/false))
        {
            emitLine(out, indent, line);
        }
    }

    std::string containerElementType(const SemanticFieldType& type) const
    {
        switch (type.scalarCategory)
        {
        case SemanticScalarCategory::Bool:
            return "bool";
        case SemanticScalarCategory::Byte:
        case SemanticScalarCategory::Utf8:
        case SemanticScalarCategory::UnsignedInt:
            return unsignedStorageType(type.bitLength);
        case SemanticScalarCategory::SignedInt:
            return signedStorageType(type.bitLength);
        case SemanticScalarCategory::Float:
            return type.bitLength == 64U ? "double" : "float";
        case SemanticScalarCategory::Void:
            return "std::uint8_t";
        case SemanticScalarCategory::Composite:
            if (type.compositeType)
            {
                return ctx_.cppQualifiedTypeName(*type.compositeType);
            }
            return "std::uint8_t";
        }
        return "std::uint8_t";
    }

    void emitAlignSerialize(std::ostringstream& out, const std::int64_t alignmentBits, const int indent)
    {
        if (alignmentBits <= 1)
        {
            return;
        }
        const auto alignedOffset = nextName("aligned_offset");
        const auto bitIndex      = nextName("align_bit");
        const auto err           = nextName("err");
        emitLine(out,
                 indent,
                 "const std::size_t " + alignedOffset + " = (offset_bits + " + std::to_string(alignmentBits - 1) +
                     "U) & ~(std::size_t)" + std::to_string(alignmentBits - 1) + "U;");
        emitLine(out,
                 indent,
                 "for (std::size_t " + bitIndex + " = offset_bits; " + bitIndex + " < " + alignedOffset + "; ++" +
                     bitIndex + ") {");
        emitLine(out,
                 indent + 1,
                 "const std::int8_t " + err + " = dsdl_runtime_set_bit(buffer, capacity_bytes, " + bitIndex +
                     ", false);");
        emitLine(out, indent + 1, "if (" + err + " < 0) {");
        emitLine(out, indent + 2, "return " + err + ";");
        emitLine(out, indent + 1, "}");
        emitLine(out, indent, "}");
        emitLine(out, indent, "offset_bits = " + alignedOffset + ";");
    }

    void emitAlignDeserialize(std::ostringstream& out, const std::int64_t alignmentBits, const int indent)
    {
        if (alignmentBits <= 1)
        {
            return;
        }
        emitLine(out,
                 indent,
                 "offset_bits = (offset_bits + " + std::to_string(alignmentBits - 1) + "U) & ~(std::size_t)" +
                     std::to_string(alignmentBits - 1) + "U;");
    }

    void emitSerializePadding(std::ostringstream& out, const SemanticFieldType& type, const int indent)
    {
        if (type.bitLength == 0)
        {
            return;
        }
        const auto err = nextName("err");
        emitLine(out,
                 indent,
                 "const std::int8_t " + err + " = dsdl_runtime_set_uxx(buffer, capacity_bytes, offset_bits, 0U, " +
                     std::to_string(type.bitLength) + "U);");
        emitLine(out, indent, "if (" + err + " < 0) {");
        emitLine(out, indent + 1, "return " + err + ";");
        emitLine(out, indent, "}");
        emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
    }

    void emitDeserializePadding(std::ostringstream& out, const SemanticFieldType& type, const int indent)
    {
        if (type.bitLength == 0)
        {
            return;
        }
        emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
    }

    void emitSerializeUnion(std::ostringstream&                  out,
                            const SemanticSection&               section,
                            const std::vector<PlannedFieldStep>& unionBranches,
                            const std::string&                   objRef,
                            const int                            indent,
                            const LoweredSectionFacts* const     sectionFacts,
                            const SectionHelperBindingPlan&      helperBindings)
    {
        const auto tagBits        = resolveUnionTagBits(section, sectionFacts);
        const auto validateHelper = helperBindingName(helperBindings.unionTagValidate->symbol);
        const auto validateErr    = nextName("err_union_tag");
        emitLine(out,
                 indent,
                 "const std::int8_t " + validateErr + " = " + validateHelper + "(static_cast<std::int64_t>(" + objRef +
                     "->_tag_));");
        emitLine(out, indent, "if (" + validateErr + " != static_cast<std::int8_t>(DSDL_RUNTIME_SUCCESS)) {");
        emitLine(out, indent + 1, "return " + validateErr + ";");
        emitLine(out, indent, "}");
        const auto tagHelper = helperBindingName(helperBindings.unionTagMask->symbol);
        const auto tagExpr   = tagHelper + "(static_cast<std::uint64_t>(" + objRef + "->_tag_))";

        const auto tagErr = nextName("err");
        emitLine(out,
                 indent,
                 "const std::int8_t " + tagErr + " = dsdl_runtime_set_uxx(buffer, capacity_bytes, offset_bits, " +
                     tagExpr + ", " + std::to_string(tagBits) + "U);");
        emitLine(out, indent, "if (" + tagErr + " < 0) {");
        emitLine(out, indent + 1, "return " + tagErr + ";");
        emitLine(out, indent, "}");
        emitLine(out, indent, "offset_bits += " + std::to_string(tagBits) + "U;");

        bool first = true;
        for (const auto& step : unionBranches)
        {
            const auto& field  = *step.field;
            const auto  member = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, field.name);
            emitLine(out,
                     indent,
                     std::string(first ? "if" : "else if") + " (" + objRef +
                         "->_tag_ == " + std::to_string(field.unionOptionIndex) + "U) {");
            emitAlignSerialize(out, field.resolvedType.alignmentBits, indent + 1);
            emitSerializeValue(out,
                               field.resolvedType,
                               objRef + "->" + member,
                               indent + 1,
                               step.arrayLengthPrefixBits,
                               step.fieldFacts);
            emitLine(out, indent, "}");
            first = false;
        }

        emitLine(out, indent, "else {");
        emitLine(out, indent + 1, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_UNION_TAG);");
        emitLine(out, indent, "}");
    }

    void emitDeserializeUnion(std::ostringstream&                  out,
                              const SemanticSection&               section,
                              const std::vector<PlannedFieldStep>& unionBranches,
                              const std::string&                   objRef,
                              const int                            indent,
                              const LoweredSectionFacts* const     sectionFacts,
                              const SectionHelperBindingPlan&      helperBindings)
    {
        const auto tagBits = resolveUnionTagBits(section, sectionFacts);
        const auto rawTag  = nextName("tag_raw");
        emitLine(out,
                 indent,
                 "const std::uint64_t " + rawTag + " = static_cast<std::uint64_t>(" + unsignedGetter(tagBits) +
                     "(buffer, capacity_bytes, offset_bits, " + std::to_string(tagBits) + "U));");
        const auto tagHelper = helperBindingName(helperBindings.unionTagMask->symbol);
        const auto tagExpr   = tagHelper + "(" + rawTag + ")";

        emitLine(out, indent, objRef + "->_tag_ = static_cast<std::uint8_t>(" + tagExpr + ");");
        const auto validateHelper = helperBindingName(helperBindings.unionTagValidate->symbol);
        const auto validateErr    = nextName("err_union_tag");
        emitLine(out,
                 indent,
                 "const std::int8_t " + validateErr + " = " + validateHelper + "(static_cast<std::int64_t>(" + objRef +
                     "->_tag_));");
        emitLine(out, indent, "if (" + validateErr + " != static_cast<std::int8_t>(DSDL_RUNTIME_SUCCESS)) {");
        emitLine(out, indent + 1, "return " + validateErr + ";");
        emitLine(out, indent, "}");
        emitLine(out, indent, "offset_bits += " + std::to_string(tagBits) + "U;");

        bool first = true;
        for (const auto& step : unionBranches)
        {
            const auto& field  = *step.field;
            const auto  member = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, field.name);
            emitLine(out,
                     indent,
                     std::string(first ? "if" : "else if") + " (" + objRef +
                         "->_tag_ == " + std::to_string(field.unionOptionIndex) + "U) {");
            emitAlignDeserialize(out, field.resolvedType.alignmentBits, indent + 1);
            emitDeserializeValue(out,
                                 field.resolvedType,
                                 objRef + "->" + member,
                                 indent + 1,
                                 step.arrayLengthPrefixBits,
                                 step.fieldFacts);
            emitLine(out, indent, "}");
            first = false;
        }

        emitLine(out, indent, "else {");
        emitLine(out, indent + 1, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_UNION_TAG);");
        emitLine(out, indent, "}");
    }

    void emitSerializeValue(std::ostringstream&                out,
                            const SemanticFieldType&           type,
                            const std::string&                 expr,
                            const int                          indent,
                            const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride = std::nullopt,
                            const LoweredFieldFacts* const     fieldFacts                    = nullptr)
    {
        if (type.arrayKind != ArrayKind::None)
        {
            emitSerializeArray(out, type, expr, indent, arrayLengthPrefixBitsOverride, fieldFacts);
            return;
        }

        switch (type.scalarCategory)
        {
        case SemanticScalarCategory::Bool: {
            const auto err = nextName("err");
            emitLine(out,
                     indent,
                     "const std::int8_t " + err + " = dsdl_runtime_set_bit(buffer, capacity_bytes, offset_bits, " +
                         expr + ");");
            emitLine(out, indent, "if (" + err + " < 0) {");
            emitLine(out, indent + 1, "return " + err + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += 1U;");
            break;
        }
        case SemanticScalarCategory::Byte:
        case SemanticScalarCategory::Utf8:
        case SemanticScalarCategory::UnsignedInt: {
            std::string valueExpr    = "static_cast<std::uint64_t>(" + expr + ")";
            const auto  helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            valueExpr         = helper + "(" + valueExpr + ")";
            const auto err    = nextName("err");
            emitLine(out,
                     indent,
                     "const std::int8_t " + err + " = dsdl_runtime_set_uxx(buffer, capacity_bytes, offset_bits, " +
                         valueExpr + ", " + std::to_string(type.bitLength) + "U);");
            emitLine(out, indent, "if (" + err + " < 0) {");
            emitLine(out, indent + 1, "return " + err + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::SignedInt: {
            std::string valueExpr    = "static_cast<std::int64_t>(" + expr + ")";
            const auto  helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            valueExpr         = helper + "(" + valueExpr + ")";
            const auto err    = nextName("err");
            emitLine(out,
                     indent,
                     "const std::int8_t " + err + " = dsdl_runtime_set_ixx(buffer, capacity_bytes, offset_bits, " +
                         valueExpr + ", " + std::to_string(type.bitLength) + "U);");
            emitLine(out, indent, "if (" + err + " < 0) {");
            emitLine(out, indent + 1, "return " + err + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::Float: {
            const auto  err            = nextName("err");
            std::string normalizedExpr = "static_cast<double>(" + expr + ")";
            const auto  helperSymbol   = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            normalizedExpr    = helper + "(" + normalizedExpr + ")";
            std::string call;
            if (type.bitLength == 16U)
            {
                call = "dsdl_runtime_set_f16(buffer, capacity_bytes, offset_bits, static_cast<float>(" +
                       normalizedExpr + "))";
            }
            else if (type.bitLength == 32U)
            {
                call = "dsdl_runtime_set_f32(buffer, capacity_bytes, offset_bits, static_cast<float>(" +
                       normalizedExpr + "))";
            }
            else
            {
                call = "dsdl_runtime_set_f64(buffer, capacity_bytes, offset_bits, static_cast<double>(" +
                       normalizedExpr + "))";
            }
            emitLine(out, indent, "const std::int8_t " + err + " = " + call + ";");
            emitLine(out, indent, "if (" + err + " < 0) {");
            emitLine(out, indent + 1, "return " + err + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::Void:
            emitSerializePadding(out, type, indent);
            break;
        case SemanticScalarCategory::Composite:
            emitSerializeComposite(out, type, expr, indent, fieldFacts);
            break;
        }
    }

    void emitDeserializeValue(std::ostringstream&                out,
                              const SemanticFieldType&           type,
                              const std::string&                 expr,
                              const int                          indent,
                              const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride = std::nullopt,
                              const LoweredFieldFacts* const     fieldFacts                    = nullptr)
    {
        if (type.arrayKind != ArrayKind::None)
        {
            emitDeserializeArray(out, type, expr, indent, arrayLengthPrefixBitsOverride, fieldFacts);
            return;
        }

        switch (type.scalarCategory)
        {
        case SemanticScalarCategory::Bool:
            emitLine(out, indent, expr + " = dsdl_runtime_get_bit(buffer, capacity_bytes, offset_bits);");
            emitLine(out, indent, "offset_bits += 1U;");
            break;
        case SemanticScalarCategory::Byte:
        case SemanticScalarCategory::Utf8:
        case SemanticScalarCategory::UnsignedInt: {
            const auto helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            const auto raw    = nextName("raw");
            emitLine(out,
                     indent,
                     "const std::uint64_t " + raw + " = static_cast<std::uint64_t>(" + unsignedGetter(type.bitLength) +
                         "(buffer, capacity_bytes, offset_bits, " + std::to_string(type.bitLength) + "U));");
            emitLine(out,
                     indent,
                     expr + " = static_cast<" + unsignedStorageType(type.bitLength) + ">(" + helper + "(" + raw +
                         "));");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::SignedInt: {
            const auto helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            const auto raw    = nextName("raw");
            emitLine(out,
                     indent,
                     "const std::int64_t " + raw + " = static_cast<std::int64_t>(" + unsignedGetter(type.bitLength) +
                         "(buffer, capacity_bytes, offset_bits, " + std::to_string(type.bitLength) + "U));");
            emitLine(out,
                     indent,
                     expr + " = static_cast<" + signedStorageType(type.bitLength) + ">(" + helper + "(" + raw + "));");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::Float: {
            const auto helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            if (type.bitLength == 16U)
            {
                emitLine(out,
                         indent,
                         expr + " = static_cast<float>(" + helper +
                             "(static_cast<double>(dsdl_runtime_get_f16(buffer, capacity_bytes, offset_bits))));");
            }
            else if (type.bitLength == 32U)
            {
                emitLine(out,
                         indent,
                         expr + " = static_cast<float>(" + helper +
                             "(static_cast<double>(dsdl_runtime_get_f32(buffer, capacity_bytes, offset_bits))));");
            }
            else
            {
                emitLine(out,
                         indent,
                         expr + " = static_cast<double>(" + helper +
                             "(static_cast<double>(dsdl_runtime_get_f64(buffer, capacity_bytes, offset_bits))));");
            }
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + "U;");
            break;
        }
        case SemanticScalarCategory::Void:
            emitDeserializePadding(out, type, indent);
            break;
        case SemanticScalarCategory::Composite:
            emitDeserializeComposite(out, type, expr, indent, fieldFacts);
            break;
        }
    }

    void emitSerializeArray(std::ostringstream&                out,
                            const SemanticFieldType&           type,
                            const std::string&                 expr,
                            const int                          indent,
                            const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride,
                            const LoweredFieldFacts* const     fieldFacts)
    {
        const bool elementIsBool = type.scalarCategory == SemanticScalarCategory::Bool;
        const auto arrayPlan =
            buildArrayWirePlan(type, fieldFacts, arrayLengthPrefixBitsOverride, HelperBindingDirection::Serialize);
        const bool  variable        = arrayPlan.variable;
        const auto  prefixBits      = arrayPlan.prefixBits;
        const auto& arrayDescriptor = arrayPlan.descriptor;

        if (variable)
        {
            assert(arrayDescriptor.has_value());
            assert(!arrayDescriptor->validateSymbol.empty());
            const auto validateHelper = helperBindingName(arrayDescriptor->validateSymbol);
            const auto validateRc     = nextName("len_rc");
            emitLine(out,
                     indent,
                     "const std::int8_t " + validateRc + " = " + validateHelper + "(static_cast<std::int64_t>(" + expr +
                         ".size()));");
            emitLine(out, indent, "if (" + validateRc + " < 0) {");
            emitLine(out, indent + 1, "return " + validateRc + ";");
            emitLine(out, indent, "}");

            std::string prefixExpr = "static_cast<std::uint64_t>(" + expr + ".size())";
            assert(!arrayDescriptor->prefixSymbol.empty());
            const auto serPrefixHelper = helperBindingName(arrayDescriptor->prefixSymbol);
            prefixExpr                 = serPrefixHelper + "(" + prefixExpr + ")";
            const auto err             = nextName("err");
            emitLine(out,
                     indent,
                     "const std::int8_t " + err + " = dsdl_runtime_set_uxx(buffer, capacity_bytes, offset_bits, " +
                         prefixExpr + ", " + std::to_string(prefixBits) + "U);");
            emitLine(out, indent, "if (" + err + " < 0) {");
            emitLine(out, indent + 1, "return " + err + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += " + std::to_string(prefixBits) + "U;");
        }

        if (elementIsBool && !variable)
        {
            const auto source    = expr + ".data()";
            const auto countExpr = std::to_string(type.arrayCapacity) + "U";
            emitLine(out,
                     indent,
                     "dsdl_runtime_copy_bits(&buffer[0], offset_bits, " + countExpr + ", " + source + ", 0U);");
            emitLine(out, indent, "offset_bits += " + countExpr + ";");
            return;
        }

        const auto index        = nextName("index");
        const auto bound        = variable ? (expr + ".size()") : std::to_string(type.arrayCapacity) + "U";
        const auto accessPrefix = expr;

        emitLine(out, indent, "for (std::size_t " + index + " = 0U; " + index + " < " + bound + "; ++" + index + ") {");
        const auto elementType = arrayElementType(type);
        emitSerializeValue(out, elementType, accessPrefix + "[" + index + "]", indent + 1, std::nullopt, fieldFacts);
        emitLine(out, indent, "}");
    }

    void emitDeserializeArray(std::ostringstream&                out,
                              const SemanticFieldType&           type,
                              const std::string&                 expr,
                              const int                          indent,
                              const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride,
                              const LoweredFieldFacts* const     fieldFacts)
    {
        const bool elementIsBool = type.scalarCategory == SemanticScalarCategory::Bool;
        const auto arrayPlan =
            buildArrayWirePlan(type, fieldFacts, arrayLengthPrefixBitsOverride, HelperBindingDirection::Deserialize);
        const bool  variable        = arrayPlan.variable;
        const auto  prefixBits      = arrayPlan.prefixBits;
        const auto& arrayDescriptor = arrayPlan.descriptor;
        std::string countExpr;

        if (variable)
        {
            const auto rawCountVar = nextName("count_raw");
            emitLine(out,
                     indent,
                     "const std::uint64_t " + rawCountVar + " = static_cast<std::uint64_t>(" +
                         unsignedGetter(prefixBits) + "(buffer, capacity_bytes, offset_bits, " +
                         std::to_string(prefixBits) + "U));");
            emitLine(out, indent, "offset_bits += " + std::to_string(prefixBits) + "U;");
            std::string countRawExpr = rawCountVar;
            assert(arrayDescriptor.has_value());
            assert(!arrayDescriptor->prefixSymbol.empty());
            const auto deserPrefixHelper = helperBindingName(arrayDescriptor->prefixSymbol);
            countRawExpr                 = deserPrefixHelper + "(" + countRawExpr + ")";
            const auto countVar          = nextName("count");
            emitLine(out,
                     indent,
                     "const std::size_t " + countVar + " = static_cast<std::size_t>(" + countRawExpr + ");");

            assert(!arrayDescriptor->validateSymbol.empty());
            const auto validateHelper = helperBindingName(arrayDescriptor->validateSymbol);
            const auto validateRc     = nextName("len_rc");
            emitLine(out,
                     indent,
                     "const std::int8_t " + validateRc + " = " + validateHelper + "(static_cast<std::int64_t>(" +
                         countVar + "));");
            emitLine(out, indent, "if (" + validateRc + " < 0) {");
            emitLine(out, indent + 1, "return " + validateRc + ";");
            emitLine(out, indent, "}");
            if (isPmrFlavor(flavor_))
            {
                const auto tmpVar = nextName("tmp");
                emitLine(out,
                         indent,
                         "std::pmr::vector<" + containerElementType(type) + "> " + tmpVar +
                             "(effective_memory_resource != nullptr ? effective_memory_resource : "
                             "::llvmdsdl::cpp::default_memory_resource());");
                emitLine(out, indent, tmpVar + ".resize(" + countVar + ");");
                emitLine(out, indent, expr + " = std::move(" + tmpVar + ");");
            }
            else
            {
                emitLine(out, indent, expr + ".resize(" + countVar + ");");
            }

            if (isPmrFlavor(flavor_) && type.scalarCategory == SemanticScalarCategory::Composite)
            {
                const auto initIndex = nextName("i");
                emitLine(out,
                         indent,
                         "for (std::size_t " + initIndex + " = 0U; " + initIndex + " < " + countVar + "; ++" +
                             initIndex + ") {");
                emitLine(out, indent + 1, expr + "[" + initIndex + "].set_memory_resource(effective_memory_resource);");
                emitLine(out, indent, "}");
            }

            countExpr = countVar;
        }
        else
        {
            countExpr = std::to_string(type.arrayCapacity) + "U";
        }

        if (elementIsBool && !variable)
        {
            const auto target = expr + ".data()";
            emitLine(out,
                     indent,
                     "dsdl_runtime_get_bits(" + target +
                         ", &buffer[0], capacity_bytes, "
                         "offset_bits, " +
                         countExpr + ");");
            emitLine(out, indent, "offset_bits += " + countExpr + ";");
            return;
        }

        const auto index        = nextName("index");
        const auto bound        = variable ? countExpr : std::to_string(type.arrayCapacity) + "U";
        const auto accessPrefix = expr;

        emitLine(out, indent, "for (std::size_t " + index + " = 0U; " + index + " < " + bound + "; ++" + index + ") {");
        const auto elementType = arrayElementType(type);
        emitDeserializeValue(out, elementType, accessPrefix + "[" + index + "]", indent + 1, std::nullopt, fieldFacts);
        emitLine(out, indent, "}");
    }

    void emitSerializeComposite(std::ostringstream&            out,
                                const SemanticFieldType&       type,
                                const std::string&             expr,
                                const int                      indent,
                                const LoweredFieldFacts* const fieldFacts)
    {
        if (!type.compositeType)
        {
            emitLine(out, indent, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
            return;
        }

        const auto nestedType = ctx_.cppQualifiedTypeName(*type.compositeType);
        auto       sizeVar    = nextName("size_bytes");
        auto       errVar     = nextName("err");

        if (!type.compositeSealed)
        {
            emitLine(out, indent, "offset_bits += 32U;  // Delimiter header");
        }

        emitLine(out,
                 indent,
                 "std::size_t " + sizeVar + " = " + std::to_string((type.bitLengthSet.max() + 7) / 8) + "U;");
        if (!type.compositeSealed)
        {
            const auto remaining = nextName("remaining");
            emitLine(out,
                     indent,
                     "const std::size_t " + remaining +
                         " = capacity_bytes - dsdl_runtime_choose_min(offset_bits / 8U, capacity_bytes);");
            const auto helperSymbol = resolveDelimiterValidateHelperSymbol(type, fieldFacts);
            assert(!helperSymbol.empty());
            const auto helper     = helperBindingName(helperSymbol);
            const auto validateRc = nextName("rc");
            emitLine(out,
                     indent,
                     "const std::int8_t " + validateRc + " = " + helper + "(static_cast<std::int64_t>(" + sizeVar +
                         "), static_cast<std::int64_t>(" + remaining + "));");
            emitLine(out, indent, "if (" + validateRc + " < 0) {");
            emitLine(out, indent + 1, "return " + validateRc + ";");
            emitLine(out, indent, "}");
        }
        emitLine(out,
                 indent,
                 "std::int8_t " + errVar + " = " + nestedType + "__serialize_(&" + expr +
                     ", &buffer[offset_bits / 8U], &" + sizeVar +
                     (isPmrFlavor(flavor_) ? ", effective_memory_resource" : "") + ");");
        emitLine(out, indent, "if (" + errVar + " < 0) {");
        emitLine(out, indent + 1, "return " + errVar + ";");
        emitLine(out, indent, "}");

        if (!type.compositeSealed)
        {
            auto hdrErr = nextName("err");
            emitLine(out,
                     indent,
                     "const std::int8_t " + hdrErr +
                         " = dsdl_runtime_set_uxx(buffer, capacity_bytes, offset_bits - 32U, "
                         "static_cast<std::uint64_t>(" +
                         sizeVar + "), 32U);");
            emitLine(out, indent, "if (" + hdrErr + " < 0) {");
            emitLine(out, indent + 1, "return " + hdrErr + ";");
            emitLine(out, indent, "}");
        }

        emitLine(out, indent, "offset_bits += " + sizeVar + " * 8U;");
    }

    void emitDeserializeComposite(std::ostringstream&            out,
                                  const SemanticFieldType&       type,
                                  const std::string&             expr,
                                  const int                      indent,
                                  const LoweredFieldFacts* const fieldFacts)
    {
        if (!type.compositeType)
        {
            emitLine(out, indent, "return static_cast<std::int8_t>(-DSDL_RUNTIME_ERROR_INVALID_ARGUMENT);");
            return;
        }

        const auto nestedType = ctx_.cppQualifiedTypeName(*type.compositeType);
        auto       sizeVar    = nextName("size_bytes");
        auto       errVar     = nextName("err");

        if (!type.compositeSealed)
        {
            emitLine(out,
                     indent,
                     "std::size_t " + sizeVar +
                         " = static_cast<std::size_t>(dsdl_runtime_get_u32(buffer, capacity_bytes, offset_bits, "
                         "32U));");
            emitLine(out, indent, "offset_bits += 32U;");
            emitLine(out,
                     indent,
                     "const std::size_t _remaining_" + std::to_string(id_) +
                         " = capacity_bytes - dsdl_runtime_choose_min(offset_bits / 8U, capacity_bytes);");
            const auto remVar = "_remaining_" + std::to_string(id_);
            ++id_;
            const auto helperSymbol = resolveDelimiterValidateHelperSymbol(type, fieldFacts);
            assert(!helperSymbol.empty());
            const auto helper     = helperBindingName(helperSymbol);
            const auto validateRc = nextName("rc");
            emitLine(out,
                     indent,
                     "const std::int8_t " + validateRc + " = " + helper + "(static_cast<std::int64_t>(" + sizeVar +
                         "), static_cast<std::int64_t>(" + remVar + "));");
            emitLine(out, indent, "if (" + validateRc + " < 0) {");
            emitLine(out, indent + 1, "return " + validateRc + ";");
            emitLine(out, indent, "}");
            const auto consumed = nextName("consumed");
            emitLine(out, indent, "std::size_t " + consumed + " = " + sizeVar + ";");
            emitLine(out,
                     indent,
                     "const std::int8_t " + errVar + " = " + nestedType + "__deserialize_(&" + expr +
                         ", &buffer[offset_bits / 8U], &" + consumed +
                         (isPmrFlavor(flavor_) ? ", effective_memory_resource" : "") + ");");
            emitLine(out, indent, "if (" + errVar + " < 0) {");
            emitLine(out, indent + 1, "return " + errVar + ";");
            emitLine(out, indent, "}");
            emitLine(out, indent, "offset_bits += " + sizeVar + " * 8U;");
            return;
        }

        emitLine(out,
                 indent,
                 "std::size_t " + sizeVar +
                     " = capacity_bytes - dsdl_runtime_choose_min(offset_bits / 8U, capacity_bytes);");
        emitLine(out,
                 indent,
                 "const std::int8_t " + errVar + " = " + nestedType + "__deserialize_(&" + expr +
                     ", &buffer[offset_bits / 8U], &" + sizeVar +
                     (isPmrFlavor(flavor_) ? ", effective_memory_resource" : "") + ");");
        emitLine(out, indent, "if (" + errVar + " < 0) {");
        emitLine(out, indent + 1, "return " + errVar + ";");
        emitLine(out, indent, "}");
        emitLine(out, indent, "offset_bits += " + sizeVar + " * 8U;");
    }
};

std::string cppTypeFromFieldType(const SemanticFieldType& type, const EmitterContext& ctx)
{
    switch (type.scalarCategory)
    {
    case SemanticScalarCategory::Bool:
        return "bool";
    case SemanticScalarCategory::Byte:
    case SemanticScalarCategory::Utf8:
    case SemanticScalarCategory::UnsignedInt:
        return unsignedStorageType(type.bitLength);
    case SemanticScalarCategory::SignedInt:
        return signedStorageType(type.bitLength);
    case SemanticScalarCategory::Float:
        if (type.bitLength == 64U)
        {
            return "double";
        }
        return "float";
    case SemanticScalarCategory::Void:
        return "std::uint8_t";
    case SemanticScalarCategory::Composite:
        if (type.compositeType)
        {
            return ctx.cppQualifiedTypeName(*type.compositeType);
        }
        return "std::uint8_t";
    }
    return "std::uint8_t";
}

void emitArrayMetadata(std::ostringstream& out, const std::string& typeName, const SemanticSection& section)
{
    for (const auto& field : section.fields)
    {
        if (field.isPadding || field.resolvedType.arrayKind == ArrayKind::None)
        {
            continue;
        }
        const auto fieldName = sanitizeMacroToken(field.name);
        emitLine(out,
                 1,
                 "static constexpr std::size_t " + fieldName +
                     "_ARRAY_CAPACITY = " + std::to_string(field.resolvedType.arrayCapacity) + "U;");
        emitLine(out,
                 1,
                 "static constexpr bool " + fieldName + "_ARRAY_IS_VARIABLE_LENGTH = " +
                     std::string(isVariableArray(field.resolvedType.arrayKind) ? "true" : "false") + ";");
    }
}

void emitFunctionPrototypes(std::ostringstream& out, const std::string& typeName, const CppFlavor flavor)
{
    emitLine(out, 0, "struct " + typeName + ";");
    emitLine(out,
             0,
             "inline std::int8_t " + typeName + "__serialize_(const " + typeName +
                 "* obj, std::uint8_t* buffer, std::size_t* inout_buffer_size_bytes" +
                 (isPmrFlavor(flavor) ? ", ::llvmdsdl::cpp::MemoryResource* memory_resource" : "") + ");");
    emitLine(out,
             0,
             "inline std::int8_t " + typeName + "__deserialize_(" + typeName +
                 "* out_obj, const std::uint8_t* buffer, std::size_t* inout_buffer_size_bytes" +
                 (isPmrFlavor(flavor) ? ", ::llvmdsdl::cpp::MemoryResource* memory_resource" : "") + ");");
    out << "\n";
}

void emitSectionStruct(std::ostringstream&    out,
                       const std::string&     typeName,
                       const std::string&     fullName,
                       std::uint32_t          majorVersion,
                       std::uint32_t          minorVersion,
                       const SemanticSection& section,
                       const EmitterContext&  ctx,
                       const CppFlavor        flavor,
                       const AttachedDoc&     typeDoc)
{
    emitAttachedDocCpp(out, 0, typeDoc);
    emitLine(out, 0, "struct " + typeName + " {");

    std::size_t              emitted = 0;
    std::vector<std::string> variableArrayMembers;
    std::vector<std::string> compositeScalarMembers;
    std::vector<std::string> compositeFixedArrayMembers;
    std::vector<std::string> compositeVariableArrayMembers;

    for (const auto& field : section.fields)
    {
        if (field.isPadding)
        {
            continue;
        }

        const auto member   = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, field.name);
        const auto baseType = cppTypeFromFieldType(field.resolvedType, ctx);
        emitAttachedDocCpp(out, 1, field.doc);

        if (field.resolvedType.arrayKind == ArrayKind::None)
        {
            emitLine(out, 1, baseType + " " + member + "{};");
            if (isPmrFlavor(flavor) && field.resolvedType.scalarCategory == SemanticScalarCategory::Composite)
            {
                compositeScalarMembers.push_back(member);
            }
            ++emitted;
            continue;
        }

        if (field.resolvedType.arrayKind == ArrayKind::Fixed)
        {
            if (field.resolvedType.scalarCategory == SemanticScalarCategory::Bool)
            {
                emitLine(out,
                         1,
                         "std::array<std::uint8_t, (" + std::to_string(field.resolvedType.arrayCapacity) +
                             "U + 7U) / 8U> " + member + "{};");
            }
            else
            {
                emitLine(out,
                         1,
                         "std::array<" + baseType + ", " + std::to_string(field.resolvedType.arrayCapacity) + "U> " +
                             member + "{};");
            }
            if (isPmrFlavor(flavor) && field.resolvedType.scalarCategory == SemanticScalarCategory::Composite)
            {
                compositeFixedArrayMembers.push_back(member);
            }
            ++emitted;
            continue;
        }

        if (isPmrFlavor(flavor))
        {
            emitLine(out,
                     1,
                     "std::pmr::vector<" +
                         std::string(field.resolvedType.scalarCategory == SemanticScalarCategory::Bool ? "bool"
                                                                                                       : baseType) +
                         "> " + member + "{};");
            variableArrayMembers.push_back(member);
            if (field.resolvedType.scalarCategory == SemanticScalarCategory::Composite)
            {
                compositeVariableArrayMembers.push_back(member);
            }
        }
        else if (isAutosarFlavor(flavor))
        {
            emitLine(out,
                     1,
                     "::llvmdsdl::cpp::autosar::BoundedVector<" +
                         std::string(field.resolvedType.scalarCategory == SemanticScalarCategory::Bool ? "bool"
                                                                                                       : baseType) +
                         ", " + std::to_string(field.resolvedType.arrayCapacity) + "U> " + member + "{};");
        }
        else
        {
            emitLine(out,
                     1,
                     "std::vector<" +
                         std::string(field.resolvedType.scalarCategory == SemanticScalarCategory::Bool ? "bool"
                                                                                                       : baseType) +
                         "> " + member + "{};");
        }
        ++emitted;
    }

    if (section.isUnion)
    {
        emitLine(out, 1, "std::uint8_t _tag_{0U};");
        ++emitted;
    }

    if (isPmrFlavor(flavor))
    {
        emitLine(out,
                 1,
                 "::llvmdsdl::cpp::MemoryResource* _memory_resource{::llvmdsdl::cpp::default_memory_resource()};");
        emitLine(out, 1, typeName + "() = default;");
        emitLine(out,
                 1,
                 "explicit " + typeName +
                     "(::llvmdsdl::cpp::MemoryResource* memory_resource) { set_memory_resource(memory_resource); }");
        emitLine(out, 1, "void set_memory_resource(::llvmdsdl::cpp::MemoryResource* memory_resource) {");
        emitLine(out,
                 2,
                 "_memory_resource = (memory_resource != nullptr) ? memory_resource : "
                 "::llvmdsdl::cpp::default_memory_resource();");
        for (const auto& member : variableArrayMembers)
        {
            emitLine(out, 2, member + " = decltype(" + member + ")(_memory_resource);");
        }
        for (const auto& member : compositeScalarMembers)
        {
            emitLine(out, 2, member + ".set_memory_resource(_memory_resource);");
        }
        for (const auto& member : compositeFixedArrayMembers)
        {
            const auto i = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, member + "_index");
            emitLine(out, 2, "for (std::size_t " + i + " = 0U; " + i + " < " + member + ".size(); ++" + i + ") {");
            emitLine(out, 3, member + "[" + i + "].set_memory_resource(_memory_resource);");
            emitLine(out, 2, "}");
        }
        for (const auto& member : compositeVariableArrayMembers)
        {
            const auto i = codegenSanitizeIdentifier(CodegenNamingLanguage::Cpp, member + "_index");
            emitLine(out, 2, "for (std::size_t " + i + " = 0U; " + i + " < " + member + ".size(); ++" + i + ") {");
            emitLine(out, 3, member + "[" + i + "].set_memory_resource(_memory_resource);");
            emitLine(out, 2, "}");
        }
        emitLine(out, 1, "}");
        ++emitted;
    }

    if (emitted == 0)
    {
        emitLine(out, 1, "std::uint8_t _dummy_{0U};");
    }

    emitLine(out, 1, "static constexpr const char* FULL_NAME = \"" + fullName + "\";");
    emitLine(out,
             1,
             "static constexpr const char* FULL_NAME_AND_VERSION = \"" + fullName + "." + std::to_string(majorVersion) +
                 "." + std::to_string(minorVersion) + "\";");
    emitLine(out,
             1,
             "static constexpr std::size_t EXTENT_BYTES = " + std::to_string(section.extentBits.value_or(0) / 8) +
                 "U;");
    emitLine(out,
             1,
             "static constexpr std::size_t SERIALIZATION_BUFFER_SIZE_BYTES = " +
                 std::to_string((section.serializationBufferSizeBits + 7) / 8) + "U;");
    if (section.isUnion)
    {
        std::size_t optionCount = 0;
        for (const auto& f : section.fields)
        {
            if (!f.isPadding)
            {
                ++optionCount;
            }
        }
        emitLine(out, 1, "static constexpr std::size_t UNION_OPTION_COUNT = " + std::to_string(optionCount) + "U;");
    }

    for (const auto& c : section.constants)
    {
        emitAttachedDocCpp(out, 1, c.doc);
        emitLine(out, 1, "static constexpr auto " + sanitizeMacroToken(c.name) + " = " + valueToCppExpr(c.value) + ";");
    }

    emitArrayMetadata(out, typeName, section);

    emitLine(out,
             1,
             "LLVMDSDL_NODISCARD inline std::int8_t serialize(std::uint8_t* buffer, std::size_t* "
             "inout_buffer_size_bytes) "
             "const {");
    if (isPmrFlavor(flavor))
    {
        emitLine(out,
                 2,
                 "return " + typeName + "__serialize_(this, buffer, inout_buffer_size_bytes, _memory_resource);");
    }
    else
    {
        emitLine(out, 2, "return " + typeName + "__serialize_(this, buffer, inout_buffer_size_bytes);");
    }
    emitLine(out, 1, "}");

    emitLine(out,
             1,
             "LLVMDSDL_NODISCARD inline std::int8_t deserialize(const std::uint8_t* buffer, std::size_t* "
             "inout_buffer_size_bytes) {");
    if (isPmrFlavor(flavor))
    {
        emitLine(out,
                 2,
                 "return " + typeName + "__deserialize_(this, buffer, inout_buffer_size_bytes, _memory_resource);");
    }
    else
    {
        emitLine(out, 2, "return " + typeName + "__deserialize_(this, buffer, inout_buffer_size_bytes);");
    }
    emitLine(out, 1, "}");

    if (isPmrFlavor(flavor))
    {
        emitLine(out,
                 1,
                 "LLVMDSDL_NODISCARD inline std::int8_t serialize(std::uint8_t* buffer, std::size_t* "
                 "inout_buffer_size_bytes, ::llvmdsdl::cpp::MemoryResource* memory_resource) const {");
        emitLine(out,
                 2,
                 "return " + typeName + "__serialize_(this, buffer, inout_buffer_size_bytes, memory_resource);");
        emitLine(out, 1, "}");

        emitLine(out,
                 1,
                 "LLVMDSDL_NODISCARD inline std::int8_t deserialize(const std::uint8_t* buffer, std::size_t* "
                 "inout_buffer_size_bytes, ::llvmdsdl::cpp::MemoryResource* memory_resource) {");
        emitLine(out,
                 2,
                 "return " + typeName + "__deserialize_(this, buffer, inout_buffer_size_bytes, memory_resource);");
        emitLine(out, 1, "}");
    }

    emitLine(out, 0, "};");
    out << "\n";
}

void emitSection(std::ostringstream&              out,
                 const EmitterContext&            ctx,
                 const SemanticDefinition&        def,
                 const std::string&               typeName,
                 const std::string&               fullName,
                 const SemanticSection&           section,
                 const CppFlavor                  flavor,
                 const AttachedDoc&               typeDoc,
                 const LoweredSectionFacts* const sectionFacts)
{
    (void) def;
    emitFunctionPrototypes(out, typeName, flavor);
    emitSectionStruct(out,
                      typeName,
                      fullName,
                      def.info.majorVersion,
                      def.info.minorVersion,
                      section,
                      ctx,
                      flavor,
                      typeDoc);

    FunctionBodyEmitter bodyEmitter(ctx, flavor);
    bodyEmitter.emitSerializeFunction(out, typeName, section, sectionFacts);
    bodyEmitter.emitDeserializeFunction(out, typeName, section, sectionFacts);
}

llvm::Expected<std::string> loadCRuntimeHeader()
{
    const std::filesystem::path absoluteRuntimeHeader =
        std::filesystem::path(LLVMDSDL_SOURCE_DIR) / "runtime" / "dsdl_runtime.h";
    std::ifstream in(absoluteRuntimeHeader.string());
    if (!in)
    {
        in.open("runtime/dsdl_runtime.h");
    }
    if (!in)
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "failed to read runtime header");
    }
    std::ostringstream content;
    content << in.rdbuf();
    return content.str();
}

llvm::Expected<std::string> loadCppRuntimeHeader(const CppFlavor flavor)
{
    const std::filesystem::path relativeRuntimeHeader =
        isAutosarFlavor(flavor) ? std::filesystem::path("runtime") / "cpp" / "autosar" / "dsdl_runtime.hpp"
                                : std::filesystem::path("runtime") / "cpp" / "dsdl_runtime.hpp";
    const std::filesystem::path absoluteRuntimeHeader =
        std::filesystem::path(LLVMDSDL_SOURCE_DIR) / relativeRuntimeHeader;
    std::ifstream in(absoluteRuntimeHeader.string());
    if (!in)
    {
        in.open(relativeRuntimeHeader.string());
    }
    if (!in)
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "failed to read C++ runtime header");
    }
    std::ostringstream content;
    content << in.rdbuf();
    return content.str();
}

std::string renderHeader(const SemanticDefinition& def,
                         const EmitterContext&     ctx,
                         const CppFlavor           flavor,
                         const LoweredFactsMap&    loweredFacts)
{
    std::ostringstream out;
    const auto         guard        = headerGuard(def.info);
    const auto         baseTypeName = ctx.cppTypeName(def);

    out << generatedCommentLine("C++ backend") << "\n";
    out << "// Source: " << def.info.fullName << "." << def.info.majorVersion << "." << def.info.minorVersion << "\n\n";
    out << "#ifndef " << guard << "\n";
    out << "#define " << guard << "\n\n";
    out << "#include <array>\n";
    out << "#include <cstddef>\n";
    out << "#include <cstdint>\n";
    out << "#include <utility>\n";
    if (!isAutosarFlavor(flavor))
    {
        out << "#include <vector>\n";
    }
    if (isPmrFlavor(flavor))
    {
        out << "#include <memory_resource>\n";
    }
    out << "#include \"dsdl_runtime.hpp\"\n";

    for (const auto& depRef : collectDefinitionCompositeDependencies(def))
    {
        if (const auto* dep = ctx.find(depRef))
        {
            out << "#include \"" << ctx.relativeHeaderPath(*dep) << "\"\n";
        }
    }
    out << "\n";
    emitNamespaceOpen(out, def.info.namespaceComponents);

    if (def.isService)
    {
        const auto requestType  = baseTypeName + "__Request";
        const auto responseType = baseTypeName + "__Response";

        emitLine(out, 0, "constexpr const char* " + baseTypeName + "_FULL_NAME = \"" + def.info.fullName + "\";");
        emitLine(out,
                 0,
                 "constexpr const char* " + baseTypeName + "_FULL_NAME_AND_VERSION = \"" + def.info.fullName + "." +
                     std::to_string(def.info.majorVersion) + "." + std::to_string(def.info.minorVersion) + "\";");
        out << "\n";

        emitSection(out,
                    ctx,
                    def,
                    requestType,
                    def.info.fullName + ".Request",
                    def.request,
                    flavor,
                    def.doc,
                    lookupLoweredSectionFacts(loweredFacts, def, "request"));
        if (def.response)
        {
            emitSection(out,
                        ctx,
                        def,
                        responseType,
                        def.info.fullName + ".Response",
                        *def.response,
                        flavor,
                        def.doc,
                        lookupLoweredSectionFacts(loweredFacts, def, "response"));
        }

        emitLine(out, 0, "using " + baseTypeName + " = " + requestType + ";");
        emitLine(out,
                 0,
                 "constexpr std::size_t " + baseTypeName + "_EXTENT_BYTES = " + requestType + "::EXTENT_BYTES;");
        emitLine(out,
                 0,
                 "constexpr std::size_t " + baseTypeName + "_SERIALIZATION_BUFFER_SIZE_BYTES = " + requestType +
                     "::SERIALIZATION_BUFFER_SIZE_BYTES;");
        out << "\n";

        emitLine(out,
                 0,
                 "inline std::int8_t " + baseTypeName + "__serialize_(const " + baseTypeName +
                     "* const obj, std::uint8_t* const buffer, std::size_t* const "
                     "inout_buffer_size_bytes" +
                     (isPmrFlavor(flavor) ? ", ::llvmdsdl::cpp::MemoryResource* const memory_resource" : "") + ")");
        emitLine(out, 0, "{");
        emitLine(out,
                 1,
                 "return " + requestType + "__serialize_(reinterpret_cast<const " + requestType +
                     "*>(obj), buffer, inout_buffer_size_bytes" + (isPmrFlavor(flavor) ? ", memory_resource" : "") +
                     ");");
        emitLine(out, 0, "}");
        out << "\n";

        emitLine(out,
                 0,
                 "inline std::int8_t " + baseTypeName + "__deserialize_(" + baseTypeName +
                     "* const out_obj, const std::uint8_t* buffer, std::size_t* const "
                     "inout_buffer_size_bytes" +
                     (isPmrFlavor(flavor) ? ", ::llvmdsdl::cpp::MemoryResource* const memory_resource" : "") + ")");
        emitLine(out, 0, "{");
        emitLine(out,
                 1,
                 "return " + requestType + "__deserialize_(reinterpret_cast<" + requestType +
                     "*>(out_obj), buffer, inout_buffer_size_bytes" + (isPmrFlavor(flavor) ? ", memory_resource" : "") +
                     ");");
        emitLine(out, 0, "}");
    }
    else
    {
        emitSection(out,
                    ctx,
                    def,
                    baseTypeName,
                    def.info.fullName,
                    def.request,
                    flavor,
                    def.doc,
                    lookupLoweredSectionFacts(loweredFacts, def, ""));
    }

    emitNamespaceClose(out, def.info.namespaceComponents);
    out << "\n#endif /* " << guard << " */\n";
    return out.str();
}

llvm::Error emitProfile(const SemanticModule&                  semantic,
                        const std::filesystem::path&           outRoot,
                        const CppFlavor                        flavor,
                        const LoweredFactsMap&                 loweredFacts,
                        const CppEmitOptions&                  options,
                        const std::unordered_set<std::string>& selectedTypeKeys)
{
    auto cRuntime = loadCRuntimeHeader();
    if (!cRuntime)
    {
        return cRuntime.takeError();
    }
    if (auto err = writeGeneratedFile(outRoot / "dsdl_runtime.h",
                                      generatedCommentLine("C runtime scaffold for C++ backend") + "\n\n" + *cRuntime,
                                      options.writePolicy))
    {
        return err;
    }

    auto cppRuntime = loadCppRuntimeHeader(flavor);
    if (!cppRuntime)
    {
        return cppRuntime.takeError();
    }
    if (auto err = writeGeneratedFile(outRoot / "dsdl_runtime.hpp",
                                      generatedCommentLine("C++ runtime scaffold") + "\n\n" + *cppRuntime,
                                      options.writePolicy))
    {
        return err;
    }

    EmitterContext ctx(semantic);
    for (const auto& def : semantic.definitions)
    {
        if (!shouldEmitDefinition(def.info, selectedTypeKeys))
        {
            continue;
        }
        const std::vector<std::string> requiredTypeKeys{definitionTypeKey(def.info)};

        std::filesystem::path dir = outRoot;
        for (const auto& ns : def.info.namespaceComponents)
        {
            dir /= ns;
        }
        if (auto err = writeGeneratedFile(dir / headerFileName(def.info),
                                          renderHeader(def, ctx, flavor, loweredFacts),
                                          options.writePolicy,
                                          requiredTypeKeys))
        {
            return err;
        }
    }

    return llvm::Error::success();
}

}  // namespace

llvm::Error emitCpp(const SemanticModule& semantic,
                    mlir::ModuleOp        module,
                    const CppEmitOptions& options,
                    DiagnosticEngine&     diagnostics)
{
    if (options.outDir.empty())
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "output directory is required");
    }
    const auto mlirCoverageDiagnostic = codegen_diagnostic_text::mlirSchemaCoverageValidationFailedForEmission("C++");
    LoweredFactsMap loweredFacts;
    if (!collectLoweredFactsFromMlir(semantic,
                                     module,
                                     diagnostics,
                                     "C++",
                                     &loweredFacts,
                                     options.optimizeLoweredSerDes))
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "%s", mlirCoverageDiagnostic.c_str());
    }

    std::filesystem::path outRoot(options.outDir);
    const auto            selectedTypeKeys = makeTypeKeySet(options.selectedTypeKeys);

    if (options.profile == CppProfile::Std)
    {
        return emitProfile(semantic, outRoot, CppFlavor::Std, loweredFacts, options, selectedTypeKeys);
    }
    if (options.profile == CppProfile::Pmr)
    {
        return emitProfile(semantic, outRoot, CppFlavor::Pmr, loweredFacts, options, selectedTypeKeys);
    }
    if (options.profile == CppProfile::Autosar)
    {
        return emitProfile(semantic, outRoot, CppFlavor::Autosar, loweredFacts, options, selectedTypeKeys);
    }

    if (auto err = emitProfile(semantic, outRoot / "std", CppFlavor::Std, loweredFacts, options, selectedTypeKeys))
    {
        return err;
    }
    return emitProfile(semantic, outRoot / "pmr", CppFlavor::Pmr, loweredFacts, options, selectedTypeKeys);
}

}  // namespace llvmdsdl
