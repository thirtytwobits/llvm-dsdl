//===----------------------------------------------------------------------===//
//
// Part of the OpenCyphal project, under the MIT licence
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
///
/// @file
/// Implements Rust backend code emission from lowered DSDL modules.
///
/// The file maps lowering facts to Rust data types and serdes routines across supported runtime profiles.
///
//===----------------------------------------------------------------------===//

#include "llvmdsdl/CodeGen/RustEmitter.h"

#include <llvm/ADT/StringRef.h>
#include <llvm/Support/Error.h>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <map>
#include <optional>
#include <set>
#include <sstream>
#include <unordered_map>
#include <vector>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <system_error>
#include <utility>
#include <variant>

#include "llvmdsdl/CodeGen/ArrayWirePlan.h"
#include "llvmdsdl/CodeGen/CodegenDiagnosticText.h"
#include "llvmdsdl/CodeGen/ConstantLiteralRender.h"
#include "llvmdsdl/CodeGen/DefinitionDependencies.h"
#include "llvmdsdl/CodeGen/DefinitionIndex.h"
#include "llvmdsdl/CodeGen/HelperBindingRender.h"
#include "llvmdsdl/CodeGen/HelperSymbolResolver.h"
#include "llvmdsdl/CodeGen/LoweredRenderIR.h"
#include "llvmdsdl/CodeGen/LoweredFactsLookup.h"
#include "llvmdsdl/CodeGen/MlirLoweredFacts.h"
#include "llvmdsdl/CodeGen/NamingPolicy.h"
#include "llvmdsdl/CodeGen/HelperBindingNaming.h"
#include "llvmdsdl/CodeGen/NativeEmitterTraversal.h"
#include "llvmdsdl/CodeGen/NativeFunctionSkeleton.h"
#include "llvmdsdl/CodeGen/SerDesHelperDescriptors.h"
#include "llvmdsdl/CodeGen/StorageTypeTokens.h"
#include "llvmdsdl/CodeGen/TypeStorage.h"
#include "llvmdsdl/CodeGen/WireLayoutFacts.h"
#include "llvm/Support/raw_ostream.h"
#include "llvmdsdl/CodeGen/SectionHelperBindingPlan.h"
#include "llvmdsdl/CodeGen/SerDesStatementPlan.h"
#include "llvmdsdl/Frontend/AST.h"
#include "llvmdsdl/Semantics/BitLengthSet.h"
#include "llvmdsdl/Semantics/Evaluator.h"
#include "llvmdsdl/Semantics/Model.h"
#include "llvmdsdl/Support/Rational.h"
#include "llvmdsdl/Version.h"
#include "mlir/IR/BuiltinOps.h"

namespace llvmdsdl
{
class DiagnosticEngine;

namespace
{

std::string rustMemoryModeVariantPath(const RustEmitOptions& options)
{
    if (options.memoryMode == RustMemoryMode::InlineThenPool)
    {
        return "crate::dsdl_runtime::DsdlMemoryMode::InlineThenPool";
    }
    return "crate::dsdl_runtime::DsdlMemoryMode::MaxInline";
}

std::string unsignedStorageType(const std::uint32_t bitLength)
{
    return renderUnsignedStorageToken(StorageTokenLanguage::Rust, bitLength);
}

std::string signedStorageType(const std::uint32_t bitLength)
{
    return renderSignedStorageToken(StorageTokenLanguage::Rust, bitLength);
}

std::string rustConstValue(const Value& value)
{
    return renderConstantLiteral(ConstantLiteralLanguage::Rust, value);
}

void emitLine(std::ostringstream& out, const int indent, const std::string& line)
{
    out << std::string(static_cast<std::size_t>(indent) * 4U, ' ') << line << '\n';
}

std::string generatedCommentLine(llvm::StringRef detail)
{
    return "// Generated by llvmdsdl " + std::string(llvmdsdl::kVersionString) + " (" + detail.str() + ").";
}

void emitAttachedDocRust(std::ostringstream& out, const int indent, const AttachedDoc& doc)
{
    for (const auto& line : doc.lines)
    {
        emitLine(out, indent, "/// " + line.text);
    }
}

class EmitterContext final
{
public:
    explicit EmitterContext(const SemanticModule& semantic)
        : index_(semantic)
    {
    }

    const SemanticDefinition* find(const SemanticTypeRef& ref) const
    {
        return index_.find(ref);
    }

    std::string rustModuleName(const DiscoveredDefinition& info) const
    {
        return codegenToSnakeCaseIdentifier(CodegenNamingLanguage::Rust, info.shortName) + "_" +
               std::to_string(info.majorVersion) + "_" + std::to_string(info.minorVersion);
    }

    std::string rustTypeName(const DiscoveredDefinition& info) const
    {
        std::string out;
        for (std::size_t i = 0; i < info.namespaceComponents.size(); ++i)
        {
            if (!out.empty())
            {
                out += "_";
            }
            out += codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, info.namespaceComponents[i]);
        }
        if (!out.empty())
        {
            out += "_";
        }
        out += codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, info.shortName);
        out += "_" + std::to_string(info.majorVersion) + "_" + std::to_string(info.minorVersion);
        return codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, out);
    }

    std::string rustTypeName(const SemanticTypeRef& ref) const
    {
        if (const auto* def = find(ref))
        {
            return rustTypeName(def->info);
        }

        DiscoveredDefinition tmp;
        tmp.shortName           = ref.shortName;
        tmp.namespaceComponents = ref.namespaceComponents;
        tmp.majorVersion        = ref.majorVersion;
        tmp.minorVersion        = ref.minorVersion;
        return rustTypeName(tmp);
    }

    std::string rustTypePath(const SemanticTypeRef& ref) const
    {
        std::ostringstream out;
        out << "crate";
        for (const auto& ns : ref.namespaceComponents)
        {
            out << "::" << codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, ns);
        }

        if (const auto* def = find(ref))
        {
            out << "::" << rustModuleName(def->info) << "::" << rustTypeName(def->info);
            return out.str();
        }

        DiscoveredDefinition tmp;
        tmp.shortName           = ref.shortName;
        tmp.namespaceComponents = ref.namespaceComponents;
        tmp.majorVersion        = ref.majorVersion;
        tmp.minorVersion        = ref.minorVersion;
        out << "::" << rustModuleName(tmp) << "::" << rustTypeName(tmp);
        return out.str();
    }

private:
    DefinitionIndex index_;
};

std::string rustFieldBaseType(const SemanticFieldType& type, const EmitterContext& ctx)
{
    switch (type.scalarCategory)
    {
    case SemanticScalarCategory::Bool:
        return "bool";
    case SemanticScalarCategory::Byte:
    case SemanticScalarCategory::Utf8:
    case SemanticScalarCategory::UnsignedInt:
        return unsignedStorageType(type.bitLength);
    case SemanticScalarCategory::SignedInt:
        return signedStorageType(type.bitLength);
    case SemanticScalarCategory::Float:
        return type.bitLength == 64 ? "f64" : "f32";
    case SemanticScalarCategory::Void:
        return "u8";
    case SemanticScalarCategory::Composite:
        if (type.compositeType)
        {
            return ctx.rustTypeName(*type.compositeType);
        }
        return "u8";
    }
    return "u8";
}

std::string rustFieldType(const SemanticFieldType& type, const EmitterContext& ctx)
{
    const auto base = rustFieldBaseType(type, ctx);
    if (type.arrayKind == ArrayKind::None)
    {
        return base;
    }
    return "crate::dsdl_runtime::DsdlVec<" + base + ">";
}

std::string defaultExpr(const SemanticFieldType& type, const EmitterContext& ctx)
{
    if (type.arrayKind != ArrayKind::None)
    {
        return "crate::dsdl_runtime::DsdlVec::new()";
    }

    switch (type.scalarCategory)
    {
    case SemanticScalarCategory::Bool:
        return "false";
    case SemanticScalarCategory::Byte:
    case SemanticScalarCategory::Utf8:
    case SemanticScalarCategory::UnsignedInt:
        return "0";
    case SemanticScalarCategory::SignedInt:
        return "0";
    case SemanticScalarCategory::Float:
        return type.bitLength == 64 ? "0.0f64" : "0.0f32";
    case SemanticScalarCategory::Void:
        return "0";
    case SemanticScalarCategory::Composite:
        if (type.compositeType)
        {
            return ctx.rustTypeName(*type.compositeType) + "::default()";
        }
        return "0";
    }
    return "0";
}

class FunctionBodyEmitter final
{
public:
    explicit FunctionBodyEmitter(const EmitterContext&                               ctx,
                                 const std::unordered_map<std::string, std::string>& poolClassConstExprByField)
        : ctx_(ctx)
        , poolClassConstExprByField_(poolClassConstExprByField)
    {
    }

    void emitSerialize(std::ostringstream&              out,
                       const std::string&               typeName,
                       const SemanticSection&           section,
                       const LoweredSectionFacts* const sectionFacts)
    {
        (void) typeName;
        emitLine(out, 1, "pub fn serialize(&self, buffer: &mut [u8]) -> core::result::Result<usize, i8> {");
        emitLine(out, 2, "let mut offset_bits: usize = 0;");
        const auto emitted = emitNativeFunctionSkeleton(
            section,
            sectionFacts,
            HelperBindingDirection::Serialize,
            NativeFunctionSkeletonCallbacks{[this, &out](const SectionHelperBindingPlan& helperBindings) {
                                                emitSerializeMlirHelperBindings(out, helperBindings, 2);
                                            },
                                            [&out](const std::string& missingHelperRequirement) {
                                                emitLine(out,
                                                         2,
                                                         "// missing lowered helper contract: " +
                                                             missingHelperRequirement);
                                                emitLine(out,
                                                         2,
                                                         "return "
                                                         "Err(-crate::dsdl_runtime::DSDL_RUNTIME_ERROR_INVALID_"
                                                         "ARGUMENT);");
                                            },
                                            [this, &out](const SectionHelperBindingPlan& helperBindings) {
                                                const auto capacityHelper =
                                                    helperBindingName(helperBindings.capacityCheck->symbol);
                                                emitLine(out,
                                                         2,
                                                         "let _err_capacity = " + capacityHelper +
                                                             "(buffer.len().saturating_mul(8) as i64);");
                                                emitLine(out,
                                                         2,
                                                         "if _err_capacity != "
                                                         "crate::dsdl_runtime::DSDL_RUNTIME_SUCCESS {");
                                                emitLine(out, 3, "return Err(_err_capacity);");
                                                emitLine(out, 2, "}");
                                            },
                                            [this, &out, &section, sectionFacts](const LoweredBodyRenderIR& renderIR) {
                                                NativeEmitterTraversalCallbacks callbacks;
                                                callbacks.onUnionDispatch =
                                                    [this, &out, &section, sectionFacts, &renderIR](
                                                        const std::vector<PlannedFieldStep>& unionBranches) {
                                                        emitSerializeUnion(out,
                                                                           section,
                                                                           unionBranches,
                                                                           2,
                                                                           sectionFacts,
                                                                           renderIR.helperBindings);
                                                    };
                                                callbacks.onFieldAlignment = [this,
                                                                              &out](const std::int64_t alignmentBits) {
                                                    emitAlignSerialize(out, alignmentBits, 2);
                                                };
                                                callbacks.onField = [this, &out](const PlannedFieldStep& fieldStep) {
                                                    const auto* const field = fieldStep.field;
                                                    const auto        fieldRef =
                                                        "self." + codegenSanitizeIdentifier(CodegenNamingLanguage::Rust,
                                                                                            field->name);
                                                    emitSerializeAny(out,
                                                                     field->resolvedType,
                                                                     fieldRef,
                                                                     2,
                                                                     fieldStep.arrayLengthPrefixBits,
                                                                     fieldStep.fieldFacts);
                                                };
                                                callbacks.onPaddingAlignment =
                                                    [this, &out](const std::int64_t alignmentBits) {
                                                        emitAlignSerialize(out, alignmentBits, 2);
                                                    };
                                                callbacks.onPadding = [this, &out](const PlannedFieldStep& fieldStep) {
                                                    const auto* const field = fieldStep.field;
                                                    emitSerializePadding(out, field->resolvedType, 2);
                                                };
                                                return callbacks;
                                            },
                                            [this, &out]() {
                                                emitAlignSerialize(out, 8, 2);
                                                emitLine(out, 2, "Ok(offset_bits / 8)");
                                            }});
        if (!emitted)
        {
            emitLine(out, 1, "}");
            return;
        }
        emitLine(out, 1, "}");
    }

    void emitDeserialize(std::ostringstream&              out,
                         const std::string&               typeName,
                         const SemanticSection&           section,
                         const LoweredSectionFacts* const sectionFacts)
    {
        (void) typeName;
        emitLine(out, 1, "pub fn deserialize(&mut self, buffer: &[u8]) -> core::result::Result<usize, i8> {");
        emitLine(out, 2, "let capacity_bytes = buffer.len();");
        emitLine(out, 2, "let capacity_bits = capacity_bytes.saturating_mul(8);\n");
        emitLine(out, 2, "let mut offset_bits: usize = 0;");
        const auto emitted = emitNativeFunctionSkeleton(
            section,
            sectionFacts,
            HelperBindingDirection::Deserialize,
            NativeFunctionSkeletonCallbacks{[this, &out](const SectionHelperBindingPlan& helperBindings) {
                                                emitDeserializeMlirHelperBindings(out, helperBindings, 2);
                                            },
                                            [&out](const std::string& missingHelperRequirement) {
                                                emitLine(out,
                                                         2,
                                                         "// missing lowered helper contract: " +
                                                             missingHelperRequirement);
                                                emitLine(out,
                                                         2,
                                                         "return "
                                                         "Err(-crate::dsdl_runtime::DSDL_RUNTIME_ERROR_INVALID_"
                                                         "ARGUMENT);");
                                            },
                                            nullptr,
                                            [this, &out, &section, sectionFacts](const LoweredBodyRenderIR& renderIR) {
                                                NativeEmitterTraversalCallbacks callbacks;
                                                callbacks.onUnionDispatch =
                                                    [this, &out, &section, sectionFacts, &renderIR](
                                                        const std::vector<PlannedFieldStep>& unionBranches) {
                                                        emitDeserializeUnion(out,
                                                                             section,
                                                                             unionBranches,
                                                                             2,
                                                                             sectionFacts,
                                                                             renderIR.helperBindings);
                                                    };
                                                callbacks.onFieldAlignment = [this,
                                                                              &out](const std::int64_t alignmentBits) {
                                                    emitAlignDeserialize(out, alignmentBits, 2);
                                                };
                                                callbacks.onField = [this, &out](const PlannedFieldStep& fieldStep) {
                                                    const auto* const field = fieldStep.field;
                                                    const auto        fieldRef =
                                                        "self." + codegenSanitizeIdentifier(CodegenNamingLanguage::Rust,
                                                                                            field->name);
                                                    emitDeserializeAny(out,
                                                                       field->resolvedType,
                                                                       fieldRef,
                                                                       2,
                                                                       fieldStep.arrayLengthPrefixBits,
                                                                       fieldStep.fieldFacts,
                                                                       poolClassConstExprForField(field->name));
                                                };
                                                callbacks.onPaddingAlignment =
                                                    [this, &out](const std::int64_t alignmentBits) {
                                                        emitAlignDeserialize(out, alignmentBits, 2);
                                                    };
                                                callbacks.onPadding = [this, &out](const PlannedFieldStep& fieldStep) {
                                                    const auto* const field = fieldStep.field;
                                                    emitDeserializePadding(out, field->resolvedType, 2);
                                                };
                                                return callbacks;
                                            },
                                            [this, &out]() {
                                                emitAlignDeserialize(out, 8, 2);
                                                emitLine(out,
                                                         2,
                                                         "Ok(crate::dsdl_runtime::choose_min(offset_bits, "
                                                         "capacity_bits) / 8)");
                                            }});
        if (!emitted)
        {
            emitLine(out, 1, "}");
            return;
        }
        emitLine(out, 1, "}");
        emitLine(out, 0, "");
        emitLine(out, 1, "pub fn deserialize_with_consumed(&mut self, buffer: &[u8]) -> (i8, usize) {");
        emitLine(out, 2, "match self.deserialize(buffer) {");
        emitLine(out, 3, "Ok(consumed) => (0, consumed),");
        emitLine(out, 3, "Err(rc) => (rc, buffer.len()),");
        emitLine(out, 2, "}");
        emitLine(out, 1, "}");
    }

private:
    const EmitterContext&                               ctx_;
    const std::unordered_map<std::string, std::string>& poolClassConstExprByField_;
    std::size_t                                         id_{0};

    std::string poolClassConstExprForField(const std::string& fieldName) const
    {
        const auto it = poolClassConstExprByField_.find(fieldName);
        if (it == poolClassConstExprByField_.end())
        {
            return "crate::dsdl_runtime::AllocationClassId(0u32)";
        }
        return it->second;
    }

    std::string nextName(const std::string& prefix)
    {
        return "_" + prefix + std::to_string(id_++) + "_";
    }

    std::string helperBindingName(const std::string& helperSymbol) const
    {
        return renderHelperBindingIdentifier(CodegenNamingLanguage::Rust, helperSymbol);
    }

    void emitSerializeMlirHelperBindings(std::ostringstream&             out,
                                         const SectionHelperBindingPlan& plan,
                                         const int                       indent)
    {
        for (const auto& line : renderSectionHelperBindings(
                 plan,
                 HelperBindingRenderLanguage::Rust,
                 ScalarBindingRenderDirection::Serialize,
                 [this](const std::string& symbol) { return helperBindingName(symbol); },
                 /*emitCapacityCheck=*/true))
        {
            emitLine(out, indent, line);
        }
    }

    void emitDeserializeMlirHelperBindings(std::ostringstream&             out,
                                           const SectionHelperBindingPlan& plan,
                                           const int                       indent)
    {
        for (const auto& line : renderSectionHelperBindings(
                 plan,
                 HelperBindingRenderLanguage::Rust,
                 ScalarBindingRenderDirection::Deserialize,
                 [this](const std::string& symbol) { return helperBindingName(symbol); },
                 /*emitCapacityCheck=*/false))
        {
            emitLine(out, indent, line);
        }
    }

    void emitAlignSerialize(std::ostringstream& out, const std::int64_t alignmentBits, const int indent)
    {
        if (alignmentBits <= 1)
        {
            return;
        }
        const auto err = nextName("err");
        emitLine(out, indent, "while (offset_bits % " + std::to_string(alignmentBits) + "usize) != 0 {");
        emitLine(out, indent + 1, "let " + err + " = crate::dsdl_runtime::set_bit(buffer, offset_bits, false);");
        emitLine(out, indent + 1, "if " + err + " < 0 { return Err(" + err + "); }");
        emitLine(out, indent + 1, "offset_bits += 1;");
        emitLine(out, indent, "}");
    }

    void emitAlignDeserialize(std::ostringstream& out, const std::int64_t alignmentBits, const int indent)
    {
        if (alignmentBits <= 1)
        {
            return;
        }
        emitLine(out,
                 indent,
                 "offset_bits = (offset_bits + " + std::to_string(alignmentBits - 1) + ") & !" +
                     std::to_string(alignmentBits - 1) + "usize;");
    }

    void emitSerializePadding(std::ostringstream& out, const SemanticFieldType& type, const int indent)
    {
        if (type.bitLength == 0)
        {
            return;
        }
        const auto err = nextName("err");
        emitLine(out,
                 indent,
                 "let " + err + " = crate::dsdl_runtime::set_uxx(buffer, offset_bits, 0, " +
                     std::to_string(type.bitLength) + "u8);");
        emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
        emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
    }

    void emitDeserializePadding(std::ostringstream& out, const SemanticFieldType& type, const int indent)
    {
        if (type.bitLength == 0)
        {
            return;
        }
        emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
    }

    void emitSerializeUnion(std::ostringstream&                  out,
                            const SemanticSection&               section,
                            const std::vector<PlannedFieldStep>& unionBranches,
                            const int                            indent,
                            const LoweredSectionFacts* const     sectionFacts,
                            const SectionHelperBindingPlan&      helperBindings)
    {
        const auto tagBits        = resolveUnionTagBits(section, sectionFacts);
        const auto validateHelper = helperBindingName(helperBindings.unionTagValidate->symbol);
        emitLine(out, indent, "let _err_union_tag = " + validateHelper + "(self._tag_ as i64);");
        emitLine(out,
                 indent,
                 "if _err_union_tag != crate::dsdl_runtime::DSDL_RUNTIME_SUCCESS { return Err(_err_union_tag); }");
        const auto tagHelper = helperBindingName(helperBindings.unionTagMask->symbol);
        const auto tagExpr   = tagHelper + "(self._tag_ as u64)";

        const auto tagErr = nextName("err");
        emitLine(out,
                 indent,
                 "let " + tagErr + " = crate::dsdl_runtime::set_uxx(buffer, offset_bits, " + tagExpr + ", " +
                     std::to_string(tagBits) + "u8);");
        emitLine(out, indent, "if " + tagErr + " < 0 { return Err(" + tagErr + "); }");
        emitLine(out, indent, "offset_bits += " + std::to_string(tagBits) + ";");

        emitLine(out, indent, "match self._tag_ {");
        for (const auto& step : unionBranches)
        {
            const auto& field = *step.field;
            emitLine(out, indent + 1, std::to_string(field.unionOptionIndex) + " => {");
            emitAlignSerialize(out, field.resolvedType.alignmentBits, indent + 2);
            emitSerializeAny(out,
                             field.resolvedType,
                             "self." + codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, field.name),
                             indent + 2,
                             step.arrayLengthPrefixBits,
                             step.fieldFacts);
            emitLine(out, indent + 1, "}");
        }
        emitLine(out,
                 indent + 1,
                 "_ => return Err(-crate::dsdl_runtime::DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_UNION_TAG),");
        emitLine(out, indent, "}");
    }

    void emitDeserializeUnion(std::ostringstream&                  out,
                              const SemanticSection&               section,
                              const std::vector<PlannedFieldStep>& unionBranches,
                              const int                            indent,
                              const LoweredSectionFacts* const     sectionFacts,
                              const SectionHelperBindingPlan&      helperBindings)
    {
        const auto tagBits = resolveUnionTagBits(section, sectionFacts);
        const auto rawTag  = nextName("tag_raw");
        emitLine(out,
                 indent,
                 "let " + rawTag + " = crate::dsdl_runtime::get_u64(buffer, offset_bits, " + std::to_string(tagBits) +
                     "u8);");
        const auto tagHelper = helperBindingName(helperBindings.unionTagMask->symbol);
        const auto tagExpr   = tagHelper + "(" + rawTag + ")";
        emitLine(out, indent, "self._tag_ = (" + tagExpr + ") as u8;");
        const auto validateHelper = helperBindingName(helperBindings.unionTagValidate->symbol);
        emitLine(out, indent, "let _err_union_tag = " + validateHelper + "(self._tag_ as i64);");
        emitLine(out,
                 indent,
                 "if _err_union_tag != crate::dsdl_runtime::DSDL_RUNTIME_SUCCESS { return Err(_err_union_tag); }");
        emitLine(out, indent, "offset_bits += " + std::to_string(tagBits) + ";");

        emitLine(out, indent, "match self._tag_ {");
        for (const auto& step : unionBranches)
        {
            const auto& field = *step.field;
            emitLine(out, indent + 1, std::to_string(field.unionOptionIndex) + " => {");
            emitAlignDeserialize(out, field.resolvedType.alignmentBits, indent + 2);
            emitDeserializeAny(out,
                               field.resolvedType,
                               "self." + codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, field.name),
                               indent + 2,
                               step.arrayLengthPrefixBits,
                               step.fieldFacts,
                               poolClassConstExprForField(field.name));
            emitLine(out, indent + 1, "}");
        }
        emitLine(out,
                 indent + 1,
                 "_ => return Err(-crate::dsdl_runtime::DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_UNION_TAG),");
        emitLine(out, indent, "}");
    }

    void emitSerializeAny(std::ostringstream&                out,
                          const SemanticFieldType&           type,
                          const std::string&                 expr,
                          const int                          indent,
                          const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride = std::nullopt,
                          const LoweredFieldFacts* const     fieldFacts                    = nullptr)
    {
        if (type.arrayKind != ArrayKind::None)
        {
            emitSerializeArray(out, type, expr, indent, arrayLengthPrefixBitsOverride, fieldFacts);
            return;
        }
        emitSerializeScalar(out, type, expr, indent, fieldFacts);
    }

    void emitDeserializeAny(std::ostringstream&                out,
                            const SemanticFieldType&           type,
                            const std::string&                 expr,
                            const int                          indent,
                            const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride = std::nullopt,
                            const LoweredFieldFacts* const     fieldFacts                    = nullptr,
                            const std::string&                 poolClassConstExpr            = "")
    {
        if (type.arrayKind != ArrayKind::None)
        {
            emitDeserializeArray(out,
                                 type,
                                 expr,
                                 indent,
                                 arrayLengthPrefixBitsOverride,
                                 fieldFacts,
                                 poolClassConstExpr);
            return;
        }
        emitDeserializeScalar(out, type, expr, indent, fieldFacts);
    }

    void emitSerializeScalar(std::ostringstream&            out,
                             const SemanticFieldType&       type,
                             const std::string&             expr,
                             const int                      indent,
                             const LoweredFieldFacts* const fieldFacts)
    {
        switch (type.scalarCategory)
        {
        case SemanticScalarCategory::Bool: {
            const auto err = nextName("err");
            emitLine(out, indent, "let " + err + " = crate::dsdl_runtime::set_bit(buffer, offset_bits, " + expr + ");");
            emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
            emitLine(out, indent, "offset_bits += 1;");
            break;
        }
        case SemanticScalarCategory::Byte:
        case SemanticScalarCategory::Utf8:
        case SemanticScalarCategory::UnsignedInt: {
            std::string valueExpr    = expr + " as u64";
            const auto  helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            valueExpr         = helper + "(" + valueExpr + ")";

            const auto err = nextName("err");
            emitLine(out,
                     indent,
                     "let " + err + " = crate::dsdl_runtime::set_uxx(buffer, offset_bits, " + valueExpr + ", " +
                         std::to_string(type.bitLength) + "u8);");
            emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::SignedInt: {
            std::string valueExpr    = expr + " as i64";
            const auto  helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            valueExpr         = helper + "(" + valueExpr + ")";

            const auto err = nextName("err");
            emitLine(out,
                     indent,
                     "let " + err + " = crate::dsdl_runtime::set_ixx(buffer, offset_bits, " + valueExpr + ", " +
                         std::to_string(type.bitLength) + "u8);");
            emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::Float: {
            const auto  err            = nextName("err");
            std::string normalizedExpr = expr + " as f64";
            const auto  helperSymbol   = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Serialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            normalizedExpr    = helper + "(" + normalizedExpr + ")";
            std::string setCall;
            if (type.bitLength == 16U)
            {
                setCall = "crate::dsdl_runtime::set_f16(buffer, offset_bits, " + normalizedExpr + " as f32)";
            }
            else if (type.bitLength == 32U)
            {
                setCall = "crate::dsdl_runtime::set_f32(buffer, offset_bits, " + normalizedExpr + " as f32)";
            }
            else
            {
                setCall = "crate::dsdl_runtime::set_f64(buffer, offset_bits, " + normalizedExpr + " as f64)";
            }
            emitLine(out, indent, "let " + err + " = " + setCall + ";");
            emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::Void:
            emitSerializePadding(out, type, indent);
            break;
        case SemanticScalarCategory::Composite:
            emitSerializeComposite(out, type, expr, indent, fieldFacts);
            break;
        }
    }

    void emitDeserializeScalar(std::ostringstream&            out,
                               const SemanticFieldType&       type,
                               const std::string&             expr,
                               const int                      indent,
                               const LoweredFieldFacts* const fieldFacts)
    {
        switch (type.scalarCategory)
        {
        case SemanticScalarCategory::Bool:
            emitLine(out, indent, expr + " = crate::dsdl_runtime::get_bit(buffer, offset_bits);");
            emitLine(out, indent, "offset_bits += 1;");
            break;
        case SemanticScalarCategory::Byte:
        case SemanticScalarCategory::Utf8:
        case SemanticScalarCategory::UnsignedInt: {
            const std::string getter = "get_u" + std::string(scalarWidthSuffix(type.bitLength));
            const auto helperSymbol  = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            const auto raw    = nextName("raw");
            emitLine(out,
                     indent,
                     "let " + raw + " = crate::dsdl_runtime::" + getter + "(buffer, offset_bits, " +
                         std::to_string(type.bitLength) + "u8) as u64;");
            emitLine(out,
                     indent,
                     expr + " = " + helper + "(" + raw + ") as " + unsignedStorageType(type.bitLength) + ";");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::SignedInt: {
            const std::string getter = "get_i" + std::string(scalarWidthSuffix(type.bitLength));
            const auto helperSymbol  = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            const auto raw    = nextName("raw");
            emitLine(out,
                     indent,
                     "let " + raw + " = crate::dsdl_runtime::get_u64(buffer, offset_bits, " +
                         std::to_string(type.bitLength) + "u8) as i64;");
            emitLine(out,
                     indent,
                     expr + " = " + helper + "(" + raw + ") as " + signedStorageType(type.bitLength) + ";");
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::Float: {
            const auto helperSymbol = resolveScalarHelperSymbol(type, fieldFacts, HelperBindingDirection::Deserialize);
            assert(!helperSymbol.empty());
            const auto helper = helperBindingName(helperSymbol);
            if (type.bitLength == 16U)
            {
                emitLine(out,
                         indent,
                         expr + " = " + helper + "(crate::dsdl_runtime::get_f16(buffer, offset_bits) as f64) as f32;");
            }
            else if (type.bitLength == 32U)
            {
                emitLine(out,
                         indent,
                         expr + " = " + helper + "(crate::dsdl_runtime::get_f32(buffer, offset_bits) as f64) as f32;");
            }
            else
            {
                emitLine(out,
                         indent,
                         expr + " = " + helper + "(crate::dsdl_runtime::get_f64(buffer, offset_bits) as f64) as f64;");
            }
            emitLine(out, indent, "offset_bits += " + std::to_string(type.bitLength) + ";");
            break;
        }
        case SemanticScalarCategory::Void:
            emitDeserializePadding(out, type, indent);
            break;
        case SemanticScalarCategory::Composite:
            emitDeserializeComposite(out, type, expr, indent, fieldFacts);
            break;
        }
    }

    void emitSerializeArray(std::ostringstream&                out,
                            const SemanticFieldType&           type,
                            const std::string&                 expr,
                            const int                          indent,
                            const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride,
                            const LoweredFieldFacts* const     fieldFacts)
    {
        const auto arrayPlan =
            buildArrayWirePlan(type, fieldFacts, arrayLengthPrefixBitsOverride, HelperBindingDirection::Serialize);
        const bool  variable        = arrayPlan.variable;
        const auto  prefixBits      = arrayPlan.prefixBits;
        const auto& arrayDescriptor = arrayPlan.descriptor;

        if (type.arrayKind == ArrayKind::Fixed)
        {
            emitLine(out,
                     indent,
                     "if " + expr + ".len() != " + std::to_string(type.arrayCapacity) +
                         "usize { return "
                         "Err(-crate::dsdl_runtime::DSDL_RUNTIME_ERROR_REPRESENTATION_BAD_ARRAY_LENGTH); }");
        }

        if (variable)
        {
            assert(arrayDescriptor.has_value());
            assert(!arrayDescriptor->validateSymbol.empty());
            const auto validateHelper = helperBindingName(arrayDescriptor->validateSymbol);
            const auto validateRc     = nextName("len_rc");
            emitLine(out, indent, "let " + validateRc + " = " + validateHelper + "(" + expr + ".len() as i64);");
            emitLine(out, indent, "if " + validateRc + " < 0 { return Err(" + validateRc + "); }");
            std::string prefixExpr = expr + ".len() as u64";
            assert(!arrayDescriptor->prefixSymbol.empty());
            const auto serPrefixHelper = helperBindingName(arrayDescriptor->prefixSymbol);
            prefixExpr                 = serPrefixHelper + "(" + prefixExpr + ")";
            const auto err             = nextName("err");
            emitLine(out,
                     indent,
                     "let " + err + " = crate::dsdl_runtime::set_uxx(buffer, offset_bits, " + prefixExpr + ", " +
                         std::to_string(prefixBits) + "u8);");
            emitLine(out, indent, "if " + err + " < 0 { return Err(" + err + "); }");
            emitLine(out, indent, "offset_bits += " + std::to_string(prefixBits) + ";");
        }

        const auto index = nextName("index");
        const auto count = variable ? (expr + ".len()") : std::to_string(type.arrayCapacity) + "usize";

        emitLine(out, indent, "for " + index + " in 0.." + count + " {");

        const auto itemType = arrayElementType(type);

        if (itemType.scalarCategory == SemanticScalarCategory::Composite)
        {
            emitSerializeScalar(out, itemType, expr + "[" + index + "]", indent + 1, fieldFacts);
        }
        else
        {
            emitSerializeScalar(out, itemType, expr + "[" + index + "]", indent + 1, fieldFacts);
        }
        emitLine(out, indent, "}");
    }

    void emitDeserializeArray(std::ostringstream&                out,
                              const SemanticFieldType&           type,
                              const std::string&                 expr,
                              const int                          indent,
                              const std::optional<std::uint32_t> arrayLengthPrefixBitsOverride,
                              const LoweredFieldFacts* const     fieldFacts,
                              const std::string&                 poolClassConstExpr)
    {
        if (!poolClassConstExpr.empty())
        {
            emitLine(out,
                     indent,
                     expr +
                         ".set_memory_contract(crate::dsdl_runtime::VarArrayMemoryContract::new("
                         "Self::__LLVMDSDL_MEMORY_MODE, "
                         "Self::__LLVMDSDL_INLINE_THRESHOLD_BYTES, " +
                         poolClassConstExpr + "));");
        }
        const auto arrayPlan =
            buildArrayWirePlan(type, fieldFacts, arrayLengthPrefixBitsOverride, HelperBindingDirection::Deserialize);
        const bool  variable        = arrayPlan.variable;
        const auto  prefixBits      = arrayPlan.prefixBits;
        const auto& arrayDescriptor = arrayPlan.descriptor;
        const auto  count           = nextName("count");

        if (variable)
        {
            const auto rawCount = nextName("count_raw");
            emitLine(out,
                     indent,
                     "let " + rawCount + " = crate::dsdl_runtime::get_u64(buffer, offset_bits, " +
                         std::to_string(prefixBits) + "u8);");
            emitLine(out, indent, "offset_bits += " + std::to_string(prefixBits) + ";");
            std::string countExpr = rawCount + " as usize";
            assert(arrayDescriptor.has_value());
            assert(!arrayDescriptor->prefixSymbol.empty());
            const auto deserPrefixHelper = helperBindingName(arrayDescriptor->prefixSymbol);
            countExpr                    = deserPrefixHelper + "(" + rawCount + ") as usize";
            emitLine(out, indent, "let " + count + " = " + countExpr + ";");
            assert(!arrayDescriptor->validateSymbol.empty());
            const auto validateHelper = helperBindingName(arrayDescriptor->validateSymbol);
            const auto validateRc     = nextName("len_rc");
            emitLine(out, indent, "let " + validateRc + " = " + validateHelper + "(" + count + " as i64);");
            emitLine(out, indent, "if " + validateRc + " < 0 { return Err(" + validateRc + "); }");
        }
        else
        {
            emitLine(out, indent, "let " + count + " = " + std::to_string(type.arrayCapacity) + "usize;");
        }
        emitLine(out, indent, expr + ".clear();");
        emitLine(out,
                 indent,
                 "if Self::__LLVMDSDL_MEMORY_MODE == "
                 "crate::dsdl_runtime::DsdlMemoryMode::InlineThenPool {");
        emitLine(out, indent + 1, "let mut _pool = crate::dsdl_runtime::PassthroughPoolProvider::default();");
        emitLine(out,
                 indent + 1,
                 "if let Err(_alloc_err) = " + expr + ".reserve_with_pool(" + count +
                     ", &mut _pool)"
                     " {");
        emitLine(out, indent + 2, "return Err(-crate::dsdl_runtime::allocation_error_to_runtime_code(_alloc_err));");
        emitLine(out, indent + 1, "}");
        emitLine(out, indent, "} else {");
        emitLine(out, indent + 1, expr + ".reserve(" + count + ");");
        emitLine(out, indent, "}");

        const auto index = nextName("index");
        emitLine(out, indent, "for " + index + " in 0.." + count + " {");

        const auto itemType = arrayElementType(type);

        const auto itemVar = nextName("item");
        emitLine(out, indent + 1, "let mut " + itemVar + " = " + defaultExpr(itemType, ctx_) + ";");
        emitDeserializeScalar(out, itemType, itemVar, indent + 1, fieldFacts);
        emitLine(out, indent + 1, expr + ".push(" + itemVar + ");");
        emitLine(out, indent, "}");
    }

    void emitSerializeComposite(std::ostringstream&            out,
                                const SemanticFieldType&       type,
                                const std::string&             expr,
                                const int                      indent,
                                const LoweredFieldFacts* const fieldFacts)
    {
        const auto sizeVar = nextName("size_bytes");
        const auto errVar  = nextName("err");

        if (!type.compositeSealed)
        {
            emitLine(out, indent, "offset_bits += 32;  // Delimiter header");
        }

        emitLine(out,
                 indent,
                 "let mut " + sizeVar + " = " + std::to_string((type.bitLengthSet.max() + 7) / 8) + "usize;");
        if (!type.compositeSealed)
        {
            emitLine(out,
                     indent,
                     "let _remaining = buffer.len().saturating_sub(crate::dsdl_runtime::choose_min(offset_bits / 8, "
                     "buffer.len()));");
            const auto helperSymbol = resolveDelimiterValidateHelperSymbol(type, fieldFacts);
            assert(!helperSymbol.empty());
            const auto helper     = helperBindingName(helperSymbol);
            const auto validateRc = nextName("rc");
            emitLine(out,
                     indent,
                     "let " + validateRc + " = " + helper + "(" + sizeVar + " as i64, _remaining as i64);");
            emitLine(out, indent, "if " + validateRc + " < 0 { return Err(" + validateRc + "); }");
        }
        emitLine(out, indent, "let _start = crate::dsdl_runtime::choose_min(offset_bits / 8, buffer.len());");
        emitLine(out, indent, "let _end = _start.saturating_add(" + sizeVar + ").min(buffer.len());");
        emitLine(out, indent, "let " + errVar + " = " + expr + ".serialize(&mut buffer[_start.._end]);");
        emitLine(out, indent, "match " + errVar + " {");
        emitLine(out, indent + 1, "Ok(v) => " + sizeVar + " = v,");
        emitLine(out, indent + 1, "Err(e) => return Err(e),");
        emitLine(out, indent, "}");

        if (!type.compositeSealed)
        {
            const auto hdrErr = nextName("err");
            emitLine(out,
                     indent,
                     "let " + hdrErr + " = crate::dsdl_runtime::set_uxx(buffer, offset_bits - 32, " + sizeVar +
                         " as u64, 32u8);");
            emitLine(out, indent, "if " + hdrErr + " < 0 { return Err(" + hdrErr + "); }");
        }

        emitLine(out, indent, "offset_bits += " + sizeVar + " * 8;");
    }

    void emitDeserializeComposite(std::ostringstream&            out,
                                  const SemanticFieldType&       type,
                                  const std::string&             expr,
                                  const int                      indent,
                                  const LoweredFieldFacts* const fieldFacts)
    {
        const auto sizeVar = nextName("size_bytes");

        if (!type.compositeSealed)
        {
            emitLine(out,
                     indent,
                     "let " + sizeVar + " = crate::dsdl_runtime::get_u32(buffer, offset_bits, 32u8) as usize;");
            emitLine(out, indent, "offset_bits += 32;");
            emitLine(out,
                     indent,
                     "let _remaining = capacity_bytes.saturating_sub(crate::dsdl_runtime::choose_min(offset_bits / 8, "
                     "capacity_bytes));");
            const auto helperSymbol = resolveDelimiterValidateHelperSymbol(type, fieldFacts);
            assert(!helperSymbol.empty());
            const auto helper     = helperBindingName(helperSymbol);
            const auto validateRc = nextName("rc");
            emitLine(out,
                     indent,
                     "let " + validateRc + " = " + helper + "(" + sizeVar + " as i64, _remaining as i64);");
            emitLine(out, indent, "if " + validateRc + " < 0 { return Err(" + validateRc + "); }");
            emitLine(out, indent, "let _start = crate::dsdl_runtime::choose_min(offset_bits / 8, buffer.len());");
            emitLine(out, indent, "let _end = _start.saturating_add(" + sizeVar + ").min(buffer.len());");
            emitLine(out, indent, "if let Err(e) = " + expr + ".deserialize(&buffer[_start.._end]) { return Err(e); }");
            emitLine(out, indent, "offset_bits += " + sizeVar + " * 8;");
            return;
        }

        emitLine(out, indent, "let _start = crate::dsdl_runtime::choose_min(offset_bits / 8, buffer.len());");
        emitLine(out, indent, "let _slice = &buffer[_start..buffer.len()];");
        emitLine(out,
                 indent,
                 "let _consumed = match " + expr + ".deserialize(_slice) { Ok(v) => v, Err(e) => return Err(e) };\n");
        emitLine(out, indent, "offset_bits += _consumed * 8;");
    }
};

std::string rustConstType(const TypeExprAST& type)
{
    const auto* prim = std::get_if<PrimitiveTypeExprAST>(&type.scalar);
    if (!prim)
    {
        return "i64";
    }
    switch (prim->kind)
    {
    case PrimitiveKind::Bool:
        return "bool";
    case PrimitiveKind::Float:
        return "f64";
    case PrimitiveKind::SignedInt:
        return "i64";
    case PrimitiveKind::UnsignedInt:
    case PrimitiveKind::Byte:
    case PrimitiveKind::Utf8:
        return "u64";
    }
    return "i64";
}

std::string rustConstType(const TypeExprAST& type, const Value& value)
{
    if (std::holds_alternative<std::string>(value.data))
    {
        return "&'static str";
    }
    if (std::holds_alternative<bool>(value.data))
    {
        return "bool";
    }
    return rustConstType(type);
}

void emitSectionType(std::ostringstream&              out,
                     const std::string&               typeName,
                     const SemanticSection&           section,
                     const EmitterContext&            ctx,
                     const RustEmitOptions&           options,
                     const std::string&               fullName,
                     std::uint32_t                    majorVersion,
                     std::uint32_t                    minorVersion,
                     const AttachedDoc&               typeDoc,
                     const LoweredSectionFacts* const sectionFacts)
{
    std::unordered_map<std::string, std::string>       poolClassConstExprByField;
    std::vector<std::pair<std::string, std::uint32_t>> poolClassConstants;
    std::set<std::string>                              usedPoolConstNames;
    std::uint32_t                                      nextPoolClassId = 1U;
    for (const auto& field : section.fields)
    {
        if (field.isPadding || field.resolvedType.arrayKind == ArrayKind::None)
        {
            continue;
        }
        const std::string baseName =
            "__LLVMDSDL_POOL_CLASS_" + codegenToUpperSnakeCaseIdentifier(CodegenNamingLanguage::Rust, field.name);
        std::string constName = baseName;
        for (std::uint32_t suffix = 1U; !usedPoolConstNames.insert(constName).second; ++suffix)
        {
            constName = baseName + "_" + std::to_string(suffix);
        }
        poolClassConstExprByField.emplace(field.name, "Self::" + constName);
        poolClassConstants.emplace_back(constName, nextPoolClassId++);
    }

    emitAttachedDocRust(out, 0, typeDoc);
    emitLine(out, 0, "#[derive(Clone, Debug, PartialEq)]");
    emitLine(out, 0, "pub struct " + typeName + " {");

    std::size_t fieldCount = 0;
    for (const auto& field : section.fields)
    {
        if (field.isPadding)
        {
            continue;
        }
        ++fieldCount;
        emitAttachedDocRust(out, 1, field.doc);
        emitLine(out,
                 1,
                 "pub " + codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, field.name) + ": " +
                     rustFieldType(field.resolvedType, ctx) + ",");
    }

    if (section.isUnion)
    {
        emitLine(out, 1, "pub _tag_: u8,");
    }

    if (fieldCount == 0 && !section.isUnion)
    {
        emitLine(out, 1, "pub _dummy_: u8,");
    }
    emitLine(out, 0, "}\n");

    emitLine(out, 0, "impl Default for " + typeName + " {");
    emitLine(out, 1, "fn default() -> Self {");
    emitLine(out, 2, "Self {");
    for (const auto& field : section.fields)
    {
        if (field.isPadding)
        {
            continue;
        }
        if (field.resolvedType.arrayKind != ArrayKind::None)
        {
            const auto  classExprIt = poolClassConstExprByField.find(field.name);
            std::string classExpr   = "crate::dsdl_runtime::AllocationClassId(0u32)";
            if (classExprIt != poolClassConstExprByField.end())
            {
                classExpr = classExprIt->second;
            }
            emitLine(out,
                     3,
                     codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, field.name) +
                         ": crate::dsdl_runtime::DsdlVec::with_contract("
                         "crate::dsdl_runtime::VarArrayMemoryContract::new("
                         "Self::__LLVMDSDL_MEMORY_MODE, "
                         "Self::__LLVMDSDL_INLINE_THRESHOLD_BYTES, " +
                         classExpr + ")),");
            continue;
        }
        emitLine(out,
                 3,
                 codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, field.name) + ": " +
                     defaultExpr(field.resolvedType, ctx) + ",");
    }
    if (section.isUnion)
    {
        emitLine(out, 3, "_tag_: 0,");
    }
    if (fieldCount == 0 && !section.isUnion)
    {
        emitLine(out, 3, "_dummy_: 0,");
    }
    emitLine(out, 2, "}");
    emitLine(out, 1, "}");
    emitLine(out, 0, "}\n");

    emitLine(out, 0, "impl " + typeName + " {");
    emitLine(out, 1, "pub const FULL_NAME: &'static str = \"" + fullName + "\";");
    emitLine(out,
             1,
             "pub const FULL_NAME_AND_VERSION: &'static str = \"" + fullName + "." + std::to_string(majorVersion) +
                 "." + std::to_string(minorVersion) + "\";");
    emitLine(out, 1, "pub const EXTENT_BYTES: usize = " + std::to_string(section.extentBits.value_or(0) / 8) + ";");
    emitLine(out,
             1,
             "pub const SERIALIZATION_BUFFER_SIZE_BYTES: usize = " +
                 std::to_string((section.serializationBufferSizeBits + 7) / 8) + ";");
    emitLine(out,
             1,
             "pub const __LLVMDSDL_MEMORY_MODE: crate::dsdl_runtime::DsdlMemoryMode = " +
                 rustMemoryModeVariantPath(options) + ";");
    emitLine(out,
             1,
             "pub const __LLVMDSDL_INLINE_THRESHOLD_BYTES: usize = " + std::to_string(options.inlineThresholdBytes) +
                 "usize;");
    for (const auto& [constName, classId] : poolClassConstants)
    {
        emitLine(out,
                 1,
                 "pub const " + constName +
                     ": crate::dsdl_runtime::AllocationClassId = crate::dsdl_runtime::AllocationClassId(" +
                     std::to_string(classId) + "u32);");
    }
    if (section.isUnion)
    {
        std::size_t optionCount = 0;
        for (const auto& f : section.fields)
        {
            if (!f.isPadding)
            {
                ++optionCount;
            }
        }
        emitLine(out, 1, "pub const UNION_OPTION_COUNT: usize = " + std::to_string(optionCount) + ";");
    }

    for (const auto& c : section.constants)
    {
        emitAttachedDocRust(out, 1, c.doc);
        emitLine(out,
                 1,
                 "pub const " + codegenToUpperSnakeCaseIdentifier(CodegenNamingLanguage::Rust, c.name) + ": " +
                     rustConstType(c.type, c.value) + " = " + rustConstValue(c.value) + ";");
    }
    out << "\n";

    FunctionBodyEmitter body(ctx, poolClassConstExprByField);
    body.emitSerialize(out, typeName, section, sectionFacts);
    out << "\n";
    body.emitDeserialize(out, typeName, section, sectionFacts);
    out << "\n";

    emitLine(out, 1, "pub fn to_bytes(&self) -> core::result::Result<crate::dsdl_runtime::DsdlVec<u8>, i8> {");
    emitLine(out,
             2,
             "let mut buffer = "
             "crate::dsdl_runtime::DsdlVec::<u8>::with_capacity(Self::SERIALIZATION_BUFFER_SIZE_BYTES);");
    emitLine(out, 2, "buffer.resize(Self::SERIALIZATION_BUFFER_SIZE_BYTES, 0u8);");
    emitLine(out, 2, "let used = self.serialize(&mut buffer)?;");
    emitLine(out, 2, "buffer.truncate(used);");
    emitLine(out, 2, "Ok(buffer)");
    emitLine(out, 1, "}\n");

    emitLine(out, 1, "pub fn from_bytes(buffer: &[u8]) -> core::result::Result<(Self, usize), i8> {");
    emitLine(out, 2, "let mut out = Self::default();");
    emitLine(out, 2, "let used = out.deserialize(buffer)?;");
    emitLine(out, 2, "Ok((out, used))");
    emitLine(out, 1, "}");
    emitLine(out, 0, "}\n");
}

std::string renderDefinitionFile(const SemanticDefinition& def,
                                 const EmitterContext&     ctx,
                                 const LoweredFactsMap&    loweredFacts,
                                 const RustEmitOptions&    options)
{
    std::ostringstream out;
    emitLine(out, 0, generatedCommentLine("Rust backend"));
    emitLine(out,
             0,
             "// Source: " + def.info.fullName + "." + std::to_string(def.info.majorVersion) + "." +
                 std::to_string(def.info.minorVersion));
    emitLine(out, 0, "#![allow(non_camel_case_types)]");
    emitLine(out, 0, "#![allow(non_snake_case)]");
    emitLine(out, 0, "#![allow(non_upper_case_globals)]\n");

    const auto deps = collectDefinitionCompositeDependencies(def);

    const auto selfKey = loweredTypeKey(def.info.fullName, def.info.majorVersion, def.info.minorVersion);

    for (const auto& depRef : deps)
    {
        if (loweredTypeKey(depRef.fullName, depRef.majorVersion, depRef.minorVersion) == selfKey)
        {
            continue;
        }

        SemanticTypeRef ref = depRef;
        if (const auto* resolved = ctx.find(depRef))
        {
            ref.namespaceComponents = resolved->info.namespaceComponents;
            ref.shortName           = resolved->info.shortName;
        }

        const auto typePath = ctx.rustTypePath(ref);
        const auto rustType = ctx.rustTypeName(ref);
        emitLine(out, 0, "use " + typePath + ";");
        (void) rustType;
    }
    if (!deps.empty())
    {
        out << "\n";
    }

    const auto baseType = ctx.rustTypeName(def.info);

    if (!def.isService)
    {
        emitSectionType(out,
                        baseType,
                        def.request,
                        ctx,
                        options,
                        def.info.fullName,
                        def.info.majorVersion,
                        def.info.minorVersion,
                        def.doc,
                        lookupLoweredSectionFacts(loweredFacts, def, ""));
        return out.str();
    }

    const auto reqType  = baseType + "_Request";
    const auto respType = baseType + "_Response";

    emitSectionType(out,
                    reqType,
                    def.request,
                    ctx,
                    options,
                    def.info.fullName + ".Request",
                    def.info.majorVersion,
                    def.info.minorVersion,
                    def.doc,
                    lookupLoweredSectionFacts(loweredFacts, def, "request"));

    if (def.response)
    {
        out << "\n";
        emitSectionType(out,
                        respType,
                        *def.response,
                        ctx,
                        options,
                        def.info.fullName + ".Response",
                        def.info.majorVersion,
                        def.info.minorVersion,
                        def.doc,
                        lookupLoweredSectionFacts(loweredFacts, def, "response"));
    }

    out << "\n";
    emitLine(out, 0, "pub type " + baseType + " = " + reqType + ";");

    return out.str();
}

llvm::Expected<std::string> loadRustRuntimeFile(const std::string& fileName)
{
    const std::filesystem::path runtimePath =
        std::filesystem::path(LLVMDSDL_SOURCE_DIR) / "runtime" / "rust" / fileName;
    std::ifstream in(runtimePath.string());
    if (!in)
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                       "failed to read Rust runtime file: %s",
                                       fileName.c_str());
    }
    std::ostringstream content;
    content << in.rdbuf();
    return content.str();
}

std::string renderCargoToml(const RustEmitOptions& options)
{
    const auto rustProfileName = [&options]() -> const char* {
        return options.profile == RustProfile::Std ? "std" : "no-std-alloc";
    };
    const auto rustRuntimeSpecializationName = [&options]() -> const char* {
        return options.runtimeSpecialization == RustRuntimeSpecialization::Fast ? "fast" : "portable";
    };
    const auto rustMemoryModeName = [&options]() -> const char* {
        return options.memoryMode == RustMemoryMode::InlineThenPool ? "inline-then-pool" : "max-inline";
    };

    std::ostringstream out;
    out << "[package]\n";
    out << "name = \"" << options.crateName << "\"\n";
    out << "version = \"" << llvmdsdl::kVersionString << "\"\n";
    out << "edition = \"2021\"\n\n";
    out << "[package.metadata.llvmdsdl]\n";
    out << "generator-version = \"" << llvmdsdl::kVersionString << "\"\n";
    out << "rust-profile = \"" << rustProfileName() << "\"\n";
    out << "rust-runtime-specialization = \"" << rustRuntimeSpecializationName() << "\"\n";
    out << "rust-memory-mode = \"" << rustMemoryModeName() << "\"\n";
    out << "rust-inline-threshold-bytes = " << options.inlineThresholdBytes << "\n\n";

    out << "[lib]\n";
    out << "path = \"src/lib.rs\"\n\n";

    out << "[features]\n";
    std::vector<std::string> defaultFeatures;
    if (options.profile == RustProfile::Std)
    {
        defaultFeatures.emplace_back("std");
    }
    if (options.runtimeSpecialization == RustRuntimeSpecialization::Fast)
    {
        defaultFeatures.emplace_back("runtime-fast");
    }
    out << "default = [";
    for (std::size_t i = 0; i < defaultFeatures.size(); ++i)
    {
        if (i != 0)
        {
            out << ", ";
        }
        out << "\"" << defaultFeatures[i] << "\"";
    }
    out << "]\n";
    out << "std = []\n";
    out << "runtime-fast = []\n";
    return out.str();
}

}  // namespace

llvm::Error emitRust(const SemanticModule&  semantic,
                     mlir::ModuleOp         module,
                     const RustEmitOptions& options,
                     DiagnosticEngine&      diagnostics)
{
    if (options.outDir.empty())
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "output directory is required");
    }
    const auto mlirCoverageDiagnostic = codegen_diagnostic_text::mlirSchemaCoverageValidationFailedForEmission("Rust");
    LoweredFactsMap loweredFacts;
    if (!collectLoweredFactsFromMlir(semantic,
                                     module,
                                     diagnostics,
                                     "Rust",
                                     &loweredFacts,
                                     options.optimizeLoweredSerDes))
    {
        return llvm::createStringError(llvm::inconvertibleErrorCode(), "%s", mlirCoverageDiagnostic.c_str());
    }
    std::filesystem::path outRoot(options.outDir);
    std::filesystem::path srcRoot          = outRoot / "src";
    const auto            selectedTypeKeys = makeTypeKeySet(options.selectedTypeKeys);

    if (options.emitCargoToml)
    {
        if (auto err = writeGeneratedFile(outRoot / "Cargo.toml", renderCargoToml(options), options.writePolicy))
        {
            return err;
        }
    }

    auto runtime = loadRustRuntimeFile("dsdl_runtime.rs");
    if (!runtime)
    {
        return runtime.takeError();
    }
    if (auto err = writeGeneratedFile(srcRoot / "dsdl_runtime.rs",
                                      generatedCommentLine("Rust runtime scaffold") + "\n\n" + *runtime,
                                      options.writePolicy))
    {
        return err;
    }

    auto semanticWrappers = loadRustRuntimeFile("dsdl_runtime_semantic_wrappers.rs");
    if (!semanticWrappers)
    {
        return semanticWrappers.takeError();
    }
    if (auto err =
            writeGeneratedFile(srcRoot / "dsdl_runtime_semantic_wrappers.rs",
                               generatedCommentLine("Rust runtime semantic wrappers") + "\n\n" + *semanticWrappers,
                               options.writePolicy))
    {
        return err;
    }

    EmitterContext ctx(semantic);

    std::map<std::string, std::set<std::string>> dirToSubdirs;
    std::map<std::string, std::set<std::string>> dirToFiles;

    for (const auto& def : semantic.definitions)
    {
        if (!shouldEmitDefinition(def.info, selectedTypeKeys))
        {
            continue;
        }
        const std::vector<std::string> requiredTypeKeys{definitionTypeKey(def.info)};

        std::vector<std::string> ns;
        ns.reserve(def.info.namespaceComponents.size());
        for (const auto& c : def.info.namespaceComponents)
        {
            ns.push_back(codegenSanitizeIdentifier(CodegenNamingLanguage::Rust, c));
        }

        std::string dirRel;
        std::string parentRel;
        for (const auto& component : ns)
        {
            dirToSubdirs[parentRel].insert(component);
            if (!dirRel.empty())
            {
                dirRel += "/";
            }
            dirRel += component;
            parentRel = dirRel;
        }

        const auto modName = ctx.rustModuleName(def.info);
        dirToFiles[dirRel].insert(modName);

        std::filesystem::path dir = srcRoot;
        if (!dirRel.empty())
        {
            dir /= dirRel;
        }
        if (auto err = writeGeneratedFile(dir / (modName + ".rs"),
                                          renderDefinitionFile(def, ctx, loweredFacts, options),
                                          options.writePolicy,
                                          requiredTypeKeys))
        {
            return err;
        }
    }

    std::ostringstream lib;
    emitLine(lib, 0, generatedCommentLine("Rust backend crate root"));
    emitLine(lib, 0, "#![cfg_attr(not(feature = \"std\"), no_std)]");
    emitLine(lib, 0, "#![allow(non_camel_case_types)]");
    emitLine(lib, 0, "#![allow(non_snake_case)]");
    emitLine(lib, 0, "#![allow(non_upper_case_globals)]");
    emitLine(lib, 0, "#[cfg(not(feature = \"std\"))]");
    emitLine(lib, 0, "extern crate alloc;");
    emitLine(lib, 0, "pub mod dsdl_runtime;");

    if (dirToSubdirs.contains(""))
    {
        for (const auto& sub : dirToSubdirs[""])
        {
            emitLine(lib, 0, "pub mod " + sub + ";");
        }
    }
    if (dirToFiles.contains(""))
    {
        for (const auto& file : dirToFiles[""])
        {
            emitLine(lib, 0, "pub mod " + file + ";");
        }
    }

    if (auto err = writeGeneratedFile(srcRoot / "lib.rs", lib.str(), options.writePolicy, options.selectedTypeKeys))
    {
        return err;
    }

    std::set<std::string> dirs;
    for (const auto& [d, _] : dirToSubdirs)
    {
        if (!d.empty())
        {
            dirs.insert(d);
        }
    }
    for (const auto& [d, _] : dirToFiles)
    {
        if (!d.empty())
        {
            dirs.insert(d);
        }
    }

    for (const auto& dirRel : dirs)
    {
        std::ostringstream mod;
        emitLine(mod, 0, generatedCommentLine("Rust backend module index"));
        if (dirToSubdirs.contains(dirRel))
        {
            for (const auto& sub : dirToSubdirs[dirRel])
            {
                emitLine(mod, 0, "pub mod " + sub + ";");
            }
        }
        if (dirToFiles.contains(dirRel))
        {
            for (const auto& file : dirToFiles[dirRel])
            {
                emitLine(mod, 0, "pub mod " + file + ";");
            }
        }

        std::filesystem::path dir = srcRoot / dirRel;
        if (auto err = writeGeneratedFile(dir / "mod.rs", mod.str(), options.writePolicy, options.selectedTypeKeys))
        {
            return err;
        }
    }

    return llvm::Error::success();
}

}  // namespace llvmdsdl
