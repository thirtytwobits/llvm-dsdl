//===----------------------------------------------------------------------===//
//
// Part of the OpenCyphal project, under the MIT licence
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
///
/// @file
/// Auto-generated embedded UAVCAN MLIR catalog.
///
/// Generated by: tools/dsdlc/generate_embedded_uavcan_mlir.py
/// Source: submodules/public_regulated_data_types/uavcan
///
/// DO NOT EDIT MANUALLY.
//===----------------------------------------------------------------------===//

namespace llvmdsdl::uavcan_embedded_mlir
{
inline constexpr std::size_t kEmbeddedUavcanSchemaCount = 0U;
inline constexpr const char  kEmbeddedUavcanMlirSha256[] =
    "1dd2130edce6f47c77f348eb9cb54d6a61321778fd17a21dadc24e61cc8b457d";
inline constexpr const char kEmbeddedUavcanMlirText[] = R"LLVMDSDL_UAVCAN(
module {
  dsdl.schema @uavcan_diagnostic_Record_1_1 attributes {c_type_name = "uavcan__diagnostic__Record", doc = "Generic human-readable text message for logging and displaying purposes.\0AGenerally, it should be published at the lowest priority level.", extent_bits = 2400 : i64, fixed_port_id = 8184 : i64, full_name = "uavcan.diagnostic.Record", header_path = "uavcan/diagnostic/Record_1_1.h", major = 1 : i32, minor = 1 : i32} {
    dsdl.field {c_name = "timestamp", doc = "Optional timestamp in the network-synchronized time system; zero if undefined.\0AThe timestamp value conveys the exact moment when the reported event took place.", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "severity", doc = "\0A", name = "severity", type_name = "Severity.1.0"}
    dsdl.field {c_name = "text", doc = "Message text.\0ANormally, messages should be kept as short as possible, especially those of high severity.", name = "text", type_name = "saturated uint8[<256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__diagnostic__Record__deserialize_", c_serialize_symbol = "uavcan__diagnostic__Record__serialize_", c_type_name = "uavcan__diagnostic__Record", extent_bits = 2400 : i64, max_bits = 2112 : i64, min_bits = 72 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Optional timestamp in the network-synchronized time system; zero if undefined.\0AThe timestamp value conveys the exact moment when the reported event took place.", kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "severity", cast_mode = "saturated", composite_c_type_name = "uavcan__diagnostic__Severity", composite_extent_bits = 8 : i64, composite_full_name = "uavcan.diagnostic.Severity", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0A", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "severity", scalar_category = "composite", type_name = "Severity.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_exclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "text", cast_mode = "saturated", doc = "Message text.\0ANormally, messages should be kept as short as possible, especially those of high severity.", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "text", scalar_category = "unsigned", type_name = "saturated uint8[<256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_diagnostic_Record_1_0 attributes {c_type_name = "uavcan__diagnostic__Record", deprecated, doc = "Generic human-readable text message for logging and displaying purposes.\0AGenerally, it should be published at the lowest priority level.", extent_bits = 2400 : i64, fixed_port_id = 8184 : i64, full_name = "uavcan.diagnostic.Record", header_path = "uavcan/diagnostic/Record_1_0.h", major = 1 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "timestamp", doc = "Optional timestamp in the network-synchronized time system; zero if undefined.\0AThe timestamp value conveys the exact moment when the reported event took place.", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "severity", doc = "\0A", name = "severity", type_name = "Severity.1.0"}
    dsdl.field {c_name = "text", doc = "Message text.\0ANormally, messages should be kept as short as possible, especially those of high severity.", name = "text", type_name = "saturated uint8[<=112]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__diagnostic__Record__deserialize_", c_serialize_symbol = "uavcan__diagnostic__Record__serialize_", c_type_name = "uavcan__diagnostic__Record", extent_bits = 2400 : i64, max_bits = 968 : i64, min_bits = 72 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Optional timestamp in the network-synchronized time system; zero if undefined.\0AThe timestamp value conveys the exact moment when the reported event took place.", kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "severity", cast_mode = "saturated", composite_c_type_name = "uavcan__diagnostic__Severity", composite_extent_bits = 8 : i64, composite_full_name = "uavcan.diagnostic.Severity", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0A", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "severity", scalar_category = "composite", type_name = "Severity.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 112 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "text", cast_mode = "saturated", doc = "Message text.\0ANormally, messages should be kept as short as possible, especially those of high severity.", kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "text", scalar_category = "unsigned", type_name = "saturated uint8[<=112]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_diagnostic_Severity_1_0 attributes {c_type_name = "uavcan__diagnostic__Severity", doc = "Generic message severity representation.", extent_bits = 8 : i64, full_name = "uavcan.diagnostic.Severity", header_path = "uavcan/diagnostic/Severity_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", doc = "The severity level ranging from 0 to 7, where low values represent low-severity (unimportant) messages, and\0Ahigh values represent high-severity (important) messages. Several mnemonics for the severity levels are\0Adefined below. Nodes are advised to implement output filtering mechanisms, allowing users to select\0Athe minimal severity for emitted messages; messages of the selected and higher severity levels will\0Abe published, and messages of lower severity will be suppressed (discarded).", name = "value", type_name = "saturated uint3"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0AMessages of this severity can be used only during development.\0AThey shall not be used in a fielded operational system.", name = "TRACE", type_name = "saturated uint3", value_text = "0"}
    dsdl.constant {doc = "\0A\0AMessages that can aid in troubleshooting.\0AMessages of this severity and lower should be disabled by default.", name = "DEBUG", type_name = "saturated uint3", value_text = "1"}
    dsdl.constant {doc = "\0A\0AGeneral informational messages of low importance.\0AMessages of this severity and lower should be disabled by default.", name = "INFO", type_name = "saturated uint3", value_text = "2"}
    dsdl.constant {doc = "\0A\0AGeneral informational messages of high importance.\0AMessages of this severity and lower should be disabled by default.", name = "NOTICE", type_name = "saturated uint3", value_text = "3"}
    dsdl.constant {doc = "\0A\0AMessages reporting abnormalities and warning conditions.\0AMessages of this severity and higher should be enabled by default.", name = "WARNING", type_name = "saturated uint3", value_text = "4"}
    dsdl.constant {doc = "\0A\0AMessages reporting problems and error conditions.\0AMessages of this severity and higher should be enabled by default.", name = "ERROR", type_name = "saturated uint3", value_text = "5"}
    dsdl.constant {doc = "\0A\0AMessages reporting serious problems and critical conditions.\0AMessages of this severity and higher should be always enabled.", name = "CRITICAL", type_name = "saturated uint3", value_text = "6"}
    dsdl.constant {doc = "\0A\0ANotifications of dangerous circumstances that demand immediate attention.\0AMessages of this severity should be always enabled.", name = "ALERT", type_name = "saturated uint3", value_text = "7"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__diagnostic__Severity__deserialize_", c_serialize_symbol = "uavcan__diagnostic__Severity__serialize_", c_type_name = "uavcan__diagnostic__Severity", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 3 : i64, c_name = "value", cast_mode = "saturated", doc = "The severity level ranging from 0 to 7, where low values represent low-severity (unimportant) messages, and\0Ahigh values represent high-severity (important) messages. Several mnemonics for the severity levels are\0Adefined below. Nodes are advised to implement output filtering mechanisms, allowing users to select\0Athe minimal severity for emitted messages; messages of the selected and higher severity levels will\0Abe published, and messages of lower severity will be suppressed (discarded).", kind = "field", max_bits = 3 : i64, min_bits = 3 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint3", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Error_1_0 attributes {c_type_name = "uavcan__file__Error", doc = "Nested type.\0AResult of a file system operation.", extent_bits = 16 : i64, full_name = "uavcan.file.Error", header_path = "uavcan/file/Error_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint16"}
    dsdl.constant {name = "OK", type_name = "saturated uint16", value_text = "0"}
    dsdl.constant {name = "UNKNOWN_ERROR", type_name = "saturated uint16", value_text = "65535"}
    dsdl.constant {name = "NOT_FOUND", type_name = "saturated uint16", value_text = "2"}
    dsdl.constant {name = "IO_ERROR", type_name = "saturated uint16", value_text = "5"}
    dsdl.constant {name = "ACCESS_DENIED", type_name = "saturated uint16", value_text = "13"}
    dsdl.constant {doc = "I.e., attempted read/write on a path that points to a directory", name = "IS_DIRECTORY", type_name = "saturated uint16", value_text = "21"}
    dsdl.constant {doc = "E.g., file name is not valid for the target file system", name = "INVALID_VALUE", type_name = "saturated uint16", value_text = "22"}
    dsdl.constant {name = "FILE_TOO_LARGE", type_name = "saturated uint16", value_text = "27"}
    dsdl.constant {name = "OUT_OF_SPACE", type_name = "saturated uint16", value_text = "28"}
    dsdl.constant {name = "NOT_SUPPORTED", type_name = "saturated uint16", value_text = "38"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Error__deserialize_", c_serialize_symbol = "uavcan__file__Error__serialize_", c_type_name = "uavcan__file__Error", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_GetInfo_0_2 attributes {c_type_name = "uavcan__file__GetInfo", doc = "Information about a remote file system entry (file, directory, etc).", extent_bits = 2400 : i64, fixed_port_id = 405 : i64, full_name = "uavcan.file.GetInfo", header_path = "uavcan/file/GetInfo_0_2.h", major = 0 : i32, minor = 2 : i32, service} {
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.2.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__GetInfo__Request__deserialize_", c_serialize_symbol = "uavcan__file__GetInfo__Request__serialize_", c_type_name = "uavcan__file__GetInfo__Request", extent_bits = 2400 : i64, max_bits = 2048 : i64, min_bits = 8 : i64, section = "request"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", doc = "Result of the operation.", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.field {c_name = "size", doc = "\0AFile size in bytes. Should be set to zero for directories.", name = "size", section = "response", type_name = "truncated uint40"}
    dsdl.field {c_name = "unix_timestamp_of_last_modification", doc = "\0AThe UNIX Epoch time when the entry was last modified. Zero if unknown.", name = "unix_timestamp_of_last_modification", section = "response", type_name = "truncated uint40"}
    dsdl.field {c_name = "is_file_not_directory", doc = "\0ATrue if file, false if directory.", name = "is_file_not_directory", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_link", doc = "This is a link to another entry; the above flag indicates the type of the target.", name = "is_link", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_readable", doc = "The item can be read by the caller (applies to files and directories).", name = "is_readable", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_writeable", doc = "The item can be written by the caller (applies to files and directories).", name = "is_writeable", section = "response", type_name = "bool"}
    dsdl.field {c_name = "_", doc = "If such entry does not exist, all flags should be cleared/ignored.", name = "", padding, section = "response", type_name = "void4"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__GetInfo__Response__deserialize_", c_serialize_symbol = "uavcan__file__GetInfo__Response__serialize_", c_type_name = "uavcan__file__GetInfo__Response", extent_bits = 384 : i64, fixed_size, max_bits = 104 : i64, min_bits = 104 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Result of the operation.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "size", cast_mode = "truncated", doc = "\0AFile size in bytes. Should be set to zero for directories.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "size", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "unix_timestamp_of_last_modification", cast_mode = "truncated", doc = "\0AThe UNIX Epoch time when the entry was last modified. Zero if unknown.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "unix_timestamp_of_last_modification", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_file_not_directory", cast_mode = "saturated", doc = "\0ATrue if file, false if directory.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_file_not_directory", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_link", cast_mode = "saturated", doc = "This is a link to another entry; the above flag indicates the type of the target.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_link", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_readable", cast_mode = "saturated", doc = "The item can be read by the caller (applies to files and directories).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_readable", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_writeable", cast_mode = "saturated", doc = "The item can be written by the caller (applies to files and directories).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_writeable", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 4 : i64, c_name = "_", cast_mode = "saturated", doc = "If such entry does not exist, all flags should be cleared/ignored.", kind = "padding", max_bits = 4 : i64, min_bits = 4 : i64, name = "", scalar_category = "void", type_name = "void4", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_GetInfo_0_1 attributes {c_type_name = "uavcan__file__GetInfo", deprecated, doc = "Information about a remote file system entry (file, directory, etc).", extent_bits = 2400 : i64, fixed_port_id = 405 : i64, full_name = "uavcan.file.GetInfo", header_path = "uavcan/file/GetInfo_0_1.h", major = 0 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__GetInfo__Request__deserialize_", c_serialize_symbol = "uavcan__file__GetInfo__Request__serialize_", c_type_name = "uavcan__file__GetInfo__Request", extent_bits = 2400 : i64, max_bits = 904 : i64, min_bits = 8 : i64, section = "request"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", doc = "Result of the operation.", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.field {c_name = "size", doc = "\0AFile size in bytes. Should be set to zero for directories.", name = "size", section = "response", type_name = "truncated uint40"}
    dsdl.field {c_name = "unix_timestamp_of_last_modification", doc = "\0AThe UNIX Epoch time when the entry was last modified. Zero if unknown.", name = "unix_timestamp_of_last_modification", section = "response", type_name = "truncated uint40"}
    dsdl.field {c_name = "is_file_not_directory", doc = "\0ATrue if file, false if directory.", name = "is_file_not_directory", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_link", doc = "This is a link to another entry; the above flag indicates the type of the target.", name = "is_link", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_readable", doc = "The item can be read by the caller (applies to files and directories).", name = "is_readable", section = "response", type_name = "bool"}
    dsdl.field {c_name = "is_writeable", doc = "The item can be written by the caller (applies to files and directories).", name = "is_writeable", section = "response", type_name = "bool"}
    dsdl.field {c_name = "_", doc = "If such entry does not exist, all flags should be cleared/ignored.", name = "", padding, section = "response", type_name = "void4"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__GetInfo__Response__deserialize_", c_serialize_symbol = "uavcan__file__GetInfo__Response__serialize_", c_type_name = "uavcan__file__GetInfo__Response", extent_bits = 384 : i64, fixed_size, max_bits = 104 : i64, min_bits = 104 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Result of the operation.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "size", cast_mode = "truncated", doc = "\0AFile size in bytes. Should be set to zero for directories.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "size", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "unix_timestamp_of_last_modification", cast_mode = "truncated", doc = "\0AThe UNIX Epoch time when the entry was last modified. Zero if unknown.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "unix_timestamp_of_last_modification", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_file_not_directory", cast_mode = "saturated", doc = "\0ATrue if file, false if directory.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_file_not_directory", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_link", cast_mode = "saturated", doc = "This is a link to another entry; the above flag indicates the type of the target.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_link", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_readable", cast_mode = "saturated", doc = "The item can be read by the caller (applies to files and directories).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_readable", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "is_writeable", cast_mode = "saturated", doc = "The item can be written by the caller (applies to files and directories).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "is_writeable", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 4 : i64, c_name = "_", cast_mode = "saturated", doc = "If such entry does not exist, all flags should be cleared/ignored.", kind = "padding", max_bits = 4 : i64, min_bits = 4 : i64, name = "", scalar_category = "void", type_name = "void4", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_List_0_2 attributes {c_type_name = "uavcan__file__List", doc = "This service can be used to list a remote directory, one entry per request.\0A\0AThe client should query each entry independently, iterating 'entry_index' from 0 until the last entry.\0AWhen the index reaches the number of elements in the directory, the server will report that there is\0Ano such entry by returning an empty name.\0A\0AThe field entry_index shall be applied to an ordered list of directory entries (e.g. alphabetically ordered).\0AThe exact sorting criteria does not matter as long as it provides the same ordering for subsequent service calls.\0A\0AObserve that this listing operation is fundamentally non-atomic. The caller shall beware of possible race conditions\0Aand is responsible for handling them properly. Particularly, consider what happens if a new item is inserted into\0Athe directory between two subsequent calls: if the item happened to be inserted at the index that is lower than the\0Aindex of the next request, the next returned item (or several, if more items were inserted) will repeat the ones\0Athat were listed earlier. The caller should handle that properly, either by ignoring the repeated items or by\0Arestarting the listing operation from the beginning (index 0).", extent_bits = 2400 : i64, fixed_port_id = 406 : i64, full_name = "uavcan.file.List", header_path = "uavcan/file/List_0_2.h", major = 0 : i32, minor = 2 : i32, service} {
    dsdl.field {c_name = "entry_index", name = "entry_index", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "_", doc = "Reserved for future use.", name = "", padding, section = "request", type_name = "void32"}
    dsdl.field {c_name = "directory_path", name = "directory_path", section = "request", type_name = "Path.2.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__List__Request__deserialize_", c_serialize_symbol = "uavcan__file__List__Request__serialize_", c_type_name = "uavcan__file__List__Request", extent_bits = 2400 : i64, max_bits = 2112 : i64, min_bits = 72 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "entry_index", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "entry_index", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "_", cast_mode = "saturated", doc = "Reserved for future use.", kind = "padding", max_bits = 32 : i64, min_bits = 32 : i64, name = "", scalar_category = "void", type_name = "void32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "directory_path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "directory_path", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "_", doc = "Reserved for future use.", name = "", padding, section = "response", type_name = "void32"}
    dsdl.field {c_name = "entry_base_name", doc = "The base name of the referenced entry, i.e., relative to the outer directory.\0AThe outer directory path is not included to conserve bandwidth.\0AEmpty if such entry does not exist.\0A\0AFor example, suppose there is a file \22/foo/bar/baz.bin\22. Listing the directory with the path \22/foo/bar/\22 (the slash\0Aat the end is optional) at the index 0 will return \22baz.bin\22. Listing the same directory at the index 1 (or any\0Ahigher) will return an empty name \22\22, indicating that the caller has reached the end of the list.", name = "entry_base_name", section = "response", type_name = "Path.2.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__List__Response__deserialize_", c_serialize_symbol = "uavcan__file__List__Response__serialize_", c_type_name = "uavcan__file__List__Response", extent_bits = 2400 : i64, max_bits = 2080 : i64, min_bits = 40 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "_", cast_mode = "saturated", doc = "Reserved for future use.", kind = "padding", max_bits = 32 : i64, min_bits = 32 : i64, name = "", scalar_category = "void", type_name = "void32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "entry_base_name", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The base name of the referenced entry, i.e., relative to the outer directory.\0AThe outer directory path is not included to conserve bandwidth.\0AEmpty if such entry does not exist.\0A\0AFor example, suppose there is a file \22/foo/bar/baz.bin\22. Listing the directory with the path \22/foo/bar/\22 (the slash\0Aat the end is optional) at the index 0 will return \22baz.bin\22. Listing the same directory at the index 1 (or any\0Ahigher) will return an empty name \22\22, indicating that the caller has reached the end of the list.", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "entry_base_name", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_List_0_1 attributes {c_type_name = "uavcan__file__List", deprecated, doc = "This service can be used to list a remote directory, one entry per request.\0A\0AThe client should query each entry independently, iterating 'entry_index' from 0 until the last entry.\0AWhen the index reaches the number of elements in the directory, the server will report that there is\0Ano such entry by returning an empty name.\0A\0AThe field entry_index shall be applied to an ordered list of directory entries (e.g. alphabetically ordered).\0AThe exact sorting criteria does not matter as long as it provides the same ordering for subsequent service calls.\0A\0AObserve that this listing operation is fundamentally non-atomic. The caller shall beware of possible race conditions\0Aand is responsible for handling them properly. Particularly, consider what happens if a new item is inserted into\0Athe directory between two subsequent calls: if the item happened to be inserted at the index that is lower than the\0Aindex of the next request, the next returned item (or several, if more items were inserted) will repeat the ones\0Athat were listed earlier. The caller should handle that properly, either by ignoring the repeated items or by\0Arestarting the listing operation from the beginning (index 0).", extent_bits = 2400 : i64, fixed_port_id = 406 : i64, full_name = "uavcan.file.List", header_path = "uavcan/file/List_0_1.h", major = 0 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "entry_index", name = "entry_index", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "_", doc = "Reserved for future use.", name = "", padding, section = "request", type_name = "void32"}
    dsdl.field {c_name = "directory_path", name = "directory_path", section = "request", type_name = "Path.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__List__Request__deserialize_", c_serialize_symbol = "uavcan__file__List__Request__serialize_", c_type_name = "uavcan__file__List__Request", extent_bits = 2400 : i64, max_bits = 968 : i64, min_bits = 72 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "entry_index", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "entry_index", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "_", cast_mode = "saturated", doc = "Reserved for future use.", kind = "padding", max_bits = 32 : i64, min_bits = 32 : i64, name = "", scalar_category = "void", type_name = "void32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "directory_path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "directory_path", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "_", doc = "Reserved for future use.", name = "", padding, section = "response", type_name = "void32"}
    dsdl.field {c_name = "entry_base_name", doc = "The base name of the referenced entry, i.e., relative to the outer directory.\0AThe outer directory path is not included to conserve bandwidth.\0AEmpty if such entry does not exist.\0A\0AFor example, suppose there is a file \22/foo/bar/baz.bin\22. Listing the directory with the path \22/foo/bar/\22 (the slash\0Aat the end is optional) at the index 0 will return \22baz.bin\22. Listing the same directory at the index 1 (or any\0Ahigher) will return an empty name \22\22, indicating that the caller has reached the end of the list.", name = "entry_base_name", section = "response", type_name = "Path.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__List__Response__deserialize_", c_serialize_symbol = "uavcan__file__List__Response__serialize_", c_type_name = "uavcan__file__List__Response", extent_bits = 2400 : i64, max_bits = 936 : i64, min_bits = 40 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "_", cast_mode = "saturated", doc = "Reserved for future use.", kind = "padding", max_bits = 32 : i64, min_bits = 32 : i64, name = "", scalar_category = "void", type_name = "void32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "entry_base_name", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The base name of the referenced entry, i.e., relative to the outer directory.\0AThe outer directory path is not included to conserve bandwidth.\0AEmpty if such entry does not exist.\0A\0AFor example, suppose there is a file \22/foo/bar/baz.bin\22. Listing the directory with the path \22/foo/bar/\22 (the slash\0Aat the end is optional) at the index 0 will return \22baz.bin\22. Listing the same directory at the index 1 (or any\0Ahigher) will return an empty name \22\22, indicating that the caller has reached the end of the list.", kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "entry_base_name", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Modify_1_1 attributes {c_type_name = "uavcan__file__Modify", doc = "Manipulate a remote file system entry. Applies to files, directories, and links alike.\0AIf the remote entry is a directory, all nested entries will be affected, too.\0A\0AThe server should perform all operations atomically, unless atomicity is not supported by\0Athe underlying file system.\0A\0AAtomic copying can be effectively employed by remote nodes before reading or after writing\0Athe file to minimize the possibility of race conditions.\0AFor example, before reading a large file from the server, the cilent might opt to create\0Aa temporary copy of it first, then read the copy, and delete it upon completion. Likewise,\0Aa similar strategy can be employed for writing, where the file is first written at a\0Atemporary location, and then moved to its final destination. These approaches, however,\0Amay lead to creation of dangling temporary files if the client failed to dispose of them\0Aproperly, so that risk should be taken into account.\0A\0AMove/Copy\0A  Specify the source path and the destination path.\0A  If the source does not exist, the operation will fail.\0A  Set the preserve_source flag to copy rather than move.\0A  If the destination exists and overwrite_destination is not set, the operation will fail.\0A  If the target path includes non-existent directories, they will be created (like \22mkdir -p\22).\0A\0ATouch\0A  Specify the destination path and make the source path empty.\0A  If the path exists (file/directory/link), its modification time will be updated.\0A  If the path does not exist, an empty file will be created.\0A  If the target path includes non-existent directories, they will be created (like \22mkdir -p\22).\0A  Flags are ignored.\0A\0ARemove\0A  Specify the source path (file/directory/link) and make the destination path empty.\0A  Fails if the path does not exist.\0A  Flags are ignored.", extent_bits = 4800 : i64, fixed_port_id = 407 : i64, full_name = "uavcan.file.Modify", header_path = "uavcan/file/Modify_1_1.h", major = 1 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "preserve_source", doc = "Do not remove the source. Used to copy instead of moving.", name = "preserve_source", section = "request", type_name = "bool"}
    dsdl.field {c_name = "overwrite_destination", doc = "If the destination exists, remove it beforehand.", name = "overwrite_destination", section = "request", type_name = "bool"}
    dsdl.field {c_name = "_", name = "", padding, section = "request", type_name = "void30"}
    dsdl.field {c_name = "source", name = "source", section = "request", type_name = "Path.2.0"}
    dsdl.field {c_name = "destination", name = "destination", section = "request", type_name = "Path.2.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Modify__Request__deserialize_", c_serialize_symbol = "uavcan__file__Modify__Request__serialize_", c_type_name = "uavcan__file__Modify__Request", extent_bits = 4800 : i64, max_bits = 4128 : i64, min_bits = 48 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "preserve_source", cast_mode = "saturated", doc = "Do not remove the source. Used to copy instead of moving.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "preserve_source", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "overwrite_destination", cast_mode = "saturated", doc = "If the destination exists, remove it beforehand.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "overwrite_destination", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 30 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 30 : i64, min_bits = 30 : i64, name = "", scalar_category = "void", type_name = "void30", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "source", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "source", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "destination", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "destination", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Modify__Response__deserialize_", c_serialize_symbol = "uavcan__file__Modify__Response__serialize_", c_type_name = "uavcan__file__Modify__Response", extent_bits = 384 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Modify_1_0 attributes {c_type_name = "uavcan__file__Modify", deprecated, doc = "Manipulate a remote file system entry. Applies to files, directories, and links alike.\0AIf the remote entry is a directory, all nested entries will be affected, too.\0A\0AThe server should perform all operations atomically, unless atomicity is not supported by\0Athe underlying file system.\0A\0AAtomic copying can be effectively employed by remote nodes before reading or after writing\0Athe file to minimize the possibility of race conditions.\0AFor example, before reading a large file from the server, the cilent might opt to create\0Aa temporary copy of it first, then read the copy, and delete it upon completion. Likewise,\0Aa similar strategy can be employed for writing, where the file is first written at a\0Atemporary location, and then moved to its final destination. These approaches, however,\0Amay lead to creation of dangling temporary files if the client failed to dispose of them\0Aproperly, so that risk should be taken into account.\0A\0AMove/Copy\0A  Specify the source path and the destination path.\0A  If the source does not exist, the operation will fail.\0A  Set the preserve_source flag to copy rather than move.\0A  If the destination exists and overwrite_destination is not set, the operation will fail.\0A  If the target path includes non-existent directories, they will be created (like \22mkdir -p\22).\0A\0ATouch\0A  Specify the destination path and make the source path empty.\0A  If the path exists (file/directory/link), its modification time will be updated.\0A  If the path does not exist, an empty file will be created.\0A  If the target path includes non-existent directories, they will be created (like \22mkdir -p\22).\0A  Flags are ignored.\0A\0ARemove\0A  Specify the source path (file/directory/link) and make the destination path empty.\0A  Fails if the path does not exist.\0A  Flags are ignored.", extent_bits = 4800 : i64, fixed_port_id = 407 : i64, full_name = "uavcan.file.Modify", header_path = "uavcan/file/Modify_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "preserve_source", doc = "Do not remove the source. Used to copy instead of moving.", name = "preserve_source", section = "request", type_name = "bool"}
    dsdl.field {c_name = "overwrite_destination", doc = "If the destination exists, remove it beforehand.", name = "overwrite_destination", section = "request", type_name = "bool"}
    dsdl.field {c_name = "_", name = "", padding, section = "request", type_name = "void30"}
    dsdl.field {c_name = "source", name = "source", section = "request", type_name = "Path.1.0"}
    dsdl.field {c_name = "destination", name = "destination", section = "request", type_name = "Path.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Modify__Request__deserialize_", c_serialize_symbol = "uavcan__file__Modify__Request__serialize_", c_type_name = "uavcan__file__Modify__Request", extent_bits = 4800 : i64, max_bits = 1840 : i64, min_bits = 48 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "preserve_source", cast_mode = "saturated", doc = "Do not remove the source. Used to copy instead of moving.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "preserve_source", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "overwrite_destination", cast_mode = "saturated", doc = "If the destination exists, remove it beforehand.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "overwrite_destination", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 30 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 30 : i64, min_bits = 30 : i64, name = "", scalar_category = "void", type_name = "void30", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "source", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "source", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "destination", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "destination", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Modify__Response__deserialize_", c_serialize_symbol = "uavcan__file__Modify__Response__serialize_", c_type_name = "uavcan__file__Modify__Response", extent_bits = 384 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Path_2_0 attributes {c_type_name = "uavcan__file__Path", doc = "Nested type.\0AA file system path encoded in UTF8. The only valid separator is the forward slash \22/\22.\0AA single slash (\22/\22) refers to the root directory (the location of which is defined by the server).\0ARelative references (e.g. \22..\22) are not defined and not permitted (although this may change in the future).\0AConventions (not enforced):\0A  - A path pointing to a file or a link to file should not end with a separator.\0A  - A path pointing to a directory or to a link to directory should end with a separator.", extent_bits = 2048 : i64, full_name = "uavcan.file.Path", header_path = "uavcan/file/Path_2_0.h", major = 2 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "path", name = "path", type_name = "saturated uint8[<=MAX_LENGTH]"}
    dsdl.constant {name = "SEPARATOR", type_name = "saturated uint8", value_text = "'/'"}
    dsdl.constant {name = "MAX_LENGTH", type_name = "saturated uint8", value_text = "255"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Path__deserialize_", c_serialize_symbol = "uavcan__file__Path__serialize_", c_type_name = "uavcan__file__Path", extent_bits = 2048 : i64, max_bits = 2048 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "path", cast_mode = "saturated", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "path", scalar_category = "unsigned", type_name = "saturated uint8[<=MAX_LENGTH]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Path_1_0 attributes {c_type_name = "uavcan__file__Path", deprecated, doc = "Nested type.\0AA file system path encoded in UTF8. The only valid separator is the forward slash \22/\22.\0AA single slash (\22/\22) refers to the root directory (the location of which is defined by the server).\0ARelative references (e.g. \22..\22) are not defined and not permitted (although this may change in the future).\0AConventions (not enforced):\0A  - A path pointing to a file or a link to file should not end with a separator.\0A  - A path pointing to a directory or to a link to directory should end with a separator.\0A\0AThe maximum path length limit is chosen as a trade-off between compatibility with deep directory structures and\0Athe worst-case transfer length. The limit is 112 bytes, which allows all transfers containing a single instance\0Aof path and no other large data chunks to fit into two CAN FD frames.", extent_bits = 904 : i64, full_name = "uavcan.file.Path", header_path = "uavcan/file/Path_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "path", name = "path", type_name = "saturated uint8[<=MAX_LENGTH]"}
    dsdl.constant {name = "SEPARATOR", type_name = "saturated uint8", value_text = "'/'"}
    dsdl.constant {name = "MAX_LENGTH", type_name = "saturated uint8", value_text = "112"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Path__deserialize_", c_serialize_symbol = "uavcan__file__Path__serialize_", c_type_name = "uavcan__file__Path", extent_bits = 904 : i64, max_bits = 904 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 112 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "path", cast_mode = "saturated", kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "path", scalar_category = "unsigned", type_name = "saturated uint8[<=MAX_LENGTH]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Read_1_1 attributes {c_type_name = "uavcan__file__Read", doc = "Read file from a remote node.\0A\0AThere are two possible outcomes of a successful call:\0A 1. Data array size equals its capacity. This means that the end of the file is not reached yet.\0A 2. Data array size is less than its capacity, possibly zero. This means that the end of the file is reached.\0A\0AThus, if the client needs to fetch the entire file, it should repeatedly call this service while increasing the\0Aoffset, until a non-full data array is returned.\0A\0AIf the object pointed by 'path' cannot be read (e.g. it is a directory or it does not exist), an appropriate error\0Acode will be returned, and the data array will be empty.\0A\0AIt is easy to see that this protocol is prone to race conditions because the remote file can be modified\0Abetween read operations which might result in the client obtaining a damaged file. To combat this,\0Aapplication designers are recommended to adhere to the following convention. Let every file whose integrity\0Ais of interest have a hash or a digital signature, which is stored in an adjacent file under the same name\0Asuffixed with the appropriate extension according to the type of hash or digital signature used.\0AFor example, let there be file \22image.bin\22, integrity of which shall be ensured by the client upon downloading.\0ASuppose that the file is hashed using SHA-256, so the appropriate file extension for the hash would be\0A\22.sha256\22. Following this convention, the hash of \22image.bin\22 would be stored in \22image.bin.sha256\22.\0AAfter downloading the file, the client would read the hash (being small, the hash can be read in a single\0Arequest) and check it against a locally computed value. Some servers may opt to generate such hash files\0Aautomatically as necessary; for example, if such file is requested but it does not exist, the server would\0Acompute the necessary signature or hash (the type of hash/signature can be deduced from the requested file\0Aextension) and return it as if the file existed. Obviously, this would be impractical for very large files;\0Ain that case, hash/signature should be pre-computed and stored in a real file. If this approach is followed,\0Aimplementers are advised to use only SHA-256 for hashing, in order to reduce the number of fielded\0Aincompatible implementations.", extent_bits = 2400 : i64, fixed_port_id = 408 : i64, full_name = "uavcan.file.Read", header_path = "uavcan/file/Read_1_1.h", major = 1 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "offset", name = "offset", section = "request", type_name = "truncated uint40"}
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.2.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Read__Request__deserialize_", c_serialize_symbol = "uavcan__file__Read__Request__serialize_", c_type_name = "uavcan__file__Read__Request", extent_bits = 2400 : i64, max_bits = 2088 : i64, min_bits = 48 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "offset", cast_mode = "truncated", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "offset", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.field {c_name = "data", name = "data", section = "response", type_name = "uavcan.primitive.Unstructured.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Read__Response__deserialize_", c_serialize_symbol = "uavcan__file__Read__Response__serialize_", c_type_name = "uavcan__file__Read__Response", extent_bits = 2400 : i64, max_bits = 2080 : i64, min_bits = 32 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Unstructured", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.Unstructured", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "data", scalar_category = "composite", type_name = "uavcan.primitive.Unstructured.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Read_1_0 attributes {c_type_name = "uavcan__file__Read", deprecated, doc = "Read file from a remote node.\0A\0AThere are two possible outcomes of a successful call:\0A 1. Data array size equals its capacity. This means that the end of the file is not reached yet.\0A 2. Data array size is less than its capacity, possibly zero. This means that the end of the file is reached.\0A\0AThus, if the client needs to fetch the entire file, it should repeatedly call this service while increasing the\0Aoffset, until a non-full data array is returned.\0A\0AIf the object pointed by 'path' cannot be read (e.g. it is a directory or it does not exist), an appropriate error\0Acode will be returned, and the data array will be empty.\0A\0AIt is easy to see that this protocol is prone to race conditions because the remote file can be modified\0Abetween read operations which might result in the client obtaining a damaged file. To combat this,\0Aapplication designers are recommended to adhere to the following convention. Let every file whose integrity\0Ais of interest have a hash or a digital signature, which is stored in an adjacent file under the same name\0Asuffixed with the appropriate extension according to the type of hash or digital signature used.\0AFor example, let there be file \22image.bin\22, integrity of which shall be ensured by the client upon downloading.\0ASuppose that the file is hashed using SHA-256, so the appropriate file extension for the hash would be\0A\22.sha256\22. Following this convention, the hash of \22image.bin\22 would be stored in \22image.bin.sha256\22.\0AAfter downloading the file, the client would read the hash (being small, the hash can be read in a single\0Arequest) and check it against a locally computed value. Some servers may opt to generate such hash files\0Aautomatically as necessary; for example, if such file is requested but it does not exist, the server would\0Acompute the necessary signature or hash (the type of hash/signature can be deduced from the requested file\0Aextension) and return it as if the file existed. Obviously, this would be impractical for very large files;\0Ain that case, hash/signature should be pre-computed and stored in a real file. If this approach is followed,\0Aimplementers are advised to use only SHA-256 for hashing, in order to reduce the number of fielded\0Aincompatible implementations.", extent_bits = 2400 : i64, fixed_port_id = 408 : i64, full_name = "uavcan.file.Read", header_path = "uavcan/file/Read_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "offset", name = "offset", section = "request", type_name = "truncated uint40"}
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Read__Request__deserialize_", c_serialize_symbol = "uavcan__file__Read__Request__serialize_", c_type_name = "uavcan__file__Read__Request", extent_bits = 2400 : i64, max_bits = 944 : i64, min_bits = 48 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "offset", cast_mode = "truncated", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "offset", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.field {c_name = "data", name = "data", section = "response", type_name = "saturated uint8[<=256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Read__Response__deserialize_", c_serialize_symbol = "uavcan__file__Read__Response__serialize_", c_type_name = "uavcan__file__Read__Response", extent_bits = 2400 : i64, max_bits = 2080 : i64, min_bits = 32 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Write_1_1 attributes {c_type_name = "uavcan__file__Write", doc = "Write into a remote file.\0AThe server shall place the contents of the field 'data' into the file pointed by 'path' at the offset specified by\0Athe field 'offset'.\0A\0AWhen writing a file, the client should repeatedly call this service with data while advancing the offset until the\0Afile is written completely. When the write sequence is completed, the client shall call the service one last time,\0Awith the offset set to the size of the file and with the data field empty, which will signal the server that the\0Atransfer is finished.\0A\0AWhen the write operation is complete, the server shall truncate the resulting file past the specified offset.", extent_bits = 4800 : i64, fixed_port_id = 409 : i64, full_name = "uavcan.file.Write", header_path = "uavcan/file/Write_1_1.h", major = 1 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "offset", name = "offset", section = "request", type_name = "truncated uint40"}
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.2.0"}
    dsdl.field {c_name = "data", name = "data", section = "request", type_name = "uavcan.primitive.Unstructured.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Write__Request__deserialize_", c_serialize_symbol = "uavcan__file__Write__Request__serialize_", c_type_name = "uavcan__file__Write__Request", extent_bits = 4800 : i64, max_bits = 4152 : i64, min_bits = 64 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "offset", cast_mode = "truncated", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "offset", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.file.Path", composite_major = 2 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.2.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Unstructured", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.Unstructured", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "data", scalar_category = "composite", type_name = "uavcan.primitive.Unstructured.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Write__Response__deserialize_", c_serialize_symbol = "uavcan__file__Write__Response__serialize_", c_type_name = "uavcan__file__Write__Response", extent_bits = 384 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_file_Write_1_0 attributes {c_type_name = "uavcan__file__Write", deprecated, doc = "Write into a remote file.\0AThe server shall place the contents of the field 'data' into the file pointed by 'path' at the offset specified by\0Athe field 'offset'.\0A\0AWhen writing a file, the client should repeatedly call this service with data while advancing the offset until the\0Afile is written completely. When the write sequence is completed, the client shall call the service one last time,\0Awith the offset set to the size of the file and with the data field empty, which will signal the server that the\0Atransfer is finished.\0A\0AWhen the write operation is complete, the server shall truncate the resulting file past the specified offset.", extent_bits = 4800 : i64, fixed_port_id = 409 : i64, full_name = "uavcan.file.Write", header_path = "uavcan/file/Write_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "offset", name = "offset", section = "request", type_name = "truncated uint40"}
    dsdl.field {c_name = "path", name = "path", section = "request", type_name = "Path.1.0"}
    dsdl.field {c_name = "data", doc = "192 = 128 + 64; the write protocol permits usage of smaller chunks.", name = "data", section = "request", type_name = "saturated uint8[<=192]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Write__Request__deserialize_", c_serialize_symbol = "uavcan__file__Write__Request__serialize_", c_type_name = "uavcan__file__Write__Request", extent_bits = 4800 : i64, max_bits = 2488 : i64, min_bits = 56 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "offset", cast_mode = "truncated", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "offset", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "path", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Path", composite_extent_bits = 904 : i64, composite_full_name = "uavcan.file.Path", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "path", scalar_category = "composite", type_name = "Path.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 192 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", doc = "192 = 128 + 64; the write protocol permits usage of smaller chunks.", kind = "field", max_bits = 1544 : i64, min_bits = 8 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=192]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "error", name = "error", section = "response", type_name = "Error.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__file__Write__Response__deserialize_", c_serialize_symbol = "uavcan__file__Write__Response__serialize_", c_type_name = "uavcan__file__Write__Response", extent_bits = 384 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__file__Error", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.file.Error", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "error", scalar_category = "composite", type_name = "Error.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_internet_udp_HandleIncomingPacket_0_2 attributes {c_type_name = "uavcan__internet__udp__HandleIncomingPacket", doc = "This message carries UDP packets sent from a remote host on the Internet or a LAN to a node on the local Cyphal bus.\0APlease refer to the definition of the message type OutgoingPacket for a general overview of the packet forwarding\0Alogic.\0A\0AThis data type has been made a service type rather than a message type in order to make its transfers addressable,\0Aallowing nodes to employ hardware acceptance filters for filtering out forwarded datagrams that are not addressed\0Ato them. Additionally, requiring the destination nodes to always respond upon reception of the forwarded datagram\0Aopens interesting opportunities for future extensions of the forwarding protocol. If the service invocation times\0Aout, the modem node is permitted to remove the corresponding entry from the NAT table immediately, not waiting\0Afor its TTL to expire.\0A\0AIt should be noted that this data type definition intentionally leaves out the source address. This is done in\0Aorder to simplify the implementation, reduce the bus traffic overhead, and because the nature of the\0Acommunication patterns proposed by this set of messages does not provide a valid way to implement server hosts\0Aon the local Cyphal bus. It is assumed that local nodes can be only clients, and therefore, they will be able to\0Adetermine the address of the sender simply by mapping the field session_id to their internally maintained states.\0AFurthermore, it is uncertain what is the optimal way of representing the source address for\0Aclient nodes: it is assumed that the local nodes will mostly use DNS names rather than IP addresses, so if there\0Awas a source address field, modem nodes would have to perform reverse mapping from the IP address they received\0Athe datagram from to the corresponding DNS name that was used by the local node with the outgoing message. This\0Aapproach creates a number of troubling corner cases and adds a fair amount of hidden complexities to the\0Aimplementation of modem nodes.\0A\0AIt is recommended to perform service invocations at the same transfer priority level as was used for broadcasting\0Athe latest matching message of type OutgoingPacket. However, meeting this recommendation would require the modem\0Anode to implement additional logic, which may be undesirable. Therefore, implementers are free to deviate from\0Athis recommendation and resort to a fixed priority level instead. In the case of a fixed priority level, it is\0Aadvised to use the lowest transfer priority level.", extent_bits = 4800 : i64, fixed_port_id = 500 : i64, full_name = "uavcan.internet.udp.HandleIncomingPacket", header_path = "uavcan/internet/udp/HandleIncomingPacket_0_2.h", major = 0 : i32, minor = 2 : i32, service} {
    dsdl.field {c_name = "session_id", doc = "This field shall contain the same value that was used by the local node when sending the corresponding outgoing\0Apacket using the message type OutgoingPacket. This value will be used by the local node to match the response\0Awith its local context.", name = "session_id", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "payload", doc = "\0A\0A\0AEffective payload. This data will be forwarded from the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ADatagrams that exceed the capacity of this field should be discarded by the modem node.", name = "payload", section = "request", type_name = "saturated uint8[<=508]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Request__deserialize_", c_serialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Request__serialize_", c_type_name = "uavcan__internet__udp__HandleIncomingPacket__Request", extent_bits = 4800 : i64, max_bits = 4096 : i64, min_bits = 32 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "session_id", cast_mode = "saturated", doc = "This field shall contain the same value that was used by the local node when sending the corresponding outgoing\0Apacket using the message type OutgoingPacket. This value will be used by the local node to match the response\0Awith its local context.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "session_id", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 508 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "payload", cast_mode = "saturated", doc = "\0A\0A\0AEffective payload. This data will be forwarded from the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ADatagrams that exceed the capacity of this field should be discarded by the modem node.", kind = "field", max_bits = 4080 : i64, min_bits = 16 : i64, name = "payload", scalar_category = "unsigned", type_name = "saturated uint8[<=508]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Response__deserialize_", c_serialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Response__serialize_", c_type_name = "uavcan__internet__udp__HandleIncomingPacket__Response", extent_bits = 504 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
    }
  }
  dsdl.schema @uavcan_internet_udp_HandleIncomingPacket_0_1 attributes {c_type_name = "uavcan__internet__udp__HandleIncomingPacket", deprecated, doc = "This message carries UDP packets sent from a remote host on the Internet or a LAN to a node on the local Cyphal bus.\0APlease refer to the definition of the message type OutgoingPacket for a general overview of the packet forwarding\0Alogic.\0A\0AThis data type has been made a service type rather than a message type in order to make its transfers addressable,\0Aallowing nodes to employ hardware acceptance filters for filtering out forwarded datagrams that are not addressed\0Ato them. Additionally, requiring the destination nodes to always respond upon reception of the forwarded datagram\0Aopens interesting opportunities for future extensions of the forwarding protocol. If the service invocation times\0Aout, the modem node is permitted to remove the corresponding entry from the NAT table immediately, not waiting\0Afor its TTL to expire.\0A\0AIt should be noted that this data type definition intentionally leaves out the source address. This is done in\0Aorder to simplify the implementation, reduce the bus traffic overhead, and because the nature of the\0Acommunication patterns proposed by this set of messages does not provide a valid way to implement server hosts\0Aon the local Cyphal bus. It is assumed that local nodes can be only clients, and therefore, they will be able to\0Adetermine the address of the sender simply by mapping the field session_id to their internally maintained states.\0AFurthermore, it is uncertain what is the optimal way of representing the source address for\0Aclient nodes: it is assumed that the local nodes will mostly use DNS names rather than IP addresses, so if there\0Awas a source address field, modem nodes would have to perform reverse mapping from the IP address they received\0Athe datagram from to the corresponding DNS name that was used by the local node with the outgoing message. This\0Aapproach creates a number of troubling corner cases and adds a fair amount of hidden complexities to the\0Aimplementation of modem nodes.\0A\0AIt is recommended to perform service invocations at the same transfer priority level as was used for broadcasting\0Athe latest matching message of type OutgoingPacket. However, meeting this recommendation would require the modem\0Anode to implement additional logic, which may be undesirable. Therefore, implementers are free to deviate from\0Athis recommendation and resort to a fixed priority level instead. In the case of a fixed priority level, it is\0Aadvised to use the lowest transfer priority level.", extent_bits = 4800 : i64, fixed_port_id = 500 : i64, full_name = "uavcan.internet.udp.HandleIncomingPacket", header_path = "uavcan/internet/udp/HandleIncomingPacket_0_1.h", major = 0 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "session_id", doc = "This field shall contain the same value that was used by the local node when sending the corresponding outgoing\0Apacket using the message type OutgoingPacket. This value will be used by the local node to match the response\0Awith its local context.", name = "session_id", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "payload", doc = "\0A\0A\0AEffective payload. This data will be forwarded from the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ACyphal further limits the maximum packet size to reduce the memory and traffic burden on the nodes.\0ADatagrams that exceed the capacity of this field should be discarded by the modem node.", name = "payload", section = "request", type_name = "saturated uint8[<=309]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Request__deserialize_", c_serialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Request__serialize_", c_type_name = "uavcan__internet__udp__HandleIncomingPacket__Request", extent_bits = 4800 : i64, max_bits = 2504 : i64, min_bits = 32 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "session_id", cast_mode = "saturated", doc = "This field shall contain the same value that was used by the local node when sending the corresponding outgoing\0Apacket using the message type OutgoingPacket. This value will be used by the local node to match the response\0Awith its local context.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "session_id", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 309 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "payload", cast_mode = "saturated", doc = "\0A\0A\0AEffective payload. This data will be forwarded from the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ACyphal further limits the maximum packet size to reduce the memory and traffic burden on the nodes.\0ADatagrams that exceed the capacity of this field should be discarded by the modem node.", kind = "field", max_bits = 2488 : i64, min_bits = 16 : i64, name = "payload", scalar_category = "unsigned", type_name = "saturated uint8[<=309]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Response__deserialize_", c_serialize_symbol = "uavcan__internet__udp__HandleIncomingPacket__Response__serialize_", c_type_name = "uavcan__internet__udp__HandleIncomingPacket__Response", extent_bits = 504 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
    }
  }
  dsdl.schema @uavcan_internet_udp_OutgoingPacket_0_2 attributes {c_type_name = "uavcan__internet__udp__OutgoingPacket", doc = "This message carries UDP packets from a node on the local bus to a remote host on the Internet or a LAN.\0A\0AAny node can broadcast a message of this type.\0A\0AAll nodes that are capable of communication with the Internet or a LAN should subscribe to messages\0Aof this type and forward the payload to the indicated host and port using exactly one UDP datagram\0Aper message (i.e. additional fragmentation is to be avoided). Such nodes will be referred to as\0A\22modem nodes\22.\0A\0AIt is expected that some systems will have more than one modem node available.\0AEach modem node is supposed to forward every message it sees, which will naturally create\0Asome degree of modular redundancy and fault tolerance. The remote host should therefore be able to\0Aproperly handle possibly duplicated messages from different source addresses, in addition to\0Apossible duplications introduced by the UDP/IP protocol itself. There are at least two obvious\0Astrategies that can be employed by the remote host:\0A\0A  - Accept only the first message, ignore duplicates. This approach requires that the UDP stream\0A    should contain some metadata necessary for the remote host to determine the source and ordering\0A    of each received datum. This approach works best for periodic data, such as telemetry, where\0A    the sender does not expect any responses.\0A\0A  - Process all messages, including duplicates. This approach assumes that the remote host acts\0A    as a server, processing all received requests and providing responses to each. This arrangement\0A    implies that the client may receive duplicated responses. It is therefore the client's\0A    responsibility to resolve the possible ambiguity. An obvious solution is to accept the first\0A    arrived response and ignore the later ones.\0A\0AApplications are free to choose whatever redundancy management strategy works best for them.\0A\0AIf the source node expects that the remote host will send some data back, it shall explicitly notify\0Athe modem nodes about this, so that they could prepare to perform reverse forwarding when the\0Aexpected data arrives from the remote host. The technique of reverse forwarding is known in\0Anetworking as IP Masquerading, or (in general) Network Address Translation (NAT). The notification\0Ais performed by means of setting one of the corresponding flags defined below.\0A\0AIn order to be able to match datagrams received from remote hosts and the local nodes they should\0Abe forwarded to, modem nodes are required to keep certain metadata about outgoing datagrams. Such\0Ametadata is stored in a data structure referred to as \22NAT table\22, where every entry would normally\0Acontain at least the following fields:\0A  - The local UDP port number that was used to send the outgoing datagram from.\0A    Per RFC 4787, the port number is chosen by the modem node automatically.\0A  - The node-ID of the local node that has sent the outgoing datagram.\0A  - Value of the field session_id defined below.\0A  - Possibly some other data, depending on the implementation.\0A\0AThe modem nodes are required to keep each NAT table entry for at least NAT_ENTRY_MIN_TTL seconds\0Asince the last reverse forwarding action was performed. Should the memory resources of the modem node\0Abe exhausted, it is allowed to remove old NAT entries earlier, following the policy of least recent use.\0A\0AHaving received a UDP packet from a remote host, the modem node would check the NAT table in order\0Ato determine where on the Cyphal bus the received data should be forwarded to. If the NAT table\0Acontains no matches, the received data should be silently dropped. If a match is found, the\0Amodem node will forward the data to the recipient node using the service HandleIncomingPacket.\0AIf the service invocation times out, the modem node is permitted to remove the corresponding entry from\0Athe NAT table immediately (but it is not required). This will ensure that the modem nodes will not be\0Atasked with translations for client nodes that are no longer online or are unreachable.\0AAdditionally, client nodes will be able to hint the modem nodes to remove translation entries they no\0Alonger need by simply refusing to respond to the corresponding service invocation. Please refer to\0Athe definition of that service data type for a more in-depth review of the reverse forwarding process.\0A\0AModem nodes can also perform traffic shaping, if needed, by means of delaying or dropping UDP\0Adatagrams that exceed the quota.\0A\0ATo summarize, a typical data exchange occurrence should amount to the following actions:\0A\0A  - A local Cyphal node broadcasts a message of type OutgoingPacket with the payload it needs\0A    to forward. If the node expects the remote host to send any data back, it sets the masquerading flag.\0A\0A  - Every modem node on the bus receives the message and performs the following actions:\0A\0A      - The domain name is resolved, unless the destination address provided in the message\0A        is already an IP address, in which case this step should be skipped.\0A\0A      - The domain name to IP address mapping is added to the local DNS cache, although this\0A        part is entirely implementation defined and is not required.\0A\0A      - The masquerading flag is checked. If it is set, a new entry is added to the NAT table.\0A        If such entry already existed, its expiration timeout is reset. If no such entry existed\0A        and a new one cannot be added because of memory limitations, the least recently used\0A        (i.e. oldest) entry of the NAT table is replaced with the new one.\0A\0A      - The payload is forwarded to the determined IP address.\0A\0A  - At this point, direct forwarding is complete. Should any of the modem nodes receive an incoming\0A    packet, they would attempt to perform a reverse forwarding according to the above provided algorithm.\0A\0AIt is recommended to use the lowest transport priority level when broadcasting messages of this type,\0Ain order to avoid interference with a real-time traffic on the bus. Usage of higher priority levels is\0Aunlikely to be practical because the latency and throughput limitations introduced by the on-board radio\0Acommunication equipment are likely to vastly exceed those of the local CAN bus.", extent_bits = 4800 : i64, fixed_port_id = 8174 : i64, full_name = "uavcan.internet.udp.OutgoingPacket", header_path = "uavcan/internet/udp/OutgoingPacket_0_2.h", major = 0 : i32, minor = 2 : i32} {
    dsdl.field {c_name = "session_id", doc = "\0A\0A\0AThis field is set to an arbitrary value by the transmitting node in order to be able to match the response\0Awith the locally kept context. The function of this field is virtually identical to that of UDP/IP port\0Anumbers. This value can be set to zero safely if the sending node does not have multiple contexts to\0Adistinguish between.", name = "session_id", type_name = "saturated uint16"}
    dsdl.field {c_name = "destination_port", doc = "\0A\0A\0A\0AUDP destination port number.", name = "destination_port", type_name = "saturated uint16"}
    dsdl.field {c_name = "destination_address", doc = "\0ADomain name or IP address where the payload should be forwarded to.\0ANote that broadcast addresses are allowed here, for example, 255.255.255.255.\0ABroadcasting with masquerading enabled works the same way as unicasting with masquerading enabled: the modem\0Anode should take care to channel all traffic arriving at the opened port from any source to the node that\0Arequested masquerading.\0AThe full domain name length may not exceed 253 octets, according to the DNS specification.\0ACyphal imposes a stricter length limit in order to reduce the memory and traffic burden on the bus: 45 characters.\0A45 characters is the amount of space that is required to represent the longest possible form of an IPv6 address\0A(an IPv4-mapped IPv6 address). Examples:\0A  \22forum.opencyphal.org\22                          - domain name\0A  \22192.168.1.1\22                                   - IPv4 address\0A  \222001:0db8:85a3:0000:0000:8a2e:0370:7334\22       - IPv6 address, full form\0A  \222001:db8:85a3::8a2e:370:7334\22                  - IPv6 address, same as above, short form (preferred)\0A  \22ABCD:ABCD:ABCD:ABCD:ABCD:ABCD:192.168.158.190\22 - IPv4-mapped IPv6, full form (length limit, 45 characters)", name = "destination_address", type_name = "saturated uint8[<=45]"}
    dsdl.field {c_name = "use_masquerading", doc = "Expect data back (i.e., instruct the modem to use the NAT table).", name = "use_masquerading", type_name = "bool"}
    dsdl.field {c_name = "use_dtls", doc = "Use Datagram Transport Layer Security. Drop the packet if DTLS is not supported.", name = "use_dtls", type_name = "bool"}
    dsdl.field {c_name = "_", doc = "Option flags.", name = "", padding, type_name = "void6"}
    dsdl.field {c_name = "payload", doc = "Effective payload. This data will be forwarded to the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.", name = "payload", type_name = "saturated uint8[<=508]"}
    dsdl.constant {doc = "[second]\0AModem nodes are required to keep the NAT table entries alive for at least this amount of time, unless the\0Atable is overflowed, in which case they are allowed to remove least recently used entries in favor of\0Anewer ones. Modem nodes are required to be able to accommodate at least 100 entries in the NAT table.", name = "NAT_ENTRY_MIN_TTL", type_name = "saturated uint32", value_text = "86400"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__OutgoingPacket__deserialize_", c_serialize_symbol = "uavcan__internet__udp__OutgoingPacket__serialize_", c_type_name = "uavcan__internet__udp__OutgoingPacket", extent_bits = 4800 : i64, max_bits = 4488 : i64, min_bits = 64 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "session_id", cast_mode = "saturated", doc = "\0A\0A\0AThis field is set to an arbitrary value by the transmitting node in order to be able to match the response\0Awith the locally kept context. The function of this field is virtually identical to that of UDP/IP port\0Anumbers. This value can be set to zero safely if the sending node does not have multiple contexts to\0Adistinguish between.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "session_id", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "destination_port", cast_mode = "saturated", doc = "\0A\0A\0A\0AUDP destination port number.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "destination_port", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 45 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "destination_address", cast_mode = "saturated", doc = "\0ADomain name or IP address where the payload should be forwarded to.\0ANote that broadcast addresses are allowed here, for example, 255.255.255.255.\0ABroadcasting with masquerading enabled works the same way as unicasting with masquerading enabled: the modem\0Anode should take care to channel all traffic arriving at the opened port from any source to the node that\0Arequested masquerading.\0AThe full domain name length may not exceed 253 octets, according to the DNS specification.\0ACyphal imposes a stricter length limit in order to reduce the memory and traffic burden on the bus: 45 characters.\0A45 characters is the amount of space that is required to represent the longest possible form of an IPv6 address\0A(an IPv4-mapped IPv6 address). Examples:\0A  \22forum.opencyphal.org\22                          - domain name\0A  \22192.168.1.1\22                                   - IPv4 address\0A  \222001:0db8:85a3:0000:0000:8a2e:0370:7334\22       - IPv6 address, full form\0A  \222001:db8:85a3::8a2e:370:7334\22                  - IPv6 address, same as above, short form (preferred)\0A  \22ABCD:ABCD:ABCD:ABCD:ABCD:ABCD:192.168.158.190\22 - IPv4-mapped IPv6, full form (length limit, 45 characters)", kind = "field", max_bits = 368 : i64, min_bits = 8 : i64, name = "destination_address", scalar_category = "unsigned", type_name = "saturated uint8[<=45]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "use_masquerading", cast_mode = "saturated", doc = "Expect data back (i.e., instruct the modem to use the NAT table).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "use_masquerading", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "use_dtls", cast_mode = "saturated", doc = "Use Datagram Transport Layer Security. Drop the packet if DTLS is not supported.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "use_dtls", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 6 : i64, c_name = "_", cast_mode = "saturated", doc = "Option flags.", kind = "padding", max_bits = 6 : i64, min_bits = 6 : i64, name = "", scalar_category = "void", type_name = "void6", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 508 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "payload", cast_mode = "saturated", doc = "Effective payload. This data will be forwarded to the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.", kind = "field", max_bits = 4080 : i64, min_bits = 16 : i64, name = "payload", scalar_category = "unsigned", type_name = "saturated uint8[<=508]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_internet_udp_OutgoingPacket_0_1 attributes {c_type_name = "uavcan__internet__udp__OutgoingPacket", deprecated, doc = "This message carries UDP packets from a node on the local bus to a remote host on the Internet or a LAN.\0A\0AAny node can broadcast a message of this type.\0A\0AAll nodes that are capable of communication with the Internet or a LAN should subscribe to messages\0Aof this type and forward the payload to the indicated host and port using exactly one UDP datagram\0Aper message (i.e. additional fragmentation is to be avoided). Such nodes will be referred to as\0A\22modem nodes\22.\0A\0AIt is expected that some systems will have more than one modem node available.\0AEach modem node is supposed to forward every message it sees, which will naturally create\0Asome degree of modular redundancy and fault tolerance. The remote host should therefore be able to\0Aproperly handle possibly duplicated messages from different source addresses, in addition to\0Apossible duplications introduced by the UDP/IP protocol itself. There are at least two obvious\0Astrategies that can be employed by the remote host:\0A\0A  - Accept only the first message, ignore duplicates. This approach requires that the UDP stream\0A    should contain some metadata necessary for the remote host to determine the source and ordering\0A    of each received datum. This approach works best for periodic data, such as telemetry, where\0A    the sender does not expect any responses.\0A\0A  - Process all messages, including duplicates. This approach assumes that the remote host acts\0A    as a server, processing all received requests and providing responses to each. This arrangement\0A    implies that the client may receive duplicated responses. It is therefore the client's\0A    responsibility to resolve the possible ambiguity. An obvious solution is to accept the first\0A    arrived response and ignore the later ones.\0A\0AApplications are free to choose whatever redundancy management strategy works best for them.\0A\0AIf the source node expects that the remote host will send some data back, it shall explicitly notify\0Athe modem nodes about this, so that they could prepare to perform reverse forwarding when the\0Aexpected data arrives from the remote host. The technique of reverse forwarding is known in\0Anetworking as IP Masquerading, or (in general) Network Address Translation (NAT). The notification\0Ais performed by means of setting one of the corresponding flags defined below.\0A\0AIn order to be able to match datagrams received from remote hosts and the local nodes they should\0Abe forwarded to, modem nodes are required to keep certain metadata about outgoing datagrams. Such\0Ametadata is stored in a data structure referred to as \22NAT table\22, where every entry would normally\0Acontain at least the following fields:\0A  - The local UDP port number that was used to send the outgoing datagram from.\0A    Per RFC 4787, the port number is chosen by the modem node automatically.\0A  - The node-ID of the local node that has sent the outgoing datagram.\0A  - Value of the field session_id defined below.\0A  - Possibly some other data, depending on the implementation.\0A\0AThe modem nodes are required to keep each NAT table entry for at least NAT_ENTRY_MIN_TTL seconds\0Asince the last reverse forwarding action was performed. Should the memory resources of the modem node\0Abe exhausted, it is allowed to remove old NAT entries earlier, following the policy of least recent use.\0A\0AHaving received a UDP packet from a remote host, the modem node would check the NAT table in order\0Ato determine where on the Cyphal bus the received data should be forwarded to. If the NAT table\0Acontains no matches, the received data should be silently dropped. If a match is found, the\0Amodem node will forward the data to the recipient node using the service HandleIncomingPacket.\0AIf the service invocation times out, the modem node is permitted to remove the corresponding entry from\0Athe NAT table immediately (but it is not required). This will ensure that the modem nodes will not be\0Atasked with translations for client nodes that are no longer online or are unreachable.\0AAdditionally, client nodes will be able to hint the modem nodes to remove translation entries they no\0Alonger need by simply refusing to respond to the corresponding service invocation. Please refer to\0Athe definition of that service data type for a more in-depth review of the reverse forwarding process.\0A\0AModem nodes can also perform traffic shaping, if needed, by means of delaying or dropping UDP\0Adatagrams that exceed the quota.\0A\0ATo summarize, a typical data exchange occurrence should amount to the following actions:\0A\0A  - A local Cyphal node broadcasts a message of type OutgoingPacket with the payload it needs\0A    to forward. If the node expects the remote host to send any data back, it sets the masquerading flag.\0A\0A  - Every modem node on the bus receives the message and performs the following actions:\0A\0A      - The domain name is resolved, unless the destination address provided in the message\0A        is already an IP address, in which case this step should be skipped.\0A\0A      - The domain name to IP address mapping is added to the local DNS cache, although this\0A        part is entirely implementation defined and is not required.\0A\0A      - The masquerading flag is checked. If it is set, a new entry is added to the NAT table.\0A        If such entry already existed, its expiration timeout is reset. If no such entry existed\0A        and a new one cannot be added because of memory limitations, the least recently used\0A        (i.e. oldest) entry of the NAT table is replaced with the new one.\0A\0A      - The payload is forwarded to the determined IP address.\0A\0A  - At this point, direct forwarding is complete. Should any of the modem nodes receive an incoming\0A    packet, they would attempt to perform a reverse forwarding according to the above provided algorithm.\0A\0AIt is recommended to use the lowest transport priority level when broadcasting messages of this type,\0Ain order to avoid interference with a real-time traffic on the bus. Usage of higher priority levels is\0Aunlikely to be practical because the latency and throughput limitations introduced by the on-board radio\0Acommunication equipment are likely to vastly exceed those of the local CAN bus.", extent_bits = 4800 : i64, fixed_port_id = 8174 : i64, full_name = "uavcan.internet.udp.OutgoingPacket", header_path = "uavcan/internet/udp/OutgoingPacket_0_1.h", major = 0 : i32, minor = 1 : i32} {
    dsdl.field {c_name = "session_id", doc = "\0A\0A\0AThis field is set to an arbitrary value by the transmitting node in order to be able to match the response\0Awith the locally kept context. The function of this field is virtually identical to that of UDP/IP port\0Anumbers. This value can be set to zero safely if the sending node does not have multiple contexts to\0Adistinguish between.", name = "session_id", type_name = "saturated uint16"}
    dsdl.field {c_name = "destination_port", doc = "\0A\0A\0A\0AUDP destination port number.", name = "destination_port", type_name = "saturated uint16"}
    dsdl.field {c_name = "destination_address", doc = "\0ADomain name or IP address where the payload should be forwarded to.\0ANote that broadcast addresses are allowed here, for example, 255.255.255.255.\0ABroadcasting with masquerading enabled works the same way as unicasting with masquerading enabled: the modem\0Anode should take care to channel all traffic arriving at the opened port from any source to the node that\0Arequested masquerading.\0AThe full domain name length may not exceed 253 octets, according to the DNS specification.\0ACyphal imposes a stricter length limit in order to reduce the memory and traffic burden on the bus: 45 characters.\0A45 characters is the amount of space that is required to represent the longest possible form of an IPv6 address\0A(an IPv4-mapped IPv6 address). Examples:\0A  \22forum.opencyphal.org\22                          - domain name\0A  \22192.168.1.1\22                                   - IPv4 address\0A  \222001:0db8:85a3:0000:0000:8a2e:0370:7334\22       - IPv6 address, full form\0A  \222001:db8:85a3::8a2e:370:7334\22                  - IPv6 address, same as above, short form (preferred)\0A  \22ABCD:ABCD:ABCD:ABCD:ABCD:ABCD:192.168.158.190\22 - IPv4-mapped IPv6, full form (length limit, 45 characters)", name = "destination_address", type_name = "saturated uint8[<=45]"}
    dsdl.field {c_name = "use_masquerading", doc = "Expect data back (i.e., instruct the modem to use the NAT table).", name = "use_masquerading", type_name = "bool"}
    dsdl.field {c_name = "use_dtls", doc = "Use Datagram Transport Layer Security. Drop the packet if DTLS is not supported.", name = "use_dtls", type_name = "bool"}
    dsdl.field {c_name = "_", doc = "Option flags.", name = "", padding, type_name = "void6"}
    dsdl.field {c_name = "payload", doc = "Effective payload. This data will be forwarded to the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ACyphal further limits the maximum packet size to reduce the memory and traffic burden on the nodes.", name = "payload", type_name = "saturated uint8[<=260]"}
    dsdl.constant {doc = "[second]\0AModem nodes are required to keep the NAT table entries alive for at least this amount of time, unless the\0Atable is overflowed, in which case they are allowed to remove least recently used entries in favor of\0Anewer ones. Modem nodes are required to be able to accommodate at least 100 entries in the NAT table.", name = "NAT_ENTRY_MIN_TTL", type_name = "saturated uint32", value_text = "86400"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__internet__udp__OutgoingPacket__deserialize_", c_serialize_symbol = "uavcan__internet__udp__OutgoingPacket__serialize_", c_type_name = "uavcan__internet__udp__OutgoingPacket", extent_bits = 4800 : i64, max_bits = 2504 : i64, min_bits = 64 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "session_id", cast_mode = "saturated", doc = "\0A\0A\0AThis field is set to an arbitrary value by the transmitting node in order to be able to match the response\0Awith the locally kept context. The function of this field is virtually identical to that of UDP/IP port\0Anumbers. This value can be set to zero safely if the sending node does not have multiple contexts to\0Adistinguish between.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "session_id", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "destination_port", cast_mode = "saturated", doc = "\0A\0A\0A\0AUDP destination port number.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "destination_port", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 45 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "destination_address", cast_mode = "saturated", doc = "\0ADomain name or IP address where the payload should be forwarded to.\0ANote that broadcast addresses are allowed here, for example, 255.255.255.255.\0ABroadcasting with masquerading enabled works the same way as unicasting with masquerading enabled: the modem\0Anode should take care to channel all traffic arriving at the opened port from any source to the node that\0Arequested masquerading.\0AThe full domain name length may not exceed 253 octets, according to the DNS specification.\0ACyphal imposes a stricter length limit in order to reduce the memory and traffic burden on the bus: 45 characters.\0A45 characters is the amount of space that is required to represent the longest possible form of an IPv6 address\0A(an IPv4-mapped IPv6 address). Examples:\0A  \22forum.opencyphal.org\22                          - domain name\0A  \22192.168.1.1\22                                   - IPv4 address\0A  \222001:0db8:85a3:0000:0000:8a2e:0370:7334\22       - IPv6 address, full form\0A  \222001:db8:85a3::8a2e:370:7334\22                  - IPv6 address, same as above, short form (preferred)\0A  \22ABCD:ABCD:ABCD:ABCD:ABCD:ABCD:192.168.158.190\22 - IPv4-mapped IPv6, full form (length limit, 45 characters)", kind = "field", max_bits = 368 : i64, min_bits = 8 : i64, name = "destination_address", scalar_category = "unsigned", type_name = "saturated uint8[<=45]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "use_masquerading", cast_mode = "saturated", doc = "Expect data back (i.e., instruct the modem to use the NAT table).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "use_masquerading", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "use_dtls", cast_mode = "saturated", doc = "Use Datagram Transport Layer Security. Drop the packet if DTLS is not supported.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "use_dtls", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 6 : i64, c_name = "_", cast_mode = "saturated", doc = "Option flags.", kind = "padding", max_bits = 6 : i64, min_bits = 6 : i64, name = "", scalar_category = "void", type_name = "void6", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 260 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "payload", cast_mode = "saturated", doc = "Effective payload. This data will be forwarded to the remote host verbatim.\0AUDP packets that contain more than 508 bytes of payload may be dropped by some types of\0Acommunication equipment. Refer to RFC 791 and 2460 for an in-depth review.\0ACyphal further limits the maximum packet size to reduce the memory and traffic burden on the nodes.", kind = "field", max_bits = 2096 : i64, min_bits = 16 : i64, name = "payload", scalar_category = "unsigned", type_name = "saturated uint8[<=260]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_ArbitrationID_0_1 attributes {c_type_name = "uavcan__metatransport__can__ArbitrationID", doc = "CAN frame arbitration field.", extent_bits = 40 : i64, full_name = "uavcan.metatransport.can.ArbitrationID", header_path = "uavcan/metatransport/can/ArbitrationID_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "base", name = "base", type_name = "BaseArbitrationID.0.1"}
    dsdl.field {c_name = "extended", name = "extended", type_name = "ExtendedArbitrationID.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__ArbitrationID__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__ArbitrationID__serialize_", c_type_name = "uavcan__metatransport__can__ArbitrationID", extent_bits = 40 : i64, fixed_size, is_union, max_bits = 40 : i64, min_bits = 40 : i64, sealed, union_option_count = 2 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "base", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__BaseArbitrationID", composite_extent_bits = 32 : i64, composite_full_name = "uavcan.metatransport.can.BaseArbitrationID", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "base", scalar_category = "composite", type_name = "BaseArbitrationID.0.1", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "extended", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__ExtendedArbitrationID", composite_extent_bits = 32 : i64, composite_full_name = "uavcan.metatransport.can.ExtendedArbitrationID", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "extended", scalar_category = "composite", type_name = "ExtendedArbitrationID.0.1", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_BaseArbitrationID_0_1 attributes {c_type_name = "uavcan__metatransport__can__BaseArbitrationID", doc = "11-bit identifier.", extent_bits = 32 : i64, full_name = "uavcan.metatransport.can.BaseArbitrationID", header_path = "uavcan/metatransport/can/BaseArbitrationID_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "truncated uint11"}
    dsdl.field {c_name = "_", name = "", padding, type_name = "void21"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__BaseArbitrationID__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__BaseArbitrationID__serialize_", c_type_name = "uavcan__metatransport__can__BaseArbitrationID", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 11 : i64, c_name = "value", cast_mode = "truncated", kind = "field", max_bits = 11 : i64, min_bits = 11 : i64, name = "value", scalar_category = "unsigned", type_name = "truncated uint11", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 21 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 21 : i64, min_bits = 21 : i64, name = "", scalar_category = "void", type_name = "void21", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_DataClassic_0_1 attributes {c_type_name = "uavcan__metatransport__can__DataClassic", doc = "Classic data frame payload.", extent_bits = 112 : i64, full_name = "uavcan.metatransport.can.DataClassic", header_path = "uavcan/metatransport/can/DataClassic_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "arbitration_id", name = "arbitration_id", type_name = "ArbitrationID.0.1"}
    dsdl.field {c_name = "data", name = "data", type_name = "saturated uint8[<=8]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__DataClassic__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__DataClassic__serialize_", c_type_name = "uavcan__metatransport__can__DataClassic", extent_bits = 112 : i64, max_bits = 112 : i64, min_bits = 48 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "arbitration_id", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__ArbitrationID", composite_extent_bits = 40 : i64, composite_full_name = "uavcan.metatransport.can.ArbitrationID", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "arbitration_id", scalar_category = "composite", type_name = "ArbitrationID.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 8 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 72 : i64, min_bits = 8 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=8]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_DataFD_0_1 attributes {c_type_name = "uavcan__metatransport__can__DataFD", doc = "CAN FD data frame payload.", extent_bits = 560 : i64, full_name = "uavcan.metatransport.can.DataFD", header_path = "uavcan/metatransport/can/DataFD_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "arbitration_id", name = "arbitration_id", type_name = "ArbitrationID.0.1"}
    dsdl.field {c_name = "data", name = "data", type_name = "saturated uint8[<=64]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__DataFD__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__DataFD__serialize_", c_type_name = "uavcan__metatransport__can__DataFD", extent_bits = 560 : i64, max_bits = 560 : i64, min_bits = 48 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "arbitration_id", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__ArbitrationID", composite_extent_bits = 40 : i64, composite_full_name = "uavcan.metatransport.can.ArbitrationID", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "arbitration_id", scalar_category = "composite", type_name = "ArbitrationID.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 64 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 520 : i64, min_bits = 8 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=64]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_Error_0_1 attributes {c_type_name = "uavcan__metatransport__can__Error", doc = "CAN bus error report: either an intentionally generated error frame or a disturbance.", extent_bits = 32 : i64, full_name = "uavcan.metatransport.can.Error", header_path = "uavcan/metatransport/can/Error_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "_", name = "", padding, type_name = "void32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__Error__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__Error__serialize_", c_type_name = "uavcan__metatransport__can__Error", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 32 : i64, min_bits = 32 : i64, name = "", scalar_category = "void", type_name = "void32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_ExtendedArbitrationID_0_1 attributes {c_type_name = "uavcan__metatransport__can__ExtendedArbitrationID", doc = "29-bit identifier.", extent_bits = 32 : i64, full_name = "uavcan.metatransport.can.ExtendedArbitrationID", header_path = "uavcan/metatransport/can/ExtendedArbitrationID_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "truncated uint29"}
    dsdl.field {c_name = "_", name = "", padding, type_name = "void3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__ExtendedArbitrationID__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__ExtendedArbitrationID__serialize_", c_type_name = "uavcan__metatransport__can__ExtendedArbitrationID", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 29 : i64, c_name = "value", cast_mode = "truncated", kind = "field", max_bits = 29 : i64, min_bits = 29 : i64, name = "value", scalar_category = "unsigned", type_name = "truncated uint29", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 3 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 3 : i64, min_bits = 3 : i64, name = "", scalar_category = "void", type_name = "void3", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_Frame_0_2 attributes {c_type_name = "uavcan__metatransport__can__Frame", doc = "Classic CAN or CAN FD frame representation. This is the top-level data type in its namespace.", extent_bits = 568 : i64, full_name = "uavcan.metatransport.can.Frame", header_path = "uavcan/metatransport/can/Frame_0_2.h", major = 0 : i32, minor = 2 : i32, sealed} {
    dsdl.field {c_name = "error", doc = "CAN error (intentional or disturbance)", name = "error", type_name = "Error.0.1"}
    dsdl.field {c_name = "data_fd", doc = "Bit rate switch flag active", name = "data_fd", type_name = "DataFD.0.1"}
    dsdl.field {c_name = "data_classic", doc = "Bit rate switch flag not active", name = "data_classic", type_name = "DataClassic.0.1"}
    dsdl.field {c_name = "remote_transmission_request", doc = "Bit rate switch flag not active", name = "remote_transmission_request", type_name = "RTR.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__Frame__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__Frame__serialize_", c_type_name = "uavcan__metatransport__can__Frame", extent_bits = 568 : i64, is_union, max_bits = 568 : i64, min_bits = 40 : i64, sealed, union_option_count = 4 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__Error", composite_extent_bits = 32 : i64, composite_full_name = "uavcan.metatransport.can.Error", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "CAN error (intentional or disturbance)", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "error", scalar_category = "composite", type_name = "Error.0.1", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data_fd", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__DataFD", composite_extent_bits = 560 : i64, composite_full_name = "uavcan.metatransport.can.DataFD", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag active", kind = "field", max_bits = 560 : i64, min_bits = 48 : i64, name = "data_fd", scalar_category = "composite", type_name = "DataFD.0.1", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data_classic", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__DataClassic", composite_extent_bits = 112 : i64, composite_full_name = "uavcan.metatransport.can.DataClassic", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag not active", kind = "field", max_bits = 112 : i64, min_bits = 48 : i64, name = "data_classic", scalar_category = "composite", type_name = "DataClassic.0.1", union_option_index = 2 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "remote_transmission_request", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__RTR", composite_extent_bits = 40 : i64, composite_full_name = "uavcan.metatransport.can.RTR", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag not active", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "remote_transmission_request", scalar_category = "composite", type_name = "RTR.0.1", union_option_index = 3 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_Frame_0_1 attributes {c_type_name = "uavcan__metatransport__can__Frame", deprecated, doc = "CAN 2.0 or CAN FD frame representation. This is the top-level data type in its namespace.", extent_bits = 624 : i64, full_name = "uavcan.metatransport.can.Frame", header_path = "uavcan/metatransport/can/Frame_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "manifestation", name = "manifestation", type_name = "Manifestation.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__Frame__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__Frame__serialize_", c_type_name = "uavcan__metatransport__can__Frame", extent_bits = 624 : i64, max_bits = 624 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "manifestation", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__Manifestation", composite_extent_bits = 568 : i64, composite_full_name = "uavcan.metatransport.can.Manifestation", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 568 : i64, min_bits = 40 : i64, name = "manifestation", scalar_category = "composite", type_name = "Manifestation.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_Manifestation_0_1 attributes {c_type_name = "uavcan__metatransport__can__Manifestation", deprecated, doc = "CAN frame properties that can be manifested on the bus.", extent_bits = 568 : i64, full_name = "uavcan.metatransport.can.Manifestation", header_path = "uavcan/metatransport/can/Manifestation_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "error", doc = "CAN error (intentional or disturbance)", name = "error", type_name = "Error.0.1"}
    dsdl.field {c_name = "data_fd", doc = "Bit rate switch flag active", name = "data_fd", type_name = "DataFD.0.1"}
    dsdl.field {c_name = "data_classic", doc = "Bit rate switch flag not active", name = "data_classic", type_name = "DataClassic.0.1"}
    dsdl.field {c_name = "remote_transmission_request", doc = "Bit rate switch flag not active", name = "remote_transmission_request", type_name = "RTR.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__Manifestation__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__Manifestation__serialize_", c_type_name = "uavcan__metatransport__can__Manifestation", extent_bits = 568 : i64, is_union, max_bits = 568 : i64, min_bits = 40 : i64, sealed, union_option_count = 4 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "error", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__Error", composite_extent_bits = 32 : i64, composite_full_name = "uavcan.metatransport.can.Error", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "CAN error (intentional or disturbance)", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "error", scalar_category = "composite", type_name = "Error.0.1", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data_fd", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__DataFD", composite_extent_bits = 560 : i64, composite_full_name = "uavcan.metatransport.can.DataFD", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag active", kind = "field", max_bits = 560 : i64, min_bits = 48 : i64, name = "data_fd", scalar_category = "composite", type_name = "DataFD.0.1", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "data_classic", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__DataClassic", composite_extent_bits = 112 : i64, composite_full_name = "uavcan.metatransport.can.DataClassic", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag not active", kind = "field", max_bits = 112 : i64, min_bits = 48 : i64, name = "data_classic", scalar_category = "composite", type_name = "DataClassic.0.1", union_option_index = 2 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "remote_transmission_request", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__RTR", composite_extent_bits = 40 : i64, composite_full_name = "uavcan.metatransport.can.RTR", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "Bit rate switch flag not active", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "remote_transmission_request", scalar_category = "composite", type_name = "RTR.0.1", union_option_index = 3 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_can_RTR_0_1 attributes {c_type_name = "uavcan__metatransport__can__RTR", doc = "Classic remote transmission request (not defined for CAN FD).", extent_bits = 40 : i64, full_name = "uavcan.metatransport.can.RTR", header_path = "uavcan/metatransport/can/RTR_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "arbitration_id", name = "arbitration_id", type_name = "ArbitrationID.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__can__RTR__deserialize_", c_serialize_symbol = "uavcan__metatransport__can__RTR__serialize_", c_type_name = "uavcan__metatransport__can__RTR", extent_bits = 40 : i64, fixed_size, max_bits = 40 : i64, min_bits = 40 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "arbitration_id", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__can__ArbitrationID", composite_extent_bits = 40 : i64, composite_full_name = "uavcan.metatransport.can.ArbitrationID", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "arbitration_id", scalar_category = "composite", type_name = "ArbitrationID.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_ethernet_EtherType_0_1 attributes {c_type_name = "uavcan__metatransport__ethernet__EtherType", doc = "Standard EtherType constants as defined by IEEE Registration Authority and IANA.\0AThis list is only a small subset of constants that are considered to be relevant for Cyphal.", extent_bits = 16 : i64, full_name = "uavcan.metatransport.ethernet.EtherType", header_path = "uavcan/metatransport/ethernet/EtherType_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint16"}
    dsdl.constant {name = "IP_V4", type_name = "saturated uint16", value_text = "2048"}
    dsdl.constant {name = "ARP", type_name = "saturated uint16", value_text = "2054"}
    dsdl.constant {name = "IP_V6", type_name = "saturated uint16", value_text = "34525"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__ethernet__EtherType__deserialize_", c_serialize_symbol = "uavcan__metatransport__ethernet__EtherType__serialize_", c_type_name = "uavcan__metatransport__ethernet__EtherType", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_ethernet_Frame_0_1 attributes {c_type_name = "uavcan__metatransport__ethernet__Frame", doc = "IEEE 802.3 Ethernet frame encapsulation.\0AIn terms of libpcap/tcpdump, the corresponding link type is LINKTYPE_ETHERNET/DLT_EN10MB.", extent_bits = 73856 : i64, full_name = "uavcan.metatransport.ethernet.Frame", header_path = "uavcan/metatransport/ethernet/Frame_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "destination", name = "destination", type_name = "saturated uint8[6]"}
    dsdl.field {c_name = "source", name = "source", type_name = "saturated uint8[6]"}
    dsdl.field {c_name = "ethertype", name = "ethertype", type_name = "EtherType.0.1"}
    dsdl.field {c_name = "payload", doc = "Supports conventional jumbo frames (up to 9 KiB).", name = "payload", type_name = "saturated uint8[<=9216]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__ethernet__Frame__deserialize_", c_serialize_symbol = "uavcan__metatransport__ethernet__Frame__serialize_", c_type_name = "uavcan__metatransport__ethernet__Frame", extent_bits = 73856 : i64, max_bits = 73856 : i64, min_bits = 128 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 6 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "destination", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "destination", scalar_category = "unsigned", type_name = "saturated uint8[6]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 6 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "source", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "source", scalar_category = "unsigned", type_name = "saturated uint8[6]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "ethertype", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__ethernet__EtherType", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.metatransport.ethernet.EtherType", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "ethertype", scalar_category = "composite", type_name = "EtherType.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 9216 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "payload", cast_mode = "saturated", doc = "Supports conventional jumbo frames (up to 9 KiB).", kind = "field", max_bits = 73744 : i64, min_bits = 16 : i64, name = "payload", scalar_category = "unsigned", type_name = "saturated uint8[<=9216]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_serial_Fragment_0_2 attributes {c_type_name = "uavcan__metatransport__serial__Fragment", doc = "A chunk of raw bytes exchanged over a serial transport. Serial links do not support framing natively.\0AThe chunk may be of arbitrary size.\0A\0AIf this data type is used to encapsulate Cyphal/serial, then it is recommended to ensure that each message\0Acontains at most one Cyphal/serial transport frame (frames are separated by zero-valued delimiter bytes).", extent_bits = 16400 : i64, full_name = "uavcan.metatransport.serial.Fragment", header_path = "uavcan/metatransport/serial/Fragment_0_2.h", major = 0 : i32, minor = 2 : i32, sealed} {
    dsdl.field {c_name = "data", name = "data", type_name = "saturated uint8[<=CAPACITY_BYTES]"}
    dsdl.constant {name = "CAPACITY_BYTES", type_name = "saturated uint12", value_text = "2048"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__serial__Fragment__deserialize_", c_serialize_symbol = "uavcan__metatransport__serial__Fragment__serialize_", c_type_name = "uavcan__metatransport__serial__Fragment", extent_bits = 16400 : i64, max_bits = 16400 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 2048 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 16400 : i64, min_bits = 16 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=CAPACITY_BYTES]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_serial_Fragment_0_1 attributes {c_type_name = "uavcan__metatransport__serial__Fragment", deprecated, doc = "A chunk of raw bytes exchanged over a serial transport. Serial links do not support framing natively.\0AThe chunk may be of arbitrary size.", extent_bits = 2120 : i64, full_name = "uavcan.metatransport.serial.Fragment", header_path = "uavcan/metatransport/serial/Fragment_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "data", name = "data", type_name = "saturated uint8[<=CAPACITY_BYTES]"}
    dsdl.constant {name = "CAPACITY_BYTES", type_name = "saturated uint9", value_text = "256"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__serial__Fragment__deserialize_", c_serialize_symbol = "uavcan__metatransport__serial__Fragment__serialize_", c_type_name = "uavcan__metatransport__serial__Fragment", extent_bits = 2120 : i64, max_bits = 2120 : i64, min_bits = 72 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=CAPACITY_BYTES]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_udp_Endpoint_0_1 attributes {c_type_name = "uavcan__metatransport__udp__Endpoint", deprecated, doc = "A UDP/IP endpoint address specification.", extent_bits = 256 : i64, full_name = "uavcan.metatransport.udp.Endpoint", header_path = "uavcan/metatransport/udp/Endpoint_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "ip_address", doc = "The IP address of the host in the network byte order (big endian).\0AIPv6 addresses are represented as-is.\0AIPv4 addresses are represented using IPv4-mapped IPv6 addresses.", name = "ip_address", type_name = "saturated uint8[16]"}
    dsdl.field {c_name = "mac_address", doc = "\0A\0A\0AMAC address of the host in the network byte order (big endian).", name = "mac_address", type_name = "saturated uint8[6]"}
    dsdl.field {c_name = "port", doc = "\0AThe UDP port number.", name = "port", type_name = "saturated uint16"}
    dsdl.field {c_name = "_", doc = "", name = "", padding, type_name = "void64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__udp__Endpoint__deserialize_", c_serialize_symbol = "uavcan__metatransport__udp__Endpoint__serialize_", c_type_name = "uavcan__metatransport__udp__Endpoint", extent_bits = 256 : i64, fixed_size, max_bits = 256 : i64, min_bits = 256 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 16 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "ip_address", cast_mode = "saturated", doc = "The IP address of the host in the network byte order (big endian).\0AIPv6 addresses are represented as-is.\0AIPv4 addresses are represented using IPv4-mapped IPv6 addresses.", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "ip_address", scalar_category = "unsigned", type_name = "saturated uint8[16]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 6 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "mac_address", cast_mode = "saturated", doc = "\0A\0A\0AMAC address of the host in the network byte order (big endian).", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "mac_address", scalar_category = "unsigned", type_name = "saturated uint8[6]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "port", cast_mode = "saturated", doc = "\0AThe UDP port number.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "port", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "_", cast_mode = "saturated", doc = "", kind = "padding", max_bits = 64 : i64, min_bits = 64 : i64, name = "", scalar_category = "void", type_name = "void64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_metatransport_udp_Frame_0_1 attributes {c_type_name = "uavcan__metatransport__udp__Frame", deprecated, doc = "A generic UDP/IP frame.\0AJumboframes are supported in the interest of greater application compatibility.", extent_bits = 81920 : i64, full_name = "uavcan.metatransport.udp.Frame", header_path = "uavcan/metatransport/udp/Frame_0_1.h", major = 0 : i32, minor = 1 : i32} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "_", name = "", padding, type_name = "void8"}
    dsdl.field {c_name = "source", name = "source", type_name = "Endpoint.0.1"}
    dsdl.field {c_name = "destination", name = "destination", type_name = "Endpoint.0.1"}
    dsdl.field {c_name = "data", name = "data", type_name = "saturated uint8[<=MTU]"}
    dsdl.constant {doc = "Max jumbo frame 9 KiB, IP header min 20 B, UDP header 8 B.", name = "MTU", type_name = "saturated uint14", value_text = "9188"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__metatransport__udp__Frame__deserialize_", c_serialize_symbol = "uavcan__metatransport__udp__Frame__serialize_", c_type_name = "uavcan__metatransport__udp__Frame", extent_bits = 81920 : i64, max_bits = 74096 : i64, min_bits = 592 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "_", cast_mode = "saturated", kind = "padding", max_bits = 8 : i64, min_bits = 8 : i64, name = "", scalar_category = "void", type_name = "void8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "source", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__udp__Endpoint", composite_extent_bits = 256 : i64, composite_full_name = "uavcan.metatransport.udp.Endpoint", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 256 : i64, min_bits = 256 : i64, name = "source", scalar_category = "composite", type_name = "Endpoint.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "destination", cast_mode = "saturated", composite_c_type_name = "uavcan__metatransport__udp__Endpoint", composite_extent_bits = 256 : i64, composite_full_name = "uavcan.metatransport.udp.Endpoint", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, kind = "field", max_bits = 256 : i64, min_bits = 256 : i64, name = "destination", scalar_category = "composite", type_name = "Endpoint.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 9188 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "data", cast_mode = "saturated", kind = "field", max_bits = 73520 : i64, min_bits = 16 : i64, name = "data", scalar_category = "unsigned", type_name = "saturated uint8[<=MTU]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_ExecuteCommand_1_3 attributes {c_type_name = "uavcan__node__ExecuteCommand", doc = "Instructs the server node to execute or commence execution of a simple predefined command.\0AAll standard commands are optional; i.e., not guaranteed to be supported by all nodes.", extent_bits = 2400 : i64, fixed_port_id = 435 : i64, full_name = "uavcan.node.ExecuteCommand", header_path = "uavcan/node/ExecuteCommand_1_3.h", major = 1 : i32, minor = 3 : i32, service} {
    dsdl.field {c_name = "command", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", name = "command", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "parameter", doc = "\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", name = "parameter", section = "request", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]"}
    dsdl.constant {doc = "\0A\0A\0AReboot the node.\0ANote that some standard commands may or may not require a restart in order to take effect; e.g., factory reset.", name = "COMMAND_RESTART", section = "request", type_name = "saturated uint16", value_text = "65535"}
    dsdl.constant {doc = "\0A\0AShut down the node; further access will not be possible until the power is turned back on.", name = "COMMAND_POWER_OFF", section = "request", type_name = "saturated uint16", value_text = "65534"}
    dsdl.constant {doc = "\0ABegin the software update process using uavcan.file.Read. This command makes use of the \22parameter\22 field below.\0AThe parameter contains the path to the new software image file to be downloaded by the server from the client\0Ausing the standard service uavcan.file.Read. Observe that this operation swaps the roles of the client and\0Athe server.\0A\0AUpon reception of this command, the server (updatee) will evaluate whether it is possible to begin the\0Asoftware update process. If that is deemed impossible, the command will be rejected with one of the\0Aerror codes defined in the response section of this definition (e.g., BAD_STATE if the node is currently\0Aon-duty and a sudden interruption of its activities is considered unsafe, and so on).\0AIf an update process is already underway, the updatee should abort the process and restart with the new file,\0Aunless the updatee can determine that the specified file is the same file that is already being downloaded,\0Ain which case it is allowed to respond SUCCESS and continue the old update process.\0AIf there are no other conditions precluding the requested update, the updatee will return a SUCCESS and\0Ainitiate the file transfer process by invoking the standard service uavcan.file.Read repeatedly until the file\0Ais transferred fully (please refer to the documentation for that data type for more information about its usage).\0A\0AWhile the software is being updated, the updatee should set its mode (the field \22mode\22 in uavcan.node.Heartbeat)\0Ato MODE_SOFTWARE_UPDATE. Please refer to the documentation for uavcan.node.Heartbeat for more information.\0A\0AIt is recognized that most systems will have to interrupt their normal services to perform the software update\0A(unless some form of software hot swapping is implemented, as is the case in some high-availability systems).\0A\0AMicrocontrollers that are requested to update their firmware may need to stop execution of their current firmware\0Aand start the embedded bootloader (although other approaches are possible as well). In that case,\0Awhile the embedded bootloader is running, the mode reported via the message uavcan.node.Heartbeat should be\0AMODE_SOFTWARE_UPDATE as long as the bootloader is runing, even if no update-related activities\0Aare currently underway. For example, if the update process failed and the bootloader cannot load the software,\0Athe same mode MODE_SOFTWARE_UPDATE will be reported.\0AIt is also recognized that in a microcontroller setting, the application that served the update request will have\0Ato pass the update-related metadata (such as the node-ID of the server and the firmware image file path) to\0Athe embedded bootloader. The tactics of that transaction lie outside of the scope of this specification.", name = "COMMAND_BEGIN_SOFTWARE_UPDATE", section = "request", type_name = "saturated uint16", value_text = "65533"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AReturn the node's configuration back to the factory default settings (may require restart).\0ADue to the uncertainty whether a restart is required, generic interfaces should always force a restart.", name = "COMMAND_FACTORY_RESET", section = "request", type_name = "saturated uint16", value_text = "65532"}
    dsdl.constant {doc = "\0A\0ACease activities immediately, enter a safe state until restarted.\0AFurther operation may no longer be possible until a restart command is executed.", name = "COMMAND_EMERGENCY_STOP", section = "request", type_name = "saturated uint16", value_text = "65531"}
    dsdl.constant {doc = "\0A\0AThis command instructs the node to store the current configuration parameter values and other persistent states\0Ato the non-volatile storage. Nodes are allowed to manage persistent states automatically, obviating the need for\0Athis command by committing all such data to the non-volatile memory automatically as necessary. However, some\0Anodes may lack this functionality, in which case this parameter should be used. Generic interfaces should always\0Ainvoke this command in order to ensure that the data is stored even if the node doesn't implement automatic\0Apersistence management.", name = "COMMAND_STORE_PERSISTENT_STATES", section = "request", type_name = "saturated uint16", value_text = "65530"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0AThis command instructs the node to physically identify itself in some way--e.g., by flashing a light or\0Aemitting a sound. The duration and the nature of the identification process is implementation-defined.\0AThis command can be useful for human operators to match assigned node-ID values to physical nodes during setup.", name = "COMMAND_IDENTIFY", section = "request", type_name = "saturated uint16", value_text = "65529"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Request__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Request__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Request", extent_bits = 2400 : i64, max_bits = 2064 : i64, min_bits = 24 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "command", cast_mode = "saturated", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "command", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "parameter", cast_mode = "saturated", doc = "\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "parameter", scalar_category = "unsigned", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "status", doc = "The result of the request.", name = "status", section = "response", type_name = "saturated uint8"}
    dsdl.field {c_name = "output", doc = "\0AAny output that could be useful that has the capability to convey detailed information.\0AUsers can send commands and receive specific data, like device status or measurements back in a streamlined manner.\0AThe standard commands should leave this field empty unless explicitly specified otherwise.", name = "output", section = "response", type_name = "saturated uint8[<=46]"}
    dsdl.constant {doc = "Started or executed successfully", name = "STATUS_SUCCESS", section = "response", type_name = "saturated uint8", value_text = "0"}
    dsdl.constant {doc = "Could not start or the desired outcome could not be reached", name = "STATUS_FAILURE", section = "response", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "Denied due to lack of authorization", name = "STATUS_NOT_AUTHORIZED", section = "response", type_name = "saturated uint8", value_text = "2"}
    dsdl.constant {doc = "The requested command is not known or not supported", name = "STATUS_BAD_COMMAND", section = "response", type_name = "saturated uint8", value_text = "3"}
    dsdl.constant {doc = "The supplied parameter cannot be used with the selected command", name = "STATUS_BAD_PARAMETER", section = "response", type_name = "saturated uint8", value_text = "4"}
    dsdl.constant {doc = "The current state of the node does not permit execution of this command", name = "STATUS_BAD_STATE", section = "response", type_name = "saturated uint8", value_text = "5"}
    dsdl.constant {doc = "The operation should have succeeded but an unexpected failure occurred", name = "STATUS_INTERNAL_ERROR", section = "response", type_name = "saturated uint8", value_text = "6"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Response__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Response__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Response", extent_bits = 384 : i64, max_bits = 384 : i64, min_bits = 16 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "status", cast_mode = "saturated", doc = "The result of the request.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "status", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 46 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "output", cast_mode = "saturated", doc = "\0AAny output that could be useful that has the capability to convey detailed information.\0AUsers can send commands and receive specific data, like device status or measurements back in a streamlined manner.\0AThe standard commands should leave this field empty unless explicitly specified otherwise.", kind = "field", max_bits = 376 : i64, min_bits = 8 : i64, name = "output", scalar_category = "unsigned", type_name = "saturated uint8[<=46]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_ExecuteCommand_1_2 attributes {c_type_name = "uavcan__node__ExecuteCommand", deprecated, doc = "Instructs the server node to execute or commence execution of a simple predefined command.\0AAll standard commands are optional; i.e., not guaranteed to be supported by all nodes.", extent_bits = 2400 : i64, fixed_port_id = 435 : i64, full_name = "uavcan.node.ExecuteCommand", header_path = "uavcan/node/ExecuteCommand_1_2.h", major = 1 : i32, minor = 2 : i32, service} {
    dsdl.field {c_name = "command", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", name = "command", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "parameter", doc = "\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", name = "parameter", section = "request", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]"}
    dsdl.constant {doc = "\0A\0A\0AReboot the node.\0ANote that some standard commands may or may not require a restart in order to take effect; e.g., factory reset.", name = "COMMAND_RESTART", section = "request", type_name = "saturated uint16", value_text = "65535"}
    dsdl.constant {doc = "\0A\0AShut down the node; further access will not be possible until the power is turned back on.", name = "COMMAND_POWER_OFF", section = "request", type_name = "saturated uint16", value_text = "65534"}
    dsdl.constant {doc = "\0ABegin the software update process using uavcan.file.Read. This command makes use of the \22parameter\22 field below.\0AThe parameter contains the path to the new software image file to be downloaded by the server from the client\0Ausing the standard service uavcan.file.Read. Observe that this operation swaps the roles of the client and\0Athe server.\0A\0AUpon reception of this command, the server (updatee) will evaluate whether it is possible to begin the\0Asoftware update process. If that is deemed impossible, the command will be rejected with one of the\0Aerror codes defined in the response section of this definition (e.g., BAD_STATE if the node is currently\0Aon-duty and a sudden interruption of its activities is considered unsafe, and so on).\0AIf an update process is already underway, the updatee should abort the process and restart with the new file,\0Aunless the updatee can determine that the specified file is the same file that is already being downloaded,\0Ain which case it is allowed to respond SUCCESS and continue the old update process.\0AIf there are no other conditions precluding the requested update, the updatee will return a SUCCESS and\0Ainitiate the file transfer process by invoking the standard service uavcan.file.Read repeatedly until the file\0Ais transferred fully (please refer to the documentation for that data type for more information about its usage).\0A\0AWhile the software is being updated, the updatee should set its mode (the field \22mode\22 in uavcan.node.Heartbeat)\0Ato MODE_SOFTWARE_UPDATE. Please refer to the documentation for uavcan.node.Heartbeat for more information.\0A\0AIt is recognized that most systems will have to interrupt their normal services to perform the software update\0A(unless some form of software hot swapping is implemented, as is the case in some high-availability systems).\0A\0AMicrocontrollers that are requested to update their firmware may need to stop execution of their current firmware\0Aand start the embedded bootloader (although other approaches are possible as well). In that case,\0Awhile the embedded bootloader is running, the mode reported via the message uavcan.node.Heartbeat should be\0AMODE_SOFTWARE_UPDATE as long as the bootloader is runing, even if no update-related activities\0Aare currently underway. For example, if the update process failed and the bootloader cannot load the software,\0Athe same mode MODE_SOFTWARE_UPDATE will be reported.\0AIt is also recognized that in a microcontroller setting, the application that served the update request will have\0Ato pass the update-related metadata (such as the node-ID of the server and the firmware image file path) to\0Athe embedded bootloader. The tactics of that transaction lie outside of the scope of this specification.", name = "COMMAND_BEGIN_SOFTWARE_UPDATE", section = "request", type_name = "saturated uint16", value_text = "65533"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AReturn the node's configuration back to the factory default settings (may require restart).\0ADue to the uncertainty whether a restart is required, generic interfaces should always force a restart.", name = "COMMAND_FACTORY_RESET", section = "request", type_name = "saturated uint16", value_text = "65532"}
    dsdl.constant {doc = "\0A\0ACease activities immediately, enter a safe state until restarted.\0AFurther operation may no longer be possible until a restart command is executed.", name = "COMMAND_EMERGENCY_STOP", section = "request", type_name = "saturated uint16", value_text = "65531"}
    dsdl.constant {doc = "\0A\0AThis command instructs the node to store the current configuration parameter values and other persistent states\0Ato the non-volatile storage. Nodes are allowed to manage persistent states automatically, obviating the need for\0Athis command by committing all such data to the non-volatile memory automatically as necessary. However, some\0Anodes may lack this functionality, in which case this parameter should be used. Generic interfaces should always\0Ainvoke this command in order to ensure that the data is stored even if the node doesn't implement automatic\0Apersistence management.", name = "COMMAND_STORE_PERSISTENT_STATES", section = "request", type_name = "saturated uint16", value_text = "65530"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0AThis command instructs the node to physically identify itself in some way--e.g., by flashing a light or\0Aemitting a sound. The duration and the nature of the identification process is implementation-defined.\0AThis command can be useful for human operators to match assigned node-ID values to physical nodes during setup.", name = "COMMAND_IDENTIFY", section = "request", type_name = "saturated uint16", value_text = "65529"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Request__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Request__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Request", extent_bits = 2400 : i64, max_bits = 2064 : i64, min_bits = 24 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "command", cast_mode = "saturated", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "command", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "parameter", cast_mode = "saturated", doc = "\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "parameter", scalar_category = "unsigned", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "status", doc = "The result of the request.", name = "status", section = "response", type_name = "saturated uint8"}
    dsdl.constant {doc = "Started or executed successfully", name = "STATUS_SUCCESS", section = "response", type_name = "saturated uint8", value_text = "0"}
    dsdl.constant {doc = "Could not start or the desired outcome could not be reached", name = "STATUS_FAILURE", section = "response", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "Denied due to lack of authorization", name = "STATUS_NOT_AUTHORIZED", section = "response", type_name = "saturated uint8", value_text = "2"}
    dsdl.constant {doc = "The requested command is not known or not supported", name = "STATUS_BAD_COMMAND", section = "response", type_name = "saturated uint8", value_text = "3"}
    dsdl.constant {doc = "The supplied parameter cannot be used with the selected command", name = "STATUS_BAD_PARAMETER", section = "response", type_name = "saturated uint8", value_text = "4"}
    dsdl.constant {doc = "The current state of the node does not permit execution of this command", name = "STATUS_BAD_STATE", section = "response", type_name = "saturated uint8", value_text = "5"}
    dsdl.constant {doc = "The operation should have succeeded but an unexpected failure occurred", name = "STATUS_INTERNAL_ERROR", section = "response", type_name = "saturated uint8", value_text = "6"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Response__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Response__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Response", extent_bits = 384 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "status", cast_mode = "saturated", doc = "The result of the request.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "status", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_ExecuteCommand_1_1 attributes {c_type_name = "uavcan__node__ExecuteCommand", deprecated, doc = "Instructs the server node to execute or commence execution of a simple predefined command.\0AAll standard commands are optional; i.e., not guaranteed to be supported by all nodes.", extent_bits = 2400 : i64, fixed_port_id = 435 : i64, full_name = "uavcan.node.ExecuteCommand", header_path = "uavcan/node/ExecuteCommand_1_1.h", major = 1 : i32, minor = 1 : i32, service} {
    dsdl.field {c_name = "command", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", name = "command", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "parameter", doc = "\0A\0A\0A\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", name = "parameter", section = "request", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]"}
    dsdl.constant {doc = "\0A\0A\0AReboot the node.\0ANote that some standard commands may or may not require a restart in order to take effect; e.g., factory reset.", name = "COMMAND_RESTART", section = "request", type_name = "saturated uint16", value_text = "65535"}
    dsdl.constant {doc = "\0A\0AShut down the node; further access will not be possible until the power is turned back on.", name = "COMMAND_POWER_OFF", section = "request", type_name = "saturated uint16", value_text = "65534"}
    dsdl.constant {doc = "\0ABegin the software update process using uavcan.file.Read. This command makes use of the \22parameter\22 field below.\0AThe parameter contains the path to the new software image file to be downloaded by the server from the client\0Ausing the standard service uavcan.file.Read. Observe that this operation swaps the roles of the client and\0Athe server.\0A\0AUpon reception of this command, the server (updatee) will evaluate whether it is possible to begin the\0Asoftware update process. If that is deemed impossible, the command will be rejected with one of the\0Aerror codes defined in the response section of this definition (e.g., BAD_STATE if the node is currently\0Aon-duty and a sudden interruption of its activities is considered unsafe, and so on).\0AIf an update process is already underway, the updatee should abort the process and restart with the new file,\0Aunless the updatee can determine that the specified file is the same file that is already being downloaded,\0Ain which case it is allowed to respond SUCCESS and continue the old update process.\0AIf there are no other conditions precluding the requested update, the updatee will return a SUCCESS and\0Ainitiate the file transfer process by invoking the standard service uavcan.file.Read repeatedly until the file\0Ais transferred fully (please refer to the documentation for that data type for more information about its usage).\0A\0AWhile the software is being updated, the updatee should set its mode (the field \22mode\22 in uavcan.node.Heartbeat)\0Ato MODE_SOFTWARE_UPDATE. Please refer to the documentation for uavcan.node.Heartbeat for more information.\0A\0AIt is recognized that most systems will have to interrupt their normal services to perform the software update\0A(unless some form of software hot swapping is implemented, as is the case in some high-availability systems).\0A\0AMicrocontrollers that are requested to update their firmware may need to stop execution of their current firmware\0Aand start the embedded bootloader (although other approaches are possible as well). In that case,\0Awhile the embedded bootloader is running, the mode reported via the message uavcan.node.Heartbeat should be\0AMODE_SOFTWARE_UPDATE as long as the bootloader is runing, even if no update-related activities\0Aare currently underway. For example, if the update process failed and the bootloader cannot load the software,\0Athe same mode MODE_SOFTWARE_UPDATE will be reported.\0AIt is also recognized that in a microcontroller setting, the application that served the update request will have\0Ato pass the update-related metadata (such as the node-ID of the server and the firmware image file path) to\0Athe embedded bootloader. The tactics of that transaction lie outside of the scope of this specification.", name = "COMMAND_BEGIN_SOFTWARE_UPDATE", section = "request", type_name = "saturated uint16", value_text = "65533"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AReturn the node's configuration back to the factory default settings (may require restart).\0ADue to the uncertainty whether a restart is required, generic interfaces should always force a restart.", name = "COMMAND_FACTORY_RESET", section = "request", type_name = "saturated uint16", value_text = "65532"}
    dsdl.constant {doc = "\0A\0ACease activities immediately, enter a safe state until restarted.\0AFurther operation may no longer be possible until a restart command is executed.", name = "COMMAND_EMERGENCY_STOP", section = "request", type_name = "saturated uint16", value_text = "65531"}
    dsdl.constant {doc = "\0A\0AThis command instructs the node to store the current configuration parameter values and other persistent states\0Ato the non-volatile storage. Nodes are allowed to manage persistent states automatically, obviating the need for\0Athis command by committing all such data to the non-volatile memory automatically as necessary. However, some\0Anodes may lack this functionality, in which case this parameter should be used. Generic interfaces should always\0Ainvoke this command in order to ensure that the data is stored even if the node doesn't implement automatic\0Apersistence management.", name = "COMMAND_STORE_PERSISTENT_STATES", section = "request", type_name = "saturated uint16", value_text = "65530"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Request__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Request__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Request", extent_bits = 2400 : i64, max_bits = 2064 : i64, min_bits = 24 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "command", cast_mode = "saturated", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "command", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "parameter", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "parameter", scalar_category = "unsigned", type_name = "saturated uint8[<=(uavcan.file.Path.2.0 . MAX_LENGTH)]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "status", doc = "The result of the request.", name = "status", section = "response", type_name = "saturated uint8"}
    dsdl.constant {doc = "Started or executed successfully", name = "STATUS_SUCCESS", section = "response", type_name = "saturated uint8", value_text = "0"}
    dsdl.constant {doc = "Could not start or the desired outcome could not be reached", name = "STATUS_FAILURE", section = "response", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "Denied due to lack of authorization", name = "STATUS_NOT_AUTHORIZED", section = "response", type_name = "saturated uint8", value_text = "2"}
    dsdl.constant {doc = "The requested command is not known or not supported", name = "STATUS_BAD_COMMAND", section = "response", type_name = "saturated uint8", value_text = "3"}
    dsdl.constant {doc = "The supplied parameter cannot be used with the selected command", name = "STATUS_BAD_PARAMETER", section = "response", type_name = "saturated uint8", value_text = "4"}
    dsdl.constant {doc = "The current state of the node does not permit execution of this command", name = "STATUS_BAD_STATE", section = "response", type_name = "saturated uint8", value_text = "5"}
    dsdl.constant {doc = "The operation should have succeeded but an unexpected failure occurred", name = "STATUS_INTERNAL_ERROR", section = "response", type_name = "saturated uint8", value_text = "6"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Response__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Response__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Response", extent_bits = 384 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "status", cast_mode = "saturated", doc = "The result of the request.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "status", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_ExecuteCommand_1_0 attributes {c_type_name = "uavcan__node__ExecuteCommand", deprecated, doc = "Instructs the server node to execute or commence execution of a simple predefined command.\0AAll standard commands are optional; i.e., not guaranteed to be supported by all nodes.", extent_bits = 2400 : i64, fixed_port_id = 435 : i64, full_name = "uavcan.node.ExecuteCommand", header_path = "uavcan/node/ExecuteCommand_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "command", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", name = "command", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "parameter", doc = "\0A\0A\0A\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", name = "parameter", section = "request", type_name = "saturated uint8[<=(uavcan.file.Path.1.0 . MAX_LENGTH)]"}
    dsdl.constant {doc = "\0A\0A\0AReboot the node.\0ANote that some standard commands may or may not require a restart in order to take effect; e.g., factory reset.", name = "COMMAND_RESTART", section = "request", type_name = "saturated uint16", value_text = "65535"}
    dsdl.constant {doc = "\0A\0AShut down the node; further access will not be possible until the power is turned back on.", name = "COMMAND_POWER_OFF", section = "request", type_name = "saturated uint16", value_text = "65534"}
    dsdl.constant {doc = "\0ABegin the software update process using uavcan.file.Read. This command makes use of the \22parameter\22 field below.\0AThe parameter contains the path to the new software image file to be downloaded by the server from the client\0Ausing the standard service uavcan.file.Read. Observe that this operation swaps the roles of the client and\0Athe server.\0A\0AUpon reception of this command, the server (updatee) will evaluate whether it is possible to begin the\0Asoftware update process. If that is deemed impossible, the command will be rejected with one of the\0Aerror codes defined in the response section of this definition (e.g., BAD_STATE if the node is currently\0Aon-duty and a sudden interruption of its activities is considered unsafe, and so on).\0AIf an update process is already underway, the updatee should abort the process and restart with the new file,\0Aunless the updatee can determine that the specified file is the same file that is already being downloaded,\0Ain which case it is allowed to respond SUCCESS and continue the old update process.\0AIf there are no other conditions precluding the requested update, the updatee will return a SUCCESS and\0Ainitiate the file transfer process by invoking the standard service uavcan.file.Read repeatedly until the file\0Ais transferred fully (please refer to the documentation for that data type for more information about its usage).\0A\0AWhile the software is being updated, the updatee should set its mode (the field \22mode\22 in uavcan.node.Heartbeat)\0Ato MODE_SOFTWARE_UPDATE. Please refer to the documentation for uavcan.node.Heartbeat for more information.\0A\0AIt is recognized that most systems will have to interrupt their normal services to perform the software update\0A(unless some form of software hot swapping is implemented, as is the case in some high-availability systems).\0A\0AMicrocontrollers that are requested to update their firmware may need to stop execution of their current firmware\0Aand start the embedded bootloader (although other approaches are possible as well). In that case,\0Awhile the embedded bootloader is running, the mode reported via the message uavcan.node.Heartbeat should be\0AMODE_SOFTWARE_UPDATE as long as the bootloader is runing, even if no update-related activities\0Aare currently underway. For example, if the update process failed and the bootloader cannot load the software,\0Athe same mode MODE_SOFTWARE_UPDATE will be reported.\0AIt is also recognized that in a microcontroller setting, the application that served the update request will have\0Ato pass the update-related metadata (such as the node-ID of the server and the firmware image file path) to\0Athe embedded bootloader. The tactics of that transaction lie outside of the scope of this specification.", name = "COMMAND_BEGIN_SOFTWARE_UPDATE", section = "request", type_name = "saturated uint16", value_text = "65533"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AReturn the node's configuration back to the factory default settings (may require restart).\0ADue to the uncertainty whether a restart is required, generic interfaces should always force a restart.", name = "COMMAND_FACTORY_RESET", section = "request", type_name = "saturated uint16", value_text = "65532"}
    dsdl.constant {doc = "\0A\0ACease activities immediately, enter a safe state until restarted.\0AFurther operation may no longer be possible until a restart command is executed.", name = "COMMAND_EMERGENCY_STOP", section = "request", type_name = "saturated uint16", value_text = "65531"}
    dsdl.constant {doc = "\0A\0AThis command instructs the node to store the current configuration parameter values and other persistent states\0Ato the non-volatile storage. Nodes are allowed to manage persistent states automatically, obviating the need for\0Athis command by committing all such data to the non-volatile memory automatically as necessary. However, some\0Anodes may lack this functionality, in which case this parameter should be used. Generic interfaces should always\0Ainvoke this command in order to ensure that the data is stored even if the node doesn't implement automatic\0Apersistence management.", name = "COMMAND_STORE_PERSISTENT_STATES", section = "request", type_name = "saturated uint16", value_text = "65530"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Request__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Request__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Request", extent_bits = 2400 : i64, max_bits = 920 : i64, min_bits = 24 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "command", cast_mode = "saturated", doc = "Standard pre-defined commands are at the top of the range (defined below).\0AVendors can define arbitrary, vendor-specific commands in the bottom part of the range (starting from zero).\0AVendor-specific commands shall not use identifiers above 32767.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "command", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 112 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "parameter", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0AA string parameter supplied to the command. The format and interpretation is command-specific.\0AThe standard commands do not use this field (ignore it), excepting the following:\0A  - COMMAND_BEGIN_SOFTWARE_UPDATE", kind = "field", max_bits = 904 : i64, min_bits = 8 : i64, name = "parameter", scalar_category = "unsigned", type_name = "saturated uint8[<=(uavcan.file.Path.1.0 . MAX_LENGTH)]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "status", doc = "The result of the request.", name = "status", section = "response", type_name = "saturated uint8"}
    dsdl.constant {doc = "Started or executed successfully", name = "STATUS_SUCCESS", section = "response", type_name = "saturated uint8", value_text = "0"}
    dsdl.constant {doc = "Could not start or the desired outcome could not be reached", name = "STATUS_FAILURE", section = "response", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "Denied due to lack of authorization", name = "STATUS_NOT_AUTHORIZED", section = "response", type_name = "saturated uint8", value_text = "2"}
    dsdl.constant {doc = "The requested command is not known or not supported", name = "STATUS_BAD_COMMAND", section = "response", type_name = "saturated uint8", value_text = "3"}
    dsdl.constant {doc = "The supplied parameter cannot be used with the selected command", name = "STATUS_BAD_PARAMETER", section = "response", type_name = "saturated uint8", value_text = "4"}
    dsdl.constant {doc = "The current state of the node does not permit execution of this command", name = "STATUS_BAD_STATE", section = "response", type_name = "saturated uint8", value_text = "5"}
    dsdl.constant {doc = "The operation should have succeeded but an unexpected failure occurred", name = "STATUS_INTERNAL_ERROR", section = "response", type_name = "saturated uint8", value_text = "6"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ExecuteCommand__Response__deserialize_", c_serialize_symbol = "uavcan__node__ExecuteCommand__Response__serialize_", c_type_name = "uavcan__node__ExecuteCommand__Response", extent_bits = 384 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "status", cast_mode = "saturated", doc = "The result of the request.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "status", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_GetInfo_1_0 attributes {c_type_name = "uavcan__node__GetInfo", doc = "Full node info request.\0AAll of the returned information shall be static (unchanged) while the node is running.\0AIt is highly recommended to support this service on all nodes.", extent_bits = 0 : i64, fixed_port_id = 430 : i64, full_name = "uavcan.node.GetInfo", header_path = "uavcan/node/GetInfo_1_0.h", major = 1 : i32, minor = 0 : i32, sealed, service} {
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__GetInfo__Request__deserialize_", c_serialize_symbol = "uavcan__node__GetInfo__Request__serialize_", c_type_name = "uavcan__node__GetInfo__Request", extent_bits = 0 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, sealed, section = "request"} {
      dsdl.align {bits = 1 : i32}
    }
    dsdl.field {c_name = "protocol_version", doc = "The Cyphal protocol version implemented on this node, both major and minor.\0ANot to be changed while the node is running.", name = "protocol_version", section = "response", type_name = "Version.1.0"}
    dsdl.field {c_name = "hardware_version", doc = "\0A", name = "hardware_version", section = "response", type_name = "Version.1.0"}
    dsdl.field {c_name = "software_version", doc = "The version information shall not be changed while the node is running.\0AThe correct hardware version shall be reported at all times, excepting software-only nodes, in which\0Acase it should be set to zeros.\0AIf the node is equipped with a Cyphal-capable bootloader, the bootloader should report the software\0Aversion of the installed application, if there is any; if no application is found, zeros should be reported.", name = "software_version", section = "response", type_name = "Version.1.0"}
    dsdl.field {c_name = "software_vcs_revision_id", doc = "\0A\0A\0A\0A\0AA version control system (VCS) revision number or hash. Not to be changed while the node is running.\0AFor example, this field can be used for reporting the short git commit hash of the current\0Asoftware revision.\0ASet to zero if not used.", name = "software_vcs_revision_id", section = "response", type_name = "saturated uint64"}
    dsdl.field {c_name = "unique_id", doc = "\0A\0A\0A\0AThe unique-ID (UID) is a 128-bit long sequence that is likely to be globally unique per node.\0AThe vendor shall ensure that the probability of a collision with any other node UID globally is negligibly low.\0AUID is defined once per hardware unit and should never be changed.\0AAll zeros is not a valid UID.\0AIf the node is equipped with a Cyphal-capable bootloader, the bootloader shall use the same UID.", name = "unique_id", section = "response", type_name = "saturated uint8[16]"}
    dsdl.field {c_name = "name", doc = "\0AHuman-readable non-empty ASCII node name. An empty name is not permitted.\0AThe name shall not be changed while the node is running.\0AAllowed characters are: a-z (lowercase ASCII letters) 0-9 (decimal digits) . (dot) - (dash) _ (underscore).\0ANode name is a reversed Internet domain name (like Java packages), e.g. \22com.manufacturer.project.product\22.", name = "name", section = "response", type_name = "saturated uint8[<=50]"}
    dsdl.field {c_name = "software_image_crc", doc = "\0A\0A\0A\0AThe value of an arbitrary hash function applied to the software image. Not to be changed while the node is running.\0AThis field can be used to detect whether the software or firmware running on the node is an exact\0Asame version as a certain specific revision. This field provides a very strong identity guarantee,\0Aunlike the version fields above, which can be the same for different builds of the software.\0AAs can be seen from its definition, this field is optional.\0A\0AThe exact hash function and the methods of its application are implementation-defined.\0AHowever, implementations are recommended to adhere to the following guidelines, fully or partially:\0A  - The hash function should be CRC-64-WE.\0A  - The hash function should be applied to the entire application image padded to 8 bytes.\0A  - If the computed image CRC is stored within the software image itself, the value of\0A    the hash function becomes ill-defined, because it becomes recursively dependent on itself.\0A    In order to circumvent this issue, while computing or checking the CRC, its value stored\0A    within the image should be zeroed out.", name = "software_image_crc", section = "response", type_name = "saturated uint64[<=1]"}
    dsdl.field {c_name = "certificate_of_authenticity", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AThe certificate of authenticity (COA) of the node, 222 bytes max, optional. This field can be used for\0Areporting digital signatures (e.g., RSA-1776, or ECDSA if a higher degree of cryptographic strength is desired).\0ALeave empty if not used. Not to be changed while the node is running.", name = "certificate_of_authenticity", section = "response", type_name = "saturated uint8[<=222]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__GetInfo__Response__deserialize_", c_serialize_symbol = "uavcan__node__GetInfo__Response__serialize_", c_type_name = "uavcan__node__GetInfo__Response", extent_bits = 3584 : i64, max_bits = 2504 : i64, min_bits = 264 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "protocol_version", cast_mode = "saturated", composite_c_type_name = "uavcan__node__Version", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.Version", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The Cyphal protocol version implemented on this node, both major and minor.\0ANot to be changed while the node is running.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "protocol_version", scalar_category = "composite", type_name = "Version.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "hardware_version", cast_mode = "saturated", composite_c_type_name = "uavcan__node__Version", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.Version", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0A", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "hardware_version", scalar_category = "composite", type_name = "Version.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "software_version", cast_mode = "saturated", composite_c_type_name = "uavcan__node__Version", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.Version", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The version information shall not be changed while the node is running.\0AThe correct hardware version shall be reported at all times, excepting software-only nodes, in which\0Acase it should be set to zeros.\0AIf the node is equipped with a Cyphal-capable bootloader, the bootloader should report the software\0Aversion of the installed application, if there is any; if no application is found, zeros should be reported.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "software_version", scalar_category = "composite", type_name = "Version.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "software_vcs_revision_id", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0AA version control system (VCS) revision number or hash. Not to be changed while the node is running.\0AFor example, this field can be used for reporting the short git commit hash of the current\0Asoftware revision.\0ASet to zero if not used.", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "software_vcs_revision_id", scalar_category = "unsigned", type_name = "saturated uint64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 16 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "unique_id", cast_mode = "saturated", doc = "\0A\0A\0A\0AThe unique-ID (UID) is a 128-bit long sequence that is likely to be globally unique per node.\0AThe vendor shall ensure that the probability of a collision with any other node UID globally is negligibly low.\0AUID is defined once per hardware unit and should never be changed.\0AAll zeros is not a valid UID.\0AIf the node is equipped with a Cyphal-capable bootloader, the bootloader shall use the same UID.", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "unique_id", scalar_category = "unsigned", type_name = "saturated uint8[16]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 50 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "name", cast_mode = "saturated", doc = "\0AHuman-readable non-empty ASCII node name. An empty name is not permitted.\0AThe name shall not be changed while the node is running.\0AAllowed characters are: a-z (lowercase ASCII letters) 0-9 (decimal digits) . (dot) - (dash) _ (underscore).\0ANode name is a reversed Internet domain name (like Java packages), e.g. \22com.manufacturer.project.product\22.", kind = "field", max_bits = 408 : i64, min_bits = 8 : i64, name = "name", scalar_category = "unsigned", type_name = "saturated uint8[<=50]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 1 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 64 : i64, c_name = "software_image_crc", cast_mode = "saturated", doc = "\0A\0A\0A\0AThe value of an arbitrary hash function applied to the software image. Not to be changed while the node is running.\0AThis field can be used to detect whether the software or firmware running on the node is an exact\0Asame version as a certain specific revision. This field provides a very strong identity guarantee,\0Aunlike the version fields above, which can be the same for different builds of the software.\0AAs can be seen from its definition, this field is optional.\0A\0AThe exact hash function and the methods of its application are implementation-defined.\0AHowever, implementations are recommended to adhere to the following guidelines, fully or partially:\0A  - The hash function should be CRC-64-WE.\0A  - The hash function should be applied to the entire application image padded to 8 bytes.\0A  - If the computed image CRC is stored within the software image itself, the value of\0A    the hash function becomes ill-defined, because it becomes recursively dependent on itself.\0A    In order to circumvent this issue, while computing or checking the CRC, its value stored\0A    within the image should be zeroed out.", kind = "field", max_bits = 72 : i64, min_bits = 8 : i64, name = "software_image_crc", scalar_category = "unsigned", type_name = "saturated uint64[<=1]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 222 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "certificate_of_authenticity", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AThe certificate of authenticity (COA) of the node, 222 bytes max, optional. This field can be used for\0Areporting digital signatures (e.g., RSA-1776, or ECDSA if a higher degree of cryptographic strength is desired).\0ALeave empty if not used. Not to be changed while the node is running.", kind = "field", max_bits = 1784 : i64, min_bits = 8 : i64, name = "certificate_of_authenticity", scalar_category = "unsigned", type_name = "saturated uint8[<=222]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_GetTransportStatistics_0_1 attributes {c_type_name = "uavcan__node__GetTransportStatistics", doc = "Returns a set of general low-level transport statistical counters.\0AServers are encouraged but not required to sample the data atomically.", extent_bits = 0 : i64, fixed_port_id = 434 : i64, full_name = "uavcan.node.GetTransportStatistics", header_path = "uavcan/node/GetTransportStatistics_0_1.h", major = 0 : i32, minor = 1 : i32, sealed, service} {
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__GetTransportStatistics__Request__deserialize_", c_serialize_symbol = "uavcan__node__GetTransportStatistics__Request__serialize_", c_type_name = "uavcan__node__GetTransportStatistics__Request", extent_bits = 0 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, sealed, section = "request"} {
      dsdl.align {bits = 1 : i32}
    }
    dsdl.field {c_name = "transfer_statistics", doc = "\0ACyphal transfer performance statistics:\0Athe number of Cyphal transfers successfully sent, successfully received, and failed.\0AThe methods of error counting are implementation-defined.", name = "transfer_statistics", section = "response", type_name = "IOStatistics.0.1"}
    dsdl.field {c_name = "network_interface_statistics", doc = "\0A\0A\0ANetwork interface statistics, separate per interface.\0AE.g., for a doubly redundant transport, this array would contain two elements,\0Athe one at the index zero would apply to the first interface, the other to the second interface.\0AThe methods of counting are implementation-defined.", name = "network_interface_statistics", section = "response", type_name = "IOStatistics.0.1[<=MAX_NETWORK_INTERFACES]"}
    dsdl.constant {doc = "Cyphal supports up to triply modular redundant interfaces.", name = "MAX_NETWORK_INTERFACES", section = "response", type_name = "saturated uint8", value_text = "3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__GetTransportStatistics__Response__deserialize_", c_serialize_symbol = "uavcan__node__GetTransportStatistics__Response__serialize_", c_type_name = "uavcan__node__GetTransportStatistics__Response", extent_bits = 1536 : i64, max_bits = 488 : i64, min_bits = 128 : i64, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "transfer_statistics", cast_mode = "saturated", composite_c_type_name = "uavcan__node__IOStatistics", composite_extent_bits = 120 : i64, composite_full_name = "uavcan.node.IOStatistics", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "\0ACyphal transfer performance statistics:\0Athe number of Cyphal transfers successfully sent, successfully received, and failed.\0AThe methods of error counting are implementation-defined.", kind = "field", max_bits = 120 : i64, min_bits = 120 : i64, name = "transfer_statistics", scalar_category = "composite", type_name = "IOStatistics.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 3 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "network_interface_statistics", cast_mode = "saturated", composite_c_type_name = "uavcan__node__IOStatistics", composite_extent_bits = 120 : i64, composite_full_name = "uavcan.node.IOStatistics", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "\0A\0A\0ANetwork interface statistics, separate per interface.\0AE.g., for a doubly redundant transport, this array would contain two elements,\0Athe one at the index zero would apply to the first interface, the other to the second interface.\0AThe methods of counting are implementation-defined.", kind = "field", max_bits = 368 : i64, min_bits = 8 : i64, name = "network_interface_statistics", scalar_category = "composite", type_name = "IOStatistics.0.1[<=MAX_NETWORK_INTERFACES]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_Health_1_0 attributes {c_type_name = "uavcan__node__Health", doc = "Abstract component health information. If the node performs multiple activities (provides multiple network services),\0Aits health status should reflect the status of the worst-performing activity (network service).\0AFollows:\0A  https://www.law.cornell.edu/cfr/text/14/23.1322\0A  https://www.faa.gov/documentLibrary/media/Advisory_Circular/AC_25.1322-1.pdf section 6", extent_bits = 8 : i64, full_name = "uavcan.node.Health", header_path = "uavcan/node/Health_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint2"}
    dsdl.constant {doc = "The component is functioning properly (nominal).", name = "NOMINAL", type_name = "saturated uint2", value_text = "0"}
    dsdl.constant {doc = "\0AA critical parameter went out of range or the component encountered a minor failure that does not prevent\0Athe subsystem from performing any of its real-time functions.", name = "ADVISORY", type_name = "saturated uint2", value_text = "1"}
    dsdl.constant {doc = "\0A\0AThe component encountered a major failure and is performing in a degraded mode or outside of its designed limitations.", name = "CAUTION", type_name = "saturated uint2", value_text = "2"}
    dsdl.constant {doc = "\0AThe component suffered a fatal malfunction and is unable to perform its intended function.", name = "WARNING", type_name = "saturated uint2", value_text = "3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__Health__deserialize_", c_serialize_symbol = "uavcan__node__Health__serialize_", c_type_name = "uavcan__node__Health", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 2 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2 : i64, min_bits = 2 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint2", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_Heartbeat_1_0 attributes {c_type_name = "uavcan__node__Heartbeat", doc = "Abstract node status information.\0AThis is the only high-level function that shall be implemented by all nodes.\0A\0AAll Cyphal nodes that have a node-ID are required to publish this message to its fixed subject periodically.\0ANodes that do not have a node-ID (also known as \22anonymous nodes\22) shall not publish to this subject.\0A\0AThe default subject-ID 7509 is 1110101010101 in binary. The alternating bit pattern at the end helps transceiver\0Asynchronization (e.g., on CAN-based networks) and on some transports permits automatic bit rate detection.\0A\0ANetwork-wide health monitoring can be implemented by subscribing to the fixed subject.", extent_bits = 96 : i64, fixed_port_id = 7509 : i64, full_name = "uavcan.node.Heartbeat", header_path = "uavcan/node/Heartbeat_1_0.h", major = 1 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "uptime", doc = "\0A[second]\0AThe uptime seconds counter should never overflow. The counter will reach the upper limit in ~136 years,\0Aupon which time it should stay at 0xFFFFFFFF until the node is restarted.\0AOther nodes may detect that a remote node has restarted when this value leaps backwards.", name = "uptime", type_name = "saturated uint32"}
    dsdl.field {c_name = "health", doc = "\0A\0A\0AThe abstract health status of this node.", name = "health", type_name = "Health.1.0"}
    dsdl.field {c_name = "mode", doc = "\0AThe abstract operating mode of the publishing node.\0AThis field indicates the general level of readiness that can be further elaborated on a per-activity basis\0Ausing various specialized interfaces.", name = "mode", type_name = "Mode.1.0"}
    dsdl.field {c_name = "vendor_specific_status_code", doc = "\0A\0A\0AOptional, vendor-specific node status code, e.g. a fault code or a status bitmask.", name = "vendor_specific_status_code", type_name = "saturated uint8"}
    dsdl.constant {doc = "[second]\0AThe publication period shall not exceed this limit.\0AThe period should not change while the node is running.", name = "MAX_PUBLICATION_PERIOD", type_name = "saturated uint16", value_text = "1"}
    dsdl.constant {doc = "\0A\0A[second]\0AIf the last message from the node was received more than this amount of time ago, it should be considered offline.", name = "OFFLINE_TIMEOUT", type_name = "saturated uint16", value_text = "3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__Heartbeat__deserialize_", c_serialize_symbol = "uavcan__node__Heartbeat__serialize_", c_type_name = "uavcan__node__Heartbeat", extent_bits = 96 : i64, fixed_size, max_bits = 56 : i64, min_bits = 56 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "uptime", cast_mode = "saturated", doc = "\0A[second]\0AThe uptime seconds counter should never overflow. The counter will reach the upper limit in ~136 years,\0Aupon which time it should stay at 0xFFFFFFFF until the node is restarted.\0AOther nodes may detect that a remote node has restarted when this value leaps backwards.", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "uptime", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "health", cast_mode = "saturated", composite_c_type_name = "uavcan__node__Health", composite_extent_bits = 8 : i64, composite_full_name = "uavcan.node.Health", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0A\0A\0AThe abstract health status of this node.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "health", scalar_category = "composite", type_name = "Health.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "mode", cast_mode = "saturated", composite_c_type_name = "uavcan__node__Mode", composite_extent_bits = 8 : i64, composite_full_name = "uavcan.node.Mode", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AThe abstract operating mode of the publishing node.\0AThis field indicates the general level of readiness that can be further elaborated on a per-activity basis\0Ausing various specialized interfaces.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "mode", scalar_category = "composite", type_name = "Mode.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "vendor_specific_status_code", cast_mode = "saturated", doc = "\0A\0A\0AOptional, vendor-specific node status code, e.g. a fault code or a status bitmask.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "vendor_specific_status_code", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_ID_1_0 attributes {c_type_name = "uavcan__node__ID", doc = "Defines a node-ID.\0AThe maximum valid value is dependent on the underlying transport layer.\0AValues lower than 128 are always valid for all transports.\0ARefer to the specification for more info.", extent_bits = 16 : i64, full_name = "uavcan.node.ID", header_path = "uavcan/node/ID_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__ID__deserialize_", c_serialize_symbol = "uavcan__node__ID__serialize_", c_type_name = "uavcan__node__ID", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_IOStatistics_0_1 attributes {c_type_name = "uavcan__node__IOStatistics", doc = "A standard set of generic input/output statistical counters that generally should not overflow.\0AIf a 40-bit counter is incremented every millisecond, it will overflow in ~35 years.\0AIf an overflow occurs, the value will wrap over to zero.\0A\0AThe values should not be reset while the node is running.", extent_bits = 120 : i64, full_name = "uavcan.node.IOStatistics", header_path = "uavcan/node/IOStatistics_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "num_emitted", doc = "The number of successfully emitted entities.", name = "num_emitted", type_name = "truncated uint40"}
    dsdl.field {c_name = "num_received", doc = "\0AThe number of successfully received entities.", name = "num_received", type_name = "truncated uint40"}
    dsdl.field {c_name = "num_errored", doc = "\0AHow many errors have occurred.\0AThe exact definition of \22error\22 and how they are counted are implementation-defined,\0Aunless specifically defined otherwise.", name = "num_errored", type_name = "truncated uint40"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__IOStatistics__deserialize_", c_serialize_symbol = "uavcan__node__IOStatistics__serialize_", c_type_name = "uavcan__node__IOStatistics", extent_bits = 120 : i64, fixed_size, max_bits = 120 : i64, min_bits = 120 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "num_emitted", cast_mode = "truncated", doc = "The number of successfully emitted entities.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "num_emitted", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "num_received", cast_mode = "truncated", doc = "\0AThe number of successfully received entities.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "num_received", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 40 : i64, c_name = "num_errored", cast_mode = "truncated", doc = "\0AHow many errors have occurred.\0AThe exact definition of \22error\22 and how they are counted are implementation-defined,\0Aunless specifically defined otherwise.", kind = "field", max_bits = 40 : i64, min_bits = 40 : i64, name = "num_errored", scalar_category = "unsigned", type_name = "truncated uint40", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_Mode_1_0 attributes {c_type_name = "uavcan__node__Mode", doc = "The operating mode of a node.\0AReserved values can be used in future revisions of the specification.", extent_bits = 8 : i64, full_name = "uavcan.node.Mode", header_path = "uavcan/node/Mode_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint3"}
    dsdl.constant {doc = "Normal operating mode.", name = "OPERATIONAL", type_name = "saturated uint3", value_text = "0"}
    dsdl.constant {doc = "\0AInitialization is in progress; this mode is entered immediately after startup.", name = "INITIALIZATION", type_name = "saturated uint3", value_text = "1"}
    dsdl.constant {doc = "\0AE.g., calibration, self-test, etc.", name = "MAINTENANCE", type_name = "saturated uint3", value_text = "2"}
    dsdl.constant {doc = "\0ANew software/firmware is being loaded or the bootloader is running.", name = "SOFTWARE_UPDATE", type_name = "saturated uint3", value_text = "3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__Mode__deserialize_", c_serialize_symbol = "uavcan__node__Mode__serialize_", c_type_name = "uavcan__node__Mode", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 3 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 3 : i64, min_bits = 3 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint3", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_Version_1_0 attributes {c_type_name = "uavcan__node__Version", doc = "A shortened semantic version representation: only major and minor.\0AThe protocol generally does not concern itself with the patch version.", extent_bits = 16 : i64, full_name = "uavcan.node.Version", header_path = "uavcan/node/Version_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "major", name = "major", type_name = "saturated uint8"}
    dsdl.field {c_name = "minor", name = "minor", type_name = "saturated uint8"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__Version__deserialize_", c_serialize_symbol = "uavcan__node__Version__serialize_", c_type_name = "uavcan__node__Version", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "major", cast_mode = "saturated", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "major", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "minor", cast_mode = "saturated", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "minor", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_ID_1_0 attributes {c_type_name = "uavcan__node__port__ID", doc = "Used to refer either to a Service or to a Subject.\0AThe chosen tag identifies the kind of the port, then the numerical ID identifies the port within the kind.", extent_bits = 24 : i64, full_name = "uavcan.node.port.ID", header_path = "uavcan/node/port/ID_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "subject_id", name = "subject_id", type_name = "SubjectID.1.0"}
    dsdl.field {c_name = "service_id", name = "service_id", type_name = "ServiceID.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__ID__deserialize_", c_serialize_symbol = "uavcan__node__port__ID__serialize_", c_type_name = "uavcan__node__port__ID", extent_bits = 24 : i64, fixed_size, is_union, max_bits = 24 : i64, min_bits = 24 : i64, sealed, union_option_count = 2 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "subject_id", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.port.SubjectID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "subject_id", scalar_category = "composite", type_name = "SubjectID.1.0", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "service_id", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__ServiceID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.port.ServiceID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "service_id", scalar_category = "composite", type_name = "ServiceID.1.0", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_List_1_0 attributes {c_type_name = "uavcan__node__port__List", doc = "A list of ports that this node is using:\0A- Subjects published by this node (whether periodically or ad-hoc).\0A- Subjects that this node is subscribed to (a datalogger or a debugger would typically subscribe to all subjects).\0A- RPC services consumed by this node (i.e., service clients).\0A- RPC services provided by this node (i.e., service servers).\0A\0AAll nodes should implement this capability to provide network introspection and diagnostic capabilities.\0AThis message should be published using the fixed subject-ID as follows:\0A- At the OPTIONAL priority level at least every MAX_PUBLICATION_PERIOD seconds.\0A- At the OPTIONAL or SLOW priority level within MAX_PUBLICATION_PERIOD after the port configuration is changed.", extent_bits = 67728 : i64, fixed_port_id = 7510 : i64, full_name = "uavcan.node.port.List", header_path = "uavcan/node/port/List_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "publishers", doc = "", name = "publishers", type_name = "SubjectIDList.1.0"}
    dsdl.field {c_name = "subscribers", name = "subscribers", type_name = "SubjectIDList.1.0"}
    dsdl.field {c_name = "clients", name = "clients", type_name = "ServiceIDList.1.0"}
    dsdl.field {c_name = "servers", name = "servers", type_name = "ServiceIDList.1.0"}
    dsdl.constant {doc = "[seconds]\0AIf the port configuration is not updated in this amount of time, the node should publish this message anyway.", name = "MAX_PUBLICATION_PERIOD", type_name = "saturated uint8", value_text = "10"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__List__deserialize_", c_serialize_symbol = "uavcan__node__port__List__serialize_", c_type_name = "uavcan__node__port__List", extent_bits = 67728 : i64, max_bits = 67728 : i64, min_bits = 128 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "publishers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectIDList", composite_extent_bits = 32776 : i64, composite_full_name = "uavcan.node.port.SubjectIDList", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = false, doc = "", kind = "field", max_bits = 32808 : i64, min_bits = 32 : i64, name = "publishers", scalar_category = "composite", type_name = "SubjectIDList.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "subscribers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectIDList", composite_extent_bits = 32776 : i64, composite_full_name = "uavcan.node.port.SubjectIDList", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = false, kind = "field", max_bits = 32808 : i64, min_bits = 32 : i64, name = "subscribers", scalar_category = "composite", type_name = "SubjectIDList.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "clients", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__ServiceIDList", composite_extent_bits = 1024 : i64, composite_full_name = "uavcan.node.port.ServiceIDList", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = false, kind = "field", max_bits = 1056 : i64, min_bits = 32 : i64, name = "clients", scalar_category = "composite", type_name = "ServiceIDList.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "servers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__ServiceIDList", composite_extent_bits = 1024 : i64, composite_full_name = "uavcan.node.port.ServiceIDList", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = false, kind = "field", max_bits = 1056 : i64, min_bits = 32 : i64, name = "servers", scalar_category = "composite", type_name = "ServiceIDList.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_List_0_1 attributes {c_type_name = "uavcan__node__port__List", deprecated, doc = "A list of ports that this node is using:\0A- Subjects published by this node (whether periodically or ad-hoc).\0A- Subjects that this node is subscribed to (a datalogger or a debugger would typically subscribe to all subjects).\0A- RPC services consumed by this node (i.e., service clients).\0A- RPC services provided by this node (i.e., service servers).\0A\0AAll nodes should implement this capability to provide network introspection and diagnostic capabilities.\0AThis message should be published using the fixed subject-ID as follows:\0A- At the OPTIONAL priority level at least every MAX_PUBLICATION_PERIOD seconds.\0A- At the OPTIONAL or SLOW priority level within MAX_PUBLICATION_PERIOD after the port configuration is changed.", extent_bits = 67728 : i64, fixed_port_id = 7510 : i64, full_name = "uavcan.node.port.List", header_path = "uavcan/node/port/List_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "publishers", doc = "", name = "publishers", type_name = "SubjectIDList.0.1"}
    dsdl.field {c_name = "subscribers", name = "subscribers", type_name = "SubjectIDList.0.1"}
    dsdl.field {c_name = "clients", name = "clients", type_name = "ServiceIDList.0.1"}
    dsdl.field {c_name = "servers", name = "servers", type_name = "ServiceIDList.0.1"}
    dsdl.constant {doc = "[seconds]\0AIf the port configuration is not updated in this amount of time, the node should publish this message anyway.", name = "MAX_PUBLICATION_PERIOD", type_name = "saturated uint8", value_text = "10"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__List__deserialize_", c_serialize_symbol = "uavcan__node__port__List__serialize_", c_type_name = "uavcan__node__port__List", extent_bits = 67728 : i64, max_bits = 67728 : i64, min_bits = 128 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "publishers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectIDList", composite_extent_bits = 32776 : i64, composite_full_name = "uavcan.node.port.SubjectIDList", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = false, doc = "", kind = "field", max_bits = 32808 : i64, min_bits = 32 : i64, name = "publishers", scalar_category = "composite", type_name = "SubjectIDList.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "subscribers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectIDList", composite_extent_bits = 32776 : i64, composite_full_name = "uavcan.node.port.SubjectIDList", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = false, kind = "field", max_bits = 32808 : i64, min_bits = 32 : i64, name = "subscribers", scalar_category = "composite", type_name = "SubjectIDList.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "clients", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__ServiceIDList", composite_extent_bits = 1024 : i64, composite_full_name = "uavcan.node.port.ServiceIDList", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = false, kind = "field", max_bits = 1056 : i64, min_bits = 32 : i64, name = "clients", scalar_category = "composite", type_name = "ServiceIDList.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "servers", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__ServiceIDList", composite_extent_bits = 1024 : i64, composite_full_name = "uavcan.node.port.ServiceIDList", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = false, kind = "field", max_bits = 1056 : i64, min_bits = 32 : i64, name = "servers", scalar_category = "composite", type_name = "ServiceIDList.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_ServiceID_1_0 attributes {c_type_name = "uavcan__node__port__ServiceID", doc = "Service-ID. The ranges are defined by the specification.", extent_bits = 16 : i64, full_name = "uavcan.node.port.ServiceID", header_path = "uavcan/node/port/ServiceID_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint9"}
    dsdl.constant {name = "MAX", type_name = "saturated uint9", value_text = "511"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__ServiceID__deserialize_", c_serialize_symbol = "uavcan__node__port__ServiceID__serialize_", c_type_name = "uavcan__node__port__ServiceID", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 9 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 9 : i64, min_bits = 9 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint9", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_ServiceIDList_1_0 attributes {c_type_name = "uavcan__node__port__ServiceIDList", doc = "A list of service identifiers.\0AThis is a trivial constant-size bitmask with some reserved space in case the range of service-ID is increased\0Ain a future revision of the protocol.", extent_bits = 1024 : i64, full_name = "uavcan.node.port.ServiceIDList", header_path = "uavcan/node/port/ServiceIDList_1_0.h", major = 1 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "mask", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", name = "mask", type_name = "bool[CAPACITY]"}
    dsdl.constant {name = "CAPACITY", type_name = "saturated uint16", value_text = "512"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__ServiceIDList__deserialize_", c_serialize_symbol = "uavcan__node__port__ServiceIDList__serialize_", c_type_name = "uavcan__node__port__ServiceIDList", extent_bits = 1024 : i64, fixed_size, max_bits = 512 : i64, min_bits = 512 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 512 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "mask", cast_mode = "saturated", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", kind = "field", max_bits = 512 : i64, min_bits = 512 : i64, name = "mask", scalar_category = "bool", type_name = "bool[CAPACITY]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_ServiceIDList_0_1 attributes {c_type_name = "uavcan__node__port__ServiceIDList", deprecated, doc = "A list of service identifiers.\0AThis is a trivial constant-size bitmask with some reserved space in case the range of service-ID is increased\0Ain a future revision of the protocol.", extent_bits = 1024 : i64, full_name = "uavcan.node.port.ServiceIDList", header_path = "uavcan/node/port/ServiceIDList_0_1.h", major = 0 : i32, minor = 1 : i32} {
    dsdl.field {c_name = "mask", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", name = "mask", type_name = "bool[CAPACITY]"}
    dsdl.constant {name = "CAPACITY", type_name = "saturated uint16", value_text = "512"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__ServiceIDList__deserialize_", c_serialize_symbol = "uavcan__node__port__ServiceIDList__serialize_", c_type_name = "uavcan__node__port__ServiceIDList", extent_bits = 1024 : i64, fixed_size, max_bits = 512 : i64, min_bits = 512 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 512 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "mask", cast_mode = "saturated", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", kind = "field", max_bits = 512 : i64, min_bits = 512 : i64, name = "mask", scalar_category = "bool", type_name = "bool[CAPACITY]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_SubjectID_1_0 attributes {c_type_name = "uavcan__node__port__SubjectID", doc = "Subject-ID. The ranges are defined by the specification.", extent_bits = 16 : i64, full_name = "uavcan.node.port.SubjectID", header_path = "uavcan/node/port/SubjectID_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint13"}
    dsdl.constant {name = "MAX", type_name = "saturated uint13", value_text = "8191"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__SubjectID__deserialize_", c_serialize_symbol = "uavcan__node__port__SubjectID__serialize_", c_type_name = "uavcan__node__port__SubjectID", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 13 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 13 : i64, min_bits = 13 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint13", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_SubjectIDList_1_0 attributes {c_type_name = "uavcan__node__port__SubjectIDList", doc = "A list of subject identifiers.\0AThe range of subject-ID is large, so using a fixed-size bitmask would make this type difficult to handle on\0Aresource-constrained systems. To address that, we provide two extra options: a simple variable-length list,\0Aand a special case that indicates that every subject-ID is in use.", extent_bits = 32776 : i64, full_name = "uavcan.node.port.SubjectIDList", header_path = "uavcan/node/port/SubjectIDList_1_0.h", major = 1 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "mask", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", name = "mask", type_name = "bool[CAPACITY]"}
    dsdl.field {c_name = "sparse_list", doc = "\0AA list of identifiers that can be used instead of the mask if most of the identifiers are unused.", name = "sparse_list", type_name = "SubjectID.1.0[<256]"}
    dsdl.field {c_name = "total", doc = "\0AA special case indicating that all identifiers are in use.", name = "total", type_name = "uavcan.primitive.Empty.1.0"}
    dsdl.constant {name = "CAPACITY", type_name = "saturated uint16", value_text = "8192"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__SubjectIDList__deserialize_", c_serialize_symbol = "uavcan__node__port__SubjectIDList__serialize_", c_type_name = "uavcan__node__port__SubjectIDList", extent_bits = 32776 : i64, is_union, max_bits = 8200 : i64, min_bits = 8 : i64, union_option_count = 3 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 8192 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "mask", cast_mode = "saturated", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", kind = "field", max_bits = 8192 : i64, min_bits = 8192 : i64, name = "mask", scalar_category = "bool", type_name = "bool[CAPACITY]", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 255 : i64, array_kind = "variable_exclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "sparse_list", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.port.SubjectID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AA list of identifiers that can be used instead of the mask if most of the identifiers are unused.", kind = "field", max_bits = 4088 : i64, min_bits = 8 : i64, name = "sparse_list", scalar_category = "composite", type_name = "SubjectID.1.0[<256]", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "total", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Empty", composite_extent_bits = 0 : i64, composite_full_name = "uavcan.primitive.Empty", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AA special case indicating that all identifiers are in use.", kind = "field", max_bits = 0 : i64, min_bits = 0 : i64, name = "total", scalar_category = "composite", type_name = "uavcan.primitive.Empty.1.0", union_option_index = 2 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_node_port_SubjectIDList_0_1 attributes {c_type_name = "uavcan__node__port__SubjectIDList", deprecated, doc = "A list of subject identifiers.\0AThe range of subject-ID is large, so using a fixed-size bitmask would make this type difficult to handle on\0Aresource-constrained systems. To address that, we provide two extra options: a simple variable-length list,\0Aand a special case that indicates that every subject-ID is in use.", extent_bits = 32776 : i64, full_name = "uavcan.node.port.SubjectIDList", header_path = "uavcan/node/port/SubjectIDList_0_1.h", major = 0 : i32, minor = 1 : i32} {
    dsdl.field {c_name = "mask", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", name = "mask", type_name = "bool[CAPACITY]"}
    dsdl.field {c_name = "sparse_list", doc = "\0AA list of identifiers that can be used instead of the mask if most of the identifiers are unused.", name = "sparse_list", type_name = "SubjectID.1.0[<256]"}
    dsdl.field {c_name = "total", doc = "\0AA special case indicating that all identifiers are in use.", name = "total", type_name = "uavcan.primitive.Empty.1.0"}
    dsdl.constant {name = "CAPACITY", type_name = "saturated uint16", value_text = "8192"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__node__port__SubjectIDList__deserialize_", c_serialize_symbol = "uavcan__node__port__SubjectIDList__serialize_", c_type_name = "uavcan__node__port__SubjectIDList", extent_bits = 32776 : i64, is_union, max_bits = 8200 : i64, min_bits = 8 : i64, union_option_count = 3 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 8192 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "mask", cast_mode = "saturated", doc = "The index represents the identifier value. True -- present/used. False -- absent/unused.", kind = "field", max_bits = 8192 : i64, min_bits = 8192 : i64, name = "mask", scalar_category = "bool", type_name = "bool[CAPACITY]", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 255 : i64, array_kind = "variable_exclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "sparse_list", cast_mode = "saturated", composite_c_type_name = "uavcan__node__port__SubjectID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.port.SubjectID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AA list of identifiers that can be used instead of the mask if most of the identifiers are unused.", kind = "field", max_bits = 4088 : i64, min_bits = 8 : i64, name = "sparse_list", scalar_category = "composite", type_name = "SubjectID.1.0[<256]", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "total", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Empty", composite_extent_bits = 0 : i64, composite_full_name = "uavcan.primitive.Empty", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AA special case indicating that all identifiers are in use.", kind = "field", max_bits = 0 : i64, min_bits = 0 : i64, name = "total", scalar_category = "composite", type_name = "uavcan.primitive.Empty.1.0", union_option_index = 2 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_NodeIDAllocationData_2_0 attributes {c_type_name = "uavcan__pnp__NodeIDAllocationData", doc = "In order to be able to operate in a Cyphal network, a node shall have a node-ID that is unique within the network.\0ATypically, a valid node-ID can be configured manually for each node; however, in certain use cases the manual\0Aapproach is either undesirable or impossible, therefore Cyphal defines the high-level feature of plug-and-play\0Anodes that allows nodes to obtain a node-ID value automatically upon connection to the network. When combined\0Awith automatic physical layer configuration (such as auto bit rate detection), this feature allows one to implement\0Anodes that can join a Cyphal network without any prior manual configuration whatsoever. Such nodes are referred to\0Aas \22plug-and-play nodes\22 (or \22PnP nodes\22 for brevity).\0A\0AThe feature is fundamentally non-deterministic and is likely to be unfit for some high-reliability systems;\0Athe designers need to carefully consider the trade-offs involved before deciding to rely on this feature.\0ANormally, static node-ID settings should be preferred.\0A\0AThis feature relies on the concept of \22anonymous message transfers\22, please consult with the Cyphal transport\0Alayer specification for details.\0A\0AThe process of plug-and-play node-ID allocation always involves two types of nodes: \22allocators\22, which serve\0Aallocation requests; and \22allocatees\22, which request PnP node-ID from allocators. A Cyphal network may implement\0Athe following configurations of allocators:\0A\0A  - Zero allocators, in which case plug-and-play node-ID allocation cannot be used, only nodes with statically\0A    configured node-ID can communicate.\0A\0A  - One allocator, in which case the feature of plug-and-play node-ID allocation will become unavailable\0A    if the allocator fails. In this configuration, the role of the allocator can be performed even by a very\0A    resource-constrained system, e.g., a low-end microcontroller.\0A\0A  - Three allocators, in which case the allocators will be using a replicated allocation table via a\0A    distributed consensus algorithm. In this configuration, the network can tolerate the loss of one\0A    allocator and continue to serve allocation requests. This configuration requires the allocators to\0A    maintain large data structures for the needs of the distributed consensus algorithm, and may therefore\0A    require a slightly more sophisticated computational platform, e.g., a high-end microcontroller.\0A\0A  - Five allocators, it is the same as the three allocator configuration reviewed above except that the network\0A    can tolerate the loss of two allocators and still continue to serve allocation requests.\0A\0AIn order to get a PnP node-ID, an allocatee shall have a globally unique 128-bit integer identifier, known as\0Aunique-ID (where \22globally unique\22 means that the probability of having two nodes anywhere in the world that share\0Athe same unique-ID is negligibly low). This is the same value that is used in the field unique_id of the data type\0Auavcan.node.GetInfo. All PnP nodes shall support the service uavcan.node.GetInfo, and they shall use the same\0Aunique-ID value when requesting node-ID allocation and when responding to the GetInfo requests (there may exist\0Aother usages of the unique-ID value, but they lie outside of the scope of the PnP protocol).\0A\0ADuring allocation, the allocatee communicates its unique-ID to the allocator (or allocators in the case of a\0Aredundant allocator configuration), which then use it to produce an appropriate allocation response. Unique-ID\0Avalues are kept by allocators in the \22allocation table\22 - a data structure that contains the mapping between\0Aunique-ID and the corresponding node-ID values. The allocation table is a write-only data structure that can\0Aonly expand. When a new allocatee requests a PnP node-ID, its unique-ID is recorded in the allocation table,\0Aand all subsequent allocation requests from the same allocatee will be served with the same node-ID value.\0A\0AIn configurations with redundant allocators, every allocator maintains a replica of the same allocation table\0A(a Cyphal network cannot contain more than one allocation table, regardless of the number of allocators employed).\0AWhile the allocation table is a write-only data structure that can only grow, it is still possible to wipe the\0Atable completely (as long as it is removed from all redundant allocators on the network simultaneously),\0Aforcing the allocators to forget known nodes and perform all future allocations anew.\0A\0AIn the context of the following description, nodes that use a manually-configured node-ID will be referred to as\0A\22static nodes\22. It is assumed that allocators are always static nodes themselves since there is no other authority\0Aon the network that can grant a PnP node-ID, so allocators are unable to request a PnP node-ID for themselves.\0AExcepting allocators, it is not recommended to mix PnP and static nodes on the same network; i.e., normally,\0Aa Cyphal network should contain either all static nodes, or all PnP nodes (excepting allocators). If this\0Arecommendation cannot be followed, the following rules of safe co-existence of PnP nodes with static nodes should\0Abe adopted:\0A  - It is safe to connect PnP nodes to the bus at any time.\0A  - A static node can be connected to the bus if the allocator (allocators) is (are) already aware of it.\0A    I.e., the static node is already listed in the allocation table.\0A  - A new static node (i.e., a node that does not meet the above criterion) can be connected to the bus only if\0A    no PnP allocation requests are happening at the moment.\0A\0ADue to the possibility of coexistence of static nodes with PnP nodes, allocators are tasked with monitoring\0Athe nodes present in the network. If the allocator detects an online node in the network the node-ID of which is\0Anot found in the allocation table (or the local copy thereof in the case of redundant allocators), the allocator\0Ashall create a new mock entry where the node-ID matches that of the newly detected node and the unique-ID is set to\0Azero (i.e., a 128-bit long sequence of zero bits). This behavior ensures that PnP nodes will never be granted\0Anode-ID values that are already taken by static nodes. Allocators are allowed to request the true unique-ID of the\0Anewly detected nodes by issuing requests uavcan.node.GetInfo instead of using mock zero unique-IDs, but this is not\0Arequired for the sake of simplicity and determinism (some nodes may fail to respond to the GetInfo request, e.g.,\0Aif this service is not supported). Note that in the case of redundant allocators, some of them may be relieved of\0Athis task due to the intrinsic properties of the distributed consensus algorithm; please refer to the documentation\0Afor the data type uavcan.pnp.cluster.AppendEntries for more information.\0A\0AThe unique-ID & node-ID pair of each allocator shall be kept in the allocation table as well. It is allowed to replace\0Athe unique-ID values of allocators with zeros at the discretion of the implementer.\0A\0AAs can be inferred from the above, the process of PnP node-ID allocation involves up to two types of communications:\0A\0A  - \22Allocatee-allocator exchange\22 - this communication is used when an allocatee requests a PnP node-ID from the\0A    allocator (or redundant allocators), and also when the allocator transmits a response back to the allocatee.\0A    This communication is invariant to the allocator configuration used, i.e., the allocatees are not aware of\0A    how many allocators are available on the network and how they are configured. In configurations with\0A    non-redundant (i.e., single) allocator, this is the only type of PnP allocation exchanges.\0A\0A  - \22Allocator-allocator exchange\22 - this communication is used by redundant allocators for the maintenance of\0A    the replicated allocation table and for other needs of the distributed consensus algorithm. Allocatees are\0A    completely isolated and are unaware of these exchanges. This communication is not used with the single-allocator\0A    configuration, since there is only one server and the allocation table is not distributed. The data types\0A    used for the allocator-allocator exchanges are defined in the namespace uavcan.pnp.cluster.\0A\0AAs has been said earlier, the logic used for communication between allocators (for the needs of the maintenance of\0Athe distributed allocation table) is completely unrelated to the allocatees. The allocatees are unaware of these\0Aexchanges, and they are also unaware of the allocator configuration used on the network: single or redundant.\0AAs such, the documentation you're currently reading does not describe the logic and requirements of the\0Aallocator-allocator exchanges for redundant configurations; for that, please refer to the documentation for the\0Adata type uavcan.pnp.cluster.AppendEntries.\0A\0AAllocatee-allocator exchanges are performed using only this message type uavcan.pnp.NodeIDAllocationData. Allocators\0Ause it with regular message transfers; allocatees use it with anonymous message transfers. The specification and\0Ausage info for this data type is provided below.\0A\0AThe general idea of the allocatee-allocator exchanges is that the allocatee communicates to the allocator its\0Aunique-ID and, if applicable, the preferred node-ID value that it would like to have. The allocatee uses\0Aanonymous message transfers of this type. The allocator performs the allocation and sends a response using\0Athe same message type, where the field for unique-ID is populated with the unique-ID of the requesting node\0Aand the field for node-ID is populated with the allocated node-ID. All exchanges from allocatee to allocator use\0Asingle-frame transfers only (see the specification for more information on the limitations of anonymous messages).\0A\0AThe allocatee-allocator exchange logic differs between allocators and allocatees. For allocators, the logic is\0Atrivial: upon reception of a request, the allocator performs an allocation and sends a response back. If the\0Aallocation could not be performed for any reason (e.g., the allocation table is full, or there was a failure),\0Ano response is sent back (i.e., the request is simply ignored); the recommended strategy for the allocatee is to\0Acontinue sending new allocation requests until a response is granted or a higher-level system (e.g., a maintenance\0Atechnician or some automation) intervenes to rectify the problem (e.g., by purging the allocation table).\0AThe allocator that could not complete an allocation for any reason is recommended to emit a diagnostic message\0Awith a human-readable description of the problem. For allocatees, the logic is described below.\0A\0AThis message is used for PnP node-ID allocation on all transports where the maximum transmission unit size is\0Asufficiently large. For low-MTU transports such as Classic CAN there is an older version of the definition (v1)\0Athat takes the low MTU into account (the unique-ID value is replaced with a short hash in order to fit the data\0Ainto one 7-byte-long transfer).\0A\0AGenerally, the randomly chosen values of the request period (Trequest) should be in the range from 0 to 1 seconds.\0AApplications that are not concerned about the allocation time are recommended to pick higher values, as it will\0Areduce interference with other nodes where faster allocations may be desirable. The random interval shall be chosen\0Aanew per transmission, whereas the pseudo node-ID value is allowed to stay constant per node.\0A\0AThe source of random data for Trequest shall be likely to yield different values for participating nodes, avoiding\0Acommon sequences. This implies that the time since boot alone is not a sufficiently robust source of randomness,\0Aas that would be probable to cause nodes powered up at the same time to emit colliding messages repeatedly.\0A\0AThe response timeout is not explicitly defined for this protocol, as the allocatee will request a new allocation\0ATrequest units of time later again, unless an allocation has been granted. Since the request and response messages\0Aare fully idempotent, accidentally repeated messages (e.g., due to benign race conditions that are inherent to this\0Aprotocol) are harmless.\0A\0AOn the allocatee's side the protocol is defined through the following set of rules:\0A\0A  Rule A. On initialization:\0A    1. The allocatee subscribes to this message.\0A    2. The allocatee starts the Request Timer with a random interval of Trequest.\0A\0A  Rule B. On expiration of the Request Timer:\0A    1. Request Timer restarts with a random interval of Trequest (chosen anew).\0A    2. The allocatee broadcasts an allocation request message, where the fields are populated as follows:\0A       node_id   - the preferred node-ID, or the highest valid value if the allocatee doesn't have any preference.\0A       unique_id - the 128-bit unique-ID of the allocatee, same value that is reported via uavcan.node.GetInfo.\0A\0A  Rule C. On an allocation message WHERE (source node-ID is non-anonymous, i.e., regular allocation response)\0A                                   AND   (the field unique_id matches the allocatee's unique-ID):\0A    1. Request Timer stops.\0A    2. The allocatee initializes its node-ID with the received value.\0A    3. The allocatee terminates its subscription to allocation messages.\0A    4. Exit.\0A\0AAs can be seen, the algorithm assumes that the allocatee will continue to emit requests at random intervals\0Auntil an allocation is granted or the allocatee is disconnected.", extent_bits = 384 : i64, fixed_port_id = 8165 : i64, full_name = "uavcan.pnp.NodeIDAllocationData", header_path = "uavcan/pnp/NodeIDAllocationData_2_0.h", major = 2 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "node_id", doc = "If the message transfer is anonymous (i.e., allocation request), this is the preferred ID.\0AIf the message transfer is non-anonymous (i.e., allocation response), this is the allocated ID.\0A\0AIf the allocatee does not have any preference, it should request the highest possible node-ID. Keep in mind that\0Athe two highest node-ID values are reserved for network maintenance tools; requesting those is not prohibited,\0Abut the allocator is recommended to avoid granting these node-ID, using nearest available lower value instead.\0AThe allocator will traverse the allocation table starting from the preferred node-ID upward,\0Auntil a free node-ID is found (or the first ID reserved for network maintenance tools is reached).\0AIf a free node-ID could not be found, the allocator will restart the search from the preferred node-ID\0Adownward, until a free node-ID is found.", name = "node_id", type_name = "uavcan.node.ID.1.0"}
    dsdl.field {c_name = "unique_id", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AThe unique-ID of the allocatee. This is the SAME value that is reported via uavcan.node.GetInfo.\0AThe value is subjected to the same set of constraints; e.g., it can't be changed while the node is running,\0Aand the same value should be unlikely to be used by any two different nodes anywhere in the world.\0A\0AIf this is a non-anonymous transfer (i.e., allocation response), allocatees will match this value against their\0Aown unique-ID, and ignore the message if there is no match. If the IDs match, then the field node_id contains\0Athe allocated node-ID value for this node.", name = "unique_id", type_name = "saturated uint8[16]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__NodeIDAllocationData__deserialize_", c_serialize_symbol = "uavcan__pnp__NodeIDAllocationData__serialize_", c_type_name = "uavcan__pnp__NodeIDAllocationData", extent_bits = 384 : i64, fixed_size, max_bits = 144 : i64, min_bits = 144 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "node_id", cast_mode = "saturated", composite_c_type_name = "uavcan__node__ID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.ID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "If the message transfer is anonymous (i.e., allocation request), this is the preferred ID.\0AIf the message transfer is non-anonymous (i.e., allocation response), this is the allocated ID.\0A\0AIf the allocatee does not have any preference, it should request the highest possible node-ID. Keep in mind that\0Athe two highest node-ID values are reserved for network maintenance tools; requesting those is not prohibited,\0Abut the allocator is recommended to avoid granting these node-ID, using nearest available lower value instead.\0AThe allocator will traverse the allocation table starting from the preferred node-ID upward,\0Auntil a free node-ID is found (or the first ID reserved for network maintenance tools is reached).\0AIf a free node-ID could not be found, the allocator will restart the search from the preferred node-ID\0Adownward, until a free node-ID is found.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "node_id", scalar_category = "composite", type_name = "uavcan.node.ID.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 16 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "unique_id", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0AThe unique-ID of the allocatee. This is the SAME value that is reported via uavcan.node.GetInfo.\0AThe value is subjected to the same set of constraints; e.g., it can't be changed while the node is running,\0Aand the same value should be unlikely to be used by any two different nodes anywhere in the world.\0A\0AIf this is a non-anonymous transfer (i.e., allocation response), allocatees will match this value against their\0Aown unique-ID, and ignore the message if there is no match. If the IDs match, then the field node_id contains\0Athe allocated node-ID value for this node.", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "unique_id", scalar_category = "unsigned", type_name = "saturated uint8[16]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_NodeIDAllocationData_1_0 attributes {c_type_name = "uavcan__pnp__NodeIDAllocationData", doc = "This definition of the allocation message is intended for use with transports where anonymous transfers are limited\0Ato 7 bytes of payload, such as Classic CAN. The definition is carried over from the original UAVCAN v0 specification\0Awith some modifications. For transports other than Classic CAN (e.g., CAN FD, serial, etc.) there is a more\0Ageneral, more capable definition NodeIDAllocationData v2.0. The PnP protocol itself is described in the documentation\0Afor the v2 definition. The documentation provided here builds upon the general case, so read that first please.\0A\0AThe full 128-bit unique-ID can't be accommodated in a single-frame anonymous message transfer over Classic CAN, so\0Athis definition substitutes the full 128-bit ID with a smaller 48-bit hash of it. The 48-bit hash is obtained by\0Aapplying an arbitrary hash function to the unique-ID that outputs at least 48 bit of data. The recommended hash\0Afunction is the standard CRC-64WE where only the lowest 48 bit of the result are used.\0A\0AAllocators that support allocation messages of different versions should maintain a shared allocation table for all.\0ARequests received via the v1 message obviously do not contain the full unique-ID; the allocators are recommended\0Ato left-zero-pad the small 48-bit hash in order to obtain a \22pseudo unique-ID\22, and use this value in the\0Aallocation table as a substitute for the real unique-ID. It is recognized that this behavior will have certain\0Aside effects, such as the same allocatee obtaining different allocated node-ID values depending on which version\0Aof the message is used, but they are considered tolerable.\0A\0AAllocatees that may need to operate over Classic CAN along with high-MTU transports may choose to use\0Aonly this constrained method of allocation for consistency and simplification.\0A\0AIn order to save space for the hash, the preferred node-ID is removed from the request. The allocated node-ID\0Ais provided in the response, however; this is achieved by means of an optional field that is not populated in\0Athe request but is populated in the response. This implies that the response may be a multi-frame transfer,\0Awhich is acceptable since responses are sent by allocators, which are regular nodes, and therefore they are\0Aallowed to use regular message transfers rather than being limited to anonymous message transfers as allocatees are.\0A\0AOn the allocatee's side the protocol is defined through the following set of rules:\0A\0A  Rule A. On initialization:\0A    1. The allocatee subscribes to this message.\0A    2. The allocatee starts the Request Timer with a random interval of Trequest.\0A\0A  Rule B. On expiration of the Request Timer (started as per rules A, B, or C):\0A    1. Request Timer restarts with a random interval of Trequest (chosen anew).\0A    2. The allocatee broadcasts an allocation request message, where the fields are populated as follows:\0A       unique_id_hash    - a 48-bit hash of the unique-ID of the allocatee.\0A       allocated_node_id - empty (not populated).\0A\0A  Rule C. On any allocation message, even if other rules also match:\0A    1. Request Timer restarts with a random interval of Trequest (chosen anew).\0A\0A  Rule D. On an allocation message WHERE (source node-ID is non-anonymous, i.e., regular allocation response)\0A                                   AND   (the field unique_id_hash matches the allocatee's 48-bit unique-ID hash)\0A                                   AND   (the field allocated_node_id is populated):\0A    1. Request Timer stops.\0A    2. The allocatee initializes its node-ID with the received value.\0A    3. The allocatee terminates its subscription to allocation messages.\0A    4. Exit.", extent_bits = 72 : i64, fixed_port_id = 8166 : i64, full_name = "uavcan.pnp.NodeIDAllocationData", header_path = "uavcan/pnp/NodeIDAllocationData_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "unique_id_hash", doc = "An arbitrary 48-bit hash of the unique-ID of the local node.", name = "unique_id_hash", type_name = "truncated uint48"}
    dsdl.field {c_name = "allocated_node_id", doc = "\0AShall be empty in request messages.\0AShall be populated in response messages.", name = "allocated_node_id", type_name = "uavcan.node.ID.1.0[<=1]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__NodeIDAllocationData__deserialize_", c_serialize_symbol = "uavcan__pnp__NodeIDAllocationData__serialize_", c_type_name = "uavcan__pnp__NodeIDAllocationData", extent_bits = 72 : i64, max_bits = 72 : i64, min_bits = 56 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 48 : i64, c_name = "unique_id_hash", cast_mode = "truncated", doc = "An arbitrary 48-bit hash of the unique-ID of the local node.", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "unique_id_hash", scalar_category = "unsigned", type_name = "truncated uint48", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 1 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "allocated_node_id", cast_mode = "saturated", composite_c_type_name = "uavcan__node__ID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.ID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AShall be empty in request messages.\0AShall be populated in response messages.", kind = "field", max_bits = 24 : i64, min_bits = 8 : i64, name = "allocated_node_id", scalar_category = "composite", type_name = "uavcan.node.ID.1.0[<=1]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_cluster_AppendEntries_1_0 attributes {c_type_name = "uavcan__pnp__cluster__AppendEntries", doc = "This type is a part of the Raft consensus algorithm. The Raft consensus is used for the maintenance of the\0Adistributed allocation table between redundant allocators. The following description is focused on the exchanges\0Abetween redundant PnP node-ID allocators. It does not apply to the case of non-redundant allocators, because\0Ain that case the allocation table is stored locally and the process of node-ID allocation is trivial and fully local.\0AExchanges between allocatees and allocators are documented in the appropriate message type definition.\0A\0AThe algorithm used for replication of the allocation table across redundant allocators is a fairly direct\0Aimplementation of the Raft consensus algorithm, as published in the paper\0A\22In Search of an Understandable Consensus Algorithm (Extended Version)\22 by Diego Ongaro and John Ousterhout.\0AThe following text assumes that the reader is familiar with the paper.\0A\0AThe Raft log contains entries of type Entry (in the same namespace), where every entry contains the Raft term\0Anumber, the unique-ID, and the corresponding node-ID value (or zeros if it could not be requested from a static\0Anode). Therefore, the Raft log is the allocation table itself.\0A\0ASince the maximum number of entries in the allocation table is limited by the range of node-ID values, the log\0Acapacity is bounded. Therefore, the snapshot transfer and log compaction functions are not required,\0Aso they are not used in this implementation of the Raft algorithm.\0A\0AWhen an allocator becomes the leader of the Raft cluster, it checks if the Raft log contains an entry for its own\0Anode-ID, and if it doesn't, the leader adds its own allocation entry to the log (the unique-ID can be replaced with\0Azeros at the discretion of the implementer). This behavior guarantees that the Raft log always contains at least\0Aone entry, therefore it is not necessary to support negative log indices, as proposed by the Raft paper.\0A\0ASince the log is write-only and limited in growth, all allocations are permanent. This restriction is acceptable,\0Asince Cyphal is a vehicle bus, and configuration of vehicle's components is not expected to change frequently.\0AOld allocations can be removed in order to free node-IDs for new allocations by clearing the Raft log on all\0Aallocators; such clearing shall be performed simultaneously while the network is down, otherwise the Raft cluster\0Awill automatically attempt to restore the lost state on the allocators where the table was cleared.\0A\0AThe allocators need to be aware of each other's node-ID in order to form a cluster. In order to learn each other's\0Anode-ID values, the allocators broadcast messages of type Discovery (in the same namespace) until the cluster is\0Afully discovered and all allocators know of each other's node-ID. This extension to the Raft algorithm makes the\0Acluster almost configuration-free - the only parameter that shall be configured on all allocators of the cluster\0Ais the number of nodes in the cluster (everything else will be auto-detected).\0A\0ARuntime cluster membership changes are not supported, since they are not needed for a vehicle bus.\0A\0AAs has been explained in the general description of the PnP node-ID allocation feature, allocators shall watch for\0Aunknown static nodes appearing on the bus. In the case of a non-redundant allocator, the task is trivial, since the\0Aallocation table can be updated locally. In the case of a Raft cluster, however, the network monitoring task shall\0Abe performed by the leader only, since other cluster members cannot commit to the shared allocation table (i.e.,\0Athe Raft log) anyway. Redundant allocators should not attempt to obtain the true unique-ID of the newly detected\0Astatic nodes (use zeros instead), because the allocation table is write-only: if the unique-ID of a static node\0Aever changes (e.g., a replacement unit is installed, or network configuration is changed manually), the change\0Awill be impossible to reflect in the allocation table.\0A\0AOnly the current Raft leader can process allocation requests and engage in communication with allocatees.\0AAn allocator is allowed to send allocation responses only if both conditions are met:\0A\0A  - The allocator is currently the Raft leader.\0A  - Its replica of the Raft log does not contain uncommitted entries (i.e. the last allocation request has been\0A    completed successfully).\0A\0AAll cluster maintenance traffic should normally use either the lowest or the next-to-lowest transfer priority level.", extent_bits = 768 : i64, fixed_port_id = 390 : i64, full_name = "uavcan.pnp.cluster.AppendEntries", header_path = "uavcan/pnp/cluster/AppendEntries_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "term", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A", name = "term", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "prev_log_term", name = "prev_log_term", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "prev_log_index", name = "prev_log_index", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "leader_commit", doc = "Refer to the Raft paper for explanation.", name = "leader_commit", section = "request", type_name = "saturated uint16"}
    dsdl.field {c_name = "entries", doc = "\0AWorst case replication time per Follower can be computed as:\0A\0A  worst replication time = (node-ID capacity) * (2 trips of next_index) * (request interval per Follower)\0A\0AE.g., given the request interval of 0.5 seconds, the worst case replication time for CAN bus is:\0A\0A  128 nodes * 2 trips * 0.5 seconds = 128 seconds.\0A\0AThis is the amount of time it will take for a new Follower to reconstruct a full replica of the distributed log.", name = "entries", section = "request", type_name = "Entry.1.0[<=1]"}
    dsdl.constant {doc = "[second]", name = "DEFAULT_MIN_ELECTION_TIMEOUT", section = "request", type_name = "saturated uint8", value_text = "2"}
    dsdl.constant {doc = "[second]\0AGiven the minimum election timeout and the cluster size,\0Athe maximum recommended request interval can be derived as follows:\0A\0A  max recommended request interval = (min election timeout) / 2 requests / (cluster size - 1)\0A\0AThe equation assumes that the Leader requests one Follower at a time, so that there's at most one pending call\0Aat any moment. Such behavior is optimal as it creates a uniform bus load, although it is implementation-specific.\0AObviously, the request interval can be lower than that if needed, but higher values are not recommended as they may\0Acause Followers to initiate premature elections in case of frame losses or delays.\0A\0AThe timeout value is randomized in the range (MIN, MAX], according to the Raft paper. The randomization granularity\0Ashould be at least one millisecond or higher.", name = "DEFAULT_MAX_ELECTION_TIMEOUT", section = "request", type_name = "saturated uint8", value_text = "4"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__AppendEntries__Request__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__AppendEntries__Request__serialize_", c_type_name = "uavcan__pnp__cluster__AppendEntries__Request", extent_bits = 768 : i64, max_bits = 280 : i64, min_bits = 104 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "term", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "prev_log_term", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "prev_log_term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "prev_log_index", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "prev_log_index", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "leader_commit", cast_mode = "saturated", doc = "Refer to the Raft paper for explanation.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "leader_commit", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 1 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "entries", cast_mode = "saturated", composite_c_type_name = "uavcan__pnp__cluster__Entry", composite_extent_bits = 176 : i64, composite_full_name = "uavcan.pnp.cluster.Entry", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0AWorst case replication time per Follower can be computed as:\0A\0A  worst replication time = (node-ID capacity) * (2 trips of next_index) * (request interval per Follower)\0A\0AE.g., given the request interval of 0.5 seconds, the worst case replication time for CAN bus is:\0A\0A  128 nodes * 2 trips * 0.5 seconds = 128 seconds.\0A\0AThis is the amount of time it will take for a new Follower to reconstruct a full replica of the distributed log.", kind = "field", max_bits = 184 : i64, min_bits = 8 : i64, name = "entries", scalar_category = "composite", type_name = "Entry.1.0[<=1]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "term", name = "term", section = "response", type_name = "saturated uint32"}
    dsdl.field {c_name = "success", doc = "Refer to the Raft paper for explanation.", name = "success", section = "response", type_name = "bool"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__AppendEntries__Response__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__AppendEntries__Response__serialize_", c_type_name = "uavcan__pnp__cluster__AppendEntries__Response", extent_bits = 384 : i64, fixed_size, max_bits = 40 : i64, min_bits = 40 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "term", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "success", cast_mode = "saturated", doc = "Refer to the Raft paper for explanation.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "success", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_cluster_Discovery_1_0 attributes {c_type_name = "uavcan__pnp__cluster__Discovery", doc = "This message is used by redundant allocators to find each other's node-ID.\0APlease refer to the type AppendEntries for details.\0A\0AAn allocator should stop publishing this message as soon as it has discovered all other allocators in the cluster.\0A\0AAn exception applies: when an allocator receives a Discovery message where the list of known nodes is incomplete\0A(i.e. len(known_nodes) < configured_cluster_size), it shall publish a Discovery message once. This condition\0Aallows other allocators to quickly re-discover the cluster after a restart.", extent_bits = 768 : i64, fixed_port_id = 8164 : i64, full_name = "uavcan.pnp.cluster.Discovery", header_path = "uavcan/pnp/cluster/Discovery_1_0.h", major = 1 : i32, minor = 0 : i32} {
    dsdl.field {c_name = "configured_cluster_size", doc = "\0AThe number of allocators in the cluster as configured on the sender.\0AThis value shall be the same across all allocators.", name = "configured_cluster_size", type_name = "saturated uint3"}
    dsdl.field {c_name = "_", doc = "\0A", name = "", padding, type_name = "void5"}
    dsdl.field {c_name = "known_nodes", doc = "Node-IDs of the allocators that are known to the publishing allocator, including the publishing allocator itself.", name = "known_nodes", type_name = "uavcan.node.ID.1.0[<=5]"}
    dsdl.constant {doc = "[second]\0AThis message should be broadcasted by the allocator at this interval until all other allocators are discovered.", name = "BROADCASTING_PERIOD", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "\0AThe redundant allocator cluster cannot contain more than 5 allocators.", name = "MAX_CLUSTER_SIZE", type_name = "saturated uint3", value_text = "5"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__Discovery__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__Discovery__serialize_", c_type_name = "uavcan__pnp__cluster__Discovery", extent_bits = 768 : i64, max_bits = 96 : i64, min_bits = 16 : i64} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 3 : i64, c_name = "configured_cluster_size", cast_mode = "saturated", doc = "\0AThe number of allocators in the cluster as configured on the sender.\0AThis value shall be the same across all allocators.", kind = "field", max_bits = 3 : i64, min_bits = 3 : i64, name = "configured_cluster_size", scalar_category = "unsigned", type_name = "saturated uint3", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 5 : i64, c_name = "_", cast_mode = "saturated", doc = "\0A", kind = "padding", max_bits = 5 : i64, min_bits = 5 : i64, name = "", scalar_category = "void", type_name = "void5", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 5 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 0 : i64, c_name = "known_nodes", cast_mode = "saturated", composite_c_type_name = "uavcan__node__ID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.ID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Node-IDs of the allocators that are known to the publishing allocator, including the publishing allocator itself.", kind = "field", max_bits = 88 : i64, min_bits = 8 : i64, name = "known_nodes", scalar_category = "composite", type_name = "uavcan.node.ID.1.0[<=5]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_cluster_Entry_1_0 attributes {c_type_name = "uavcan__pnp__cluster__Entry", doc = "One PnP node-ID allocation entry.\0AThis type is a part of the Raft consensus algorithm. Please refer to the type AppendEntries for details.", extent_bits = 176 : i64, full_name = "uavcan.pnp.cluster.Entry", header_path = "uavcan/pnp/cluster/Entry_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "term", doc = "Refer to the Raft paper for explanation.", name = "term", type_name = "saturated uint32"}
    dsdl.field {c_name = "unique_id", doc = "Unique-ID of this allocation; zero if unknown.", name = "unique_id", type_name = "saturated uint8[16]"}
    dsdl.field {c_name = "node_id", doc = "Node-ID of this allocation.", name = "node_id", type_name = "uavcan.node.ID.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__Entry__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__Entry__serialize_", c_type_name = "uavcan__pnp__cluster__Entry", extent_bits = 176 : i64, fixed_size, max_bits = 176 : i64, min_bits = 176 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "term", cast_mode = "saturated", doc = "Refer to the Raft paper for explanation.", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 16 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "unique_id", cast_mode = "saturated", doc = "Unique-ID of this allocation; zero if unknown.", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "unique_id", scalar_category = "unsigned", type_name = "saturated uint8[16]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "node_id", cast_mode = "saturated", composite_c_type_name = "uavcan__node__ID", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.node.ID", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Node-ID of this allocation.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "node_id", scalar_category = "composite", type_name = "uavcan.node.ID.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_pnp_cluster_RequestVote_1_0 attributes {c_type_name = "uavcan__pnp__cluster__RequestVote", doc = "This type is a part of the Raft consensus algorithm. Please refer to the type AppendEntries for details.", extent_bits = 384 : i64, fixed_port_id = 391 : i64, full_name = "uavcan.pnp.cluster.RequestVote", header_path = "uavcan/pnp/cluster/RequestVote_1_0.h", major = 1 : i32, minor = 0 : i32, service} {
    dsdl.field {c_name = "term", name = "term", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "last_log_term", name = "last_log_term", section = "request", type_name = "saturated uint32"}
    dsdl.field {c_name = "last_log_index", doc = "Refer to the Raft paper for explanation.", name = "last_log_index", section = "request", type_name = "saturated uint16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__RequestVote__Request__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__RequestVote__Request__serialize_", c_type_name = "uavcan__pnp__cluster__RequestVote__Request", extent_bits = 384 : i64, fixed_size, max_bits = 80 : i64, min_bits = 80 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "term", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "last_log_term", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "last_log_term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "last_log_index", cast_mode = "saturated", doc = "Refer to the Raft paper for explanation.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "last_log_index", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "term", name = "term", section = "response", type_name = "saturated uint32"}
    dsdl.field {c_name = "vote_granted", doc = "Refer to the Raft paper for explanation.", name = "vote_granted", section = "response", type_name = "bool"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__pnp__cluster__RequestVote__Response__deserialize_", c_serialize_symbol = "uavcan__pnp__cluster__RequestVote__Response__serialize_", c_type_name = "uavcan__pnp__cluster__RequestVote__Response", extent_bits = 384 : i64, fixed_size, max_bits = 40 : i64, min_bits = 40 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "term", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "term", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "vote_granted", cast_mode = "saturated", doc = "Refer to the Raft paper for explanation.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "vote_granted", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_Empty_1_0 attributes {c_type_name = "uavcan__primitive__Empty", extent_bits = 0 : i64, full_name = "uavcan.primitive.Empty", header_path = "uavcan/primitive/Empty_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__Empty__deserialize_", c_serialize_symbol = "uavcan__primitive__Empty__serialize_", c_type_name = "uavcan__primitive__Empty", extent_bits = 0 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
    }
  }
  dsdl.schema @uavcan_primitive_String_1_0 attributes {c_type_name = "uavcan__primitive__String", doc = "A UTF8-encoded string of text.\0ASince the string is represented as a dynamic array of bytes, it is not null-terminated. Like Pascal string.", extent_bits = 2064 : i64, full_name = "uavcan.primitive.String", header_path = "uavcan/primitive/String_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint8[<=256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__String__deserialize_", c_serialize_symbol = "uavcan__primitive__String__serialize_", c_type_name = "uavcan__primitive__String", extent_bits = 2064 : i64, max_bits = 2064 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint8[<=256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_Unstructured_1_0 attributes {c_type_name = "uavcan__primitive__Unstructured", doc = "An unstructured collection of bytes, e.g., raw binary image.", extent_bits = 2064 : i64, full_name = "uavcan.primitive.Unstructured", header_path = "uavcan/primitive/Unstructured_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint8[<=256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__Unstructured__deserialize_", c_serialize_symbol = "uavcan__primitive__Unstructured__serialize_", c_type_name = "uavcan__primitive__Unstructured", extent_bits = 2064 : i64, max_bits = 2064 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint8[<=256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Bit_1_0 attributes {c_type_name = "uavcan__primitive__array__Bit", doc = "2048 bits + 11 bit length + 4 bit padding = 2064 bits = 258 bytes", extent_bits = 2064 : i64, full_name = "uavcan.primitive.array.Bit", header_path = "uavcan/primitive/array/Bit_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "bool[<=2048]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Bit__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Bit__serialize_", c_type_name = "uavcan__primitive__array__Bit", extent_bits = 2064 : i64, max_bits = 2064 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 2048 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 1 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "value", scalar_category = "bool", type_name = "bool[<=2048]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Integer16_1_0 attributes {c_type_name = "uavcan__primitive__array__Integer16", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Integer16", header_path = "uavcan/primitive/array/Integer16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int16[<=128]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Integer16__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Integer16__serialize_", c_type_name = "uavcan__primitive__array__Integer16", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 128 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "signed", type_name = "saturated int16[<=128]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Integer32_1_0 attributes {c_type_name = "uavcan__primitive__array__Integer32", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Integer32", header_path = "uavcan/primitive/array/Integer32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int32[<=64]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Integer32__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Integer32__serialize_", c_type_name = "uavcan__primitive__array__Integer32", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 64 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "signed", type_name = "saturated int32[<=64]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Integer64_1_0 attributes {c_type_name = "uavcan__primitive__array__Integer64", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Integer64", header_path = "uavcan/primitive/array/Integer64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int64[<=32]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Integer64__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Integer64__serialize_", c_type_name = "uavcan__primitive__array__Integer64", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 32 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "signed", type_name = "saturated int64[<=32]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Integer8_1_0 attributes {c_type_name = "uavcan__primitive__array__Integer8", extent_bits = 2064 : i64, full_name = "uavcan.primitive.array.Integer8", header_path = "uavcan/primitive/array/Integer8_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int8[<=256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Integer8__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Integer8__serialize_", c_type_name = "uavcan__primitive__array__Integer8", extent_bits = 2064 : i64, max_bits = 2064 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "value", scalar_category = "signed", type_name = "saturated int8[<=256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Natural16_1_0 attributes {c_type_name = "uavcan__primitive__array__Natural16", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Natural16", header_path = "uavcan/primitive/array/Natural16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint16[<=128]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Natural16__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Natural16__serialize_", c_type_name = "uavcan__primitive__array__Natural16", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 128 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint16[<=128]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Natural32_1_0 attributes {c_type_name = "uavcan__primitive__array__Natural32", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Natural32", header_path = "uavcan/primitive/array/Natural32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint32[<=64]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Natural32__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Natural32__serialize_", c_type_name = "uavcan__primitive__array__Natural32", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 64 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint32[<=64]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Natural64_1_0 attributes {c_type_name = "uavcan__primitive__array__Natural64", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Natural64", header_path = "uavcan/primitive/array/Natural64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint64[<=32]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Natural64__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Natural64__serialize_", c_type_name = "uavcan__primitive__array__Natural64", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 32 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint64[<=32]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Natural8_1_0 attributes {c_type_name = "uavcan__primitive__array__Natural8", extent_bits = 2064 : i64, full_name = "uavcan.primitive.array.Natural8", header_path = "uavcan/primitive/array/Natural8_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint8[<=256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Natural8__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Natural8__serialize_", c_type_name = "uavcan__primitive__array__Natural8", extent_bits = 2064 : i64, max_bits = 2064 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 256 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 16 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint8[<=256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Real16_1_0 attributes {c_type_name = "uavcan__primitive__array__Real16", doc = "Exactly representable integers: [-2048, +2048]", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Real16", header_path = "uavcan/primitive/array/Real16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated float16[<=128]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Real16__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Real16__serialize_", c_type_name = "uavcan__primitive__array__Real16", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 128 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "float", type_name = "saturated float16[<=128]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Real32_1_0 attributes {c_type_name = "uavcan__primitive__array__Real32", doc = "Exactly representable integers: [-16777216, +16777216]", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Real32", header_path = "uavcan/primitive/array/Real32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated float32[<=64]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Real32__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Real32__serialize_", c_type_name = "uavcan__primitive__array__Real32", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 64 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "float", type_name = "saturated float32[<=64]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_array_Real64_1_0 attributes {c_type_name = "uavcan__primitive__array__Real64", doc = "Exactly representable integers: [-2**53, +2**53]", extent_bits = 2056 : i64, full_name = "uavcan.primitive.array.Real64", header_path = "uavcan/primitive/array/Real64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated float64[<=32]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__array__Real64__deserialize_", c_serialize_symbol = "uavcan__primitive__array__Real64__serialize_", c_type_name = "uavcan__primitive__array__Real64", extent_bits = 2056 : i64, max_bits = 2056 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 32 : i64, array_kind = "variable_inclusive", array_length_prefix_bits = 8 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "value", scalar_category = "float", type_name = "saturated float64[<=32]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Bit_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Bit", extent_bits = 8 : i64, full_name = "uavcan.primitive.scalar.Bit", header_path = "uavcan/primitive/scalar/Bit_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "bool"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Bit__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Bit__serialize_", c_type_name = "uavcan__primitive__scalar__Bit", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "value", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Integer16_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Integer16", extent_bits = 16 : i64, full_name = "uavcan.primitive.scalar.Integer16", header_path = "uavcan/primitive/scalar/Integer16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Integer16__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Integer16__serialize_", c_type_name = "uavcan__primitive__scalar__Integer16", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "signed", type_name = "saturated int16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Integer32_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Integer32", extent_bits = 32 : i64, full_name = "uavcan.primitive.scalar.Integer32", header_path = "uavcan/primitive/scalar/Integer32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Integer32__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Integer32__serialize_", c_type_name = "uavcan__primitive__scalar__Integer32", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "value", scalar_category = "signed", type_name = "saturated int32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Integer64_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Integer64", extent_bits = 64 : i64, full_name = "uavcan.primitive.scalar.Integer64", header_path = "uavcan/primitive/scalar/Integer64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Integer64__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Integer64__serialize_", c_type_name = "uavcan__primitive__scalar__Integer64", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "value", scalar_category = "signed", type_name = "saturated int64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Integer8_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Integer8", extent_bits = 8 : i64, full_name = "uavcan.primitive.scalar.Integer8", header_path = "uavcan/primitive/scalar/Integer8_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated int8"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Integer8__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Integer8__serialize_", c_type_name = "uavcan__primitive__scalar__Integer8", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "value", scalar_category = "signed", type_name = "saturated int8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Natural16_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Natural16", extent_bits = 16 : i64, full_name = "uavcan.primitive.scalar.Natural16", header_path = "uavcan/primitive/scalar/Natural16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Natural16__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Natural16__serialize_", c_type_name = "uavcan__primitive__scalar__Natural16", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Natural32_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Natural32", extent_bits = 32 : i64, full_name = "uavcan.primitive.scalar.Natural32", header_path = "uavcan/primitive/scalar/Natural32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Natural32__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Natural32__serialize_", c_type_name = "uavcan__primitive__scalar__Natural32", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Natural64_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Natural64", extent_bits = 64 : i64, full_name = "uavcan.primitive.scalar.Natural64", header_path = "uavcan/primitive/scalar/Natural64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Natural64__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Natural64__serialize_", c_type_name = "uavcan__primitive__scalar__Natural64", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Natural8_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Natural8", extent_bits = 8 : i64, full_name = "uavcan.primitive.scalar.Natural8", header_path = "uavcan/primitive/scalar/Natural8_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "saturated uint8"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Natural8__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Natural8__serialize_", c_type_name = "uavcan__primitive__scalar__Natural8", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 8 : i64, c_name = "value", cast_mode = "saturated", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "value", scalar_category = "unsigned", type_name = "saturated uint8", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Real16_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Real16", extent_bits = 16 : i64, full_name = "uavcan.primitive.scalar.Real16", header_path = "uavcan/primitive/scalar/Real16_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", doc = "Exactly representable integers: [-2048, +2048]", name = "value", type_name = "saturated float16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Real16__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Real16__serialize_", c_type_name = "uavcan__primitive__scalar__Real16", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "value", cast_mode = "saturated", doc = "Exactly representable integers: [-2048, +2048]", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "value", scalar_category = "float", type_name = "saturated float16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Real32_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Real32", extent_bits = 32 : i64, full_name = "uavcan.primitive.scalar.Real32", header_path = "uavcan/primitive/scalar/Real32_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", doc = "Exactly representable integers: [-16777216, +16777216]", name = "value", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Real32__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Real32__serialize_", c_type_name = "uavcan__primitive__scalar__Real32", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "value", cast_mode = "saturated", doc = "Exactly representable integers: [-16777216, +16777216]", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "value", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_primitive_scalar_Real64_1_0 attributes {c_type_name = "uavcan__primitive__scalar__Real64", extent_bits = 64 : i64, full_name = "uavcan.primitive.scalar.Real64", header_path = "uavcan/primitive/scalar/Real64_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "value", doc = "Exactly representable integers: [-2**53, +2**53]", name = "value", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__primitive__scalar__Real64__deserialize_", c_serialize_symbol = "uavcan__primitive__scalar__Real64__serialize_", c_type_name = "uavcan__primitive__scalar__Real64", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "value", cast_mode = "saturated", doc = "Exactly representable integers: [-2**53, +2**53]", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "value", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_register_Access_1_0 attributes {c_type_name = "uavcan__register___Access", doc = "Registers are strongly-typed named values used to store the configuration parameters of a node.\0AThis service is used to write and read a register.\0A\0A\0A  READ/WRITE BEHAVIORS\0A\0AThe write operation is performed first, unless skipped by sending an empty value in the request.\0AThe server may attempt to convert the type of the supplied value to the correct type if there is a type mismatch\0A(e.g. uint8 may be converted to uint16); however, servers are not required to perform implicit type conversion,\0Aand the rules of such conversion are not explicitly specified, so this behavior should not be relied upon.\0A\0AOn the next step the register will be read regardless of the outcome of the write operation. As such, if the write\0Aoperation could not be performed (e.g. due to a type mismatch or any other issue), the register will retain its old\0Avalue. By evaluating the response the caller can determine whether the register was written successfully.\0A\0AThe write-read sequence is not guaranteed to be atomic, meaning that external influences may cause the register to\0Achange its value between the write and the subsequent read operation. The caller is responsible for handling that\0Acase properly.\0A\0AThe timestamp provided in the response corresponds to the time when the register was read. The timestamp may\0Abe empty if the server does not support timestamping or its clock is not (yet) synchronized with the network.\0A\0AIf only read is desired, but not write, the caller shall provide a value of type 'empty'. That will signal the server\0Athat the write operation shall be skipped, and it will proceed to read the register immediately.\0A\0AIf the requested register does not exist, the write operation will have no effect and the returned value will be\0Aempty. Existing registers should not return 'empty' when read since that would make them indistinguishable from\0Anonexistent registers.\0A\0A\0A  REGISTER DEFINITION REQUIREMENTS\0A\0ARegisters shall never change their type or flags as long as the server is running. Meaning that:\0A  - Mutability and persistence flags cannot change their states.\0A  - Read operations shall always return values of the same type and same dimensionality.\0A    The dimensionality requirement does not apply to inherently variable-length values such as strings and\0A    unstructured chunks.\0A\0ARegister name should contain only:\0A  - Lowercase ASCII alphanumeric characters (a-z, 0-9)\0A  - Full stop (.)\0A  - Low line (underscore) (_)\0AWith the following limitations/recommendations:\0A  - The name shall not begin with a decimal digit (0-9).\0A  - The name shall neither begin nor end with a full stop.\0A  - A low line shall not be followed by a non-alphanumeric character.\0A  - The name should contain at least one full stop character.\0AOther patterns and ASCII characters are reserved for special function registers (introduced below).\0A\0A\0A  ENVIRONMENT VARIABLES\0A\0AThis section applies only to software nodes executed in a high-level operating system that supports environment\0Avariables or an equivalent mechanism.\0A\0AWhen a software node is launched, it is usually necessary to provide some of its configuration information early,\0Aparticularly that which is related to Cyphal networking, before the node is started. Environment variables offer\0Aa convenient way of addressing this. Software nodes that support the register interface should evaluate the\0Aavailable environment variables during initialization and update their registers (whether they are stored in\0Aa persistent storage or in memory) accoringly. This should be completed before the first register read access.\0A\0AA register name is mapped to an environment variable name as follows:\0A  - the name is upper-cased;\0A  - full stop characters are replaced with double low line characters.\0AFor example: 'motor.inductance_dq' is mapped to 'MOTOR__INDUCTANCE_DQ'.\0A\0ARegister values are represented in environment variables as follows:\0A  - string:                         utf-8 or platform-specific\0A  - unstructured:                   as-is\0A  - bit, integer*, natural*, real*: space-separated decimals\0A\0AIf an environment variable matches the name of an existing register but its value cannot be converted to the\0Aregister's type, an error should be raised.\0A\0AIf an environment variable does not match the name of any register, it may be ignored. However, if the implementation\0Acan reliably deduce the type and purpose of the register, it may create one automatically. This provision is to\0Asupport applications where the register schema may be altered by configuration.\0A\0A\0A  SPECIAL FUNCTION REGISTERS\0A\0AThe following optional special function register names are defined:\0A  - suffix '<' is used to define an immutable persistent value that contains the maximum value\0A    of the respective register.\0A  - suffix '>' is like above, used to define the minimum value of the respective register.\0A  - suffix '=' is like above, used to define the default value of the respective register.\0A  - prefix '*' is reserved for raw memory access (to be defined later).\0AExamples:\0A  - register name \22system.parameter\22\0A  - maximum value is contained in the register named \22system.parameter<\22 (optional)\0A  - minimum value is contained in the register named \22system.parameter>\22 (optional)\0A  - default value is contained in the register named \22system.parameter=\22 (optional)\0A\0AThe type and dimensionality of the special function registers containing the minimum, maximum, and the default\0Avalue of a register shall be the same as those of the register they relate to.\0A\0AIf a written value exceeds the minimum/maximum specified by the respective special function registers,\0Athe server may either adjust the value automatically, or to retain the old value, depending on which behavior\0Asuits the objectives of the application better.\0AThe values of registers containing non-scalar numerical entities should be compared elementwise.\0A\0A\0A  STANDARD REGISTERS\0A\0AThe following table specifies the register name patterns that are reserved by the specification for\0Acommon functions. These conventions are not mandatory to follow, but implementers are recommended to adhere because\0Athey enable enhanced introspection capabilities and simplify device configuration and diagnostics.\0A\0A  REGISTER NAME PATTERN                               TYPE            FLAGS                   RECOMMENDED DEFAULT\0A=====================================================================================================================\0A\0A  uavcan.node.id                                      natural16[1]    mutable, persistent     65535 (unset/PnP)\0A\0AContains the node-ID of the local node. Values above the maximum valid node-ID for the current transport\0Aindicate that the node-ID is not set; if plug-and-play is supported, it will be used by the node to obtain an\0Aautomatic node-ID. Invalid values other than 65535 should be avoided for consistency.\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.node.description                             string          mutable, persistent     (empty)\0A\0AUser/integrator-defined, human-readable description of this specific node.\0AThis is intended for use by a system integrator and should not be set by the manufacturer of a component.\0AFor example: on a quad-rotor drone this might read \22motor 2\22 for one of the ESC nodes.\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.pub.PORT_NAME.id                             natural16[1]    mutable, persistent     65535 (unset, invalid)\0A  uavcan.sub.PORT_NAME.id                             ditto           ditto                   ditto\0A  uavcan.cln.PORT_NAME.id                             ditto           ditto                   ditto\0A  uavcan.srv.PORT_NAME.id                             ditto           ditto                   ditto\0A\0APublication/subscription/client/server port-ID, respectively. These registers are configured by the system integrator\0Aor an autoconfiguration authority when the node is first connected to a network.\0A\0AThe \22PORT_NAME\22 defines the human-friendly name of the port, which is related to the corresponding function\0Aor a network service supported by the node. The name shall match the following POSIX ERE expression:\0A\0A  [a-zA-Z_][a-zA-Z0-9_.]*\0A\0AThe names are defined by the vendor of the node. The user/integrator is expected to understand their meaning and\0Arelation to the functional capabilities of the node by reading the technical documentation provided by the vendor.\0A\0AA port whose port-ID register is unset (invalid value) remains inactive (unused); the corresponding function may\0Abe disabled. For example, a register named \22uavcan.pub.measurement.id\22 defines the subject-ID of a measurement\0Apublished by this node; if the register contains an invalid value (above the maximum valid subject-ID),\0Asaid measurement is not published.\0A\0AThe same name is used in other similar registers defined below. Network introspection and autoconfiguration tools\0Awill expect to find a register of this form for every configurable port supported by the node.\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.pub.PORT_NAME.type                           string          immutable, persistent   N/A\0A  uavcan.sub.PORT_NAME.type                           ditto           ditto                   ditto\0A  uavcan.cln.PORT_NAME.type                           ditto           ditto                   ditto\0A  uavcan.srv.PORT_NAME.type                           ditto           ditto                   ditto\0A\0APublication/subscription/client/server full data type name and dot-separated version numbers, respectively.\0AThese registers are set by the vendor once and typically they are to remain unchanged (hence \22immutable\22).\0AThe \22PORT_NAME\22 defines the human-friendly name of the port as specified above.\0AFor example, a register named \22uavcan.pub.measurement.type\22 may contain \22uavcan.si.sample.angle.Quaternion.1.0\22.\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.diagnostic.*\0A\0APrefix reserved for future use.\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.can.bitrate                                  natural32[2]    implementation-defined  implementation-defined\0A  uavcan.can.iface                                    string          mutable, persistent     implementation-defined\0A\0AThese registers are only relevant for nodes that support Cyphal/CAN.\0A\0Auavcan.can.bitrate defines the CAN bus bit rate: the first value is the arbitration bit rate, the second is the\0Adata phase bit rate. Nodes that support only Classic CAN should ignore the second value. Nodes that support CAN FD\0Ashould initialize in the Classic CAN mode (MTU 8 bytes, BRS flag not set) if the values are equal. If CAN bitrate\0Ais not configurable or is always auto-detected, this register may be omitted or made immutable; otherwise it should\0Abe mutable and persistent.\0A\0Auavcan.can.iface is only relevant for software nodes or nodes that are capable of using different CAN interfaces.\0AThe value is a space-separated list of CAN interface names to use. The name format is implementation-defined\0A(for example, \22can0\22).\0A\0A---------------------------------------------------------------------------------------------------------------------\0A\0A  uavcan.udp.*\0A\0APrefix reserved for future use.\0A\0A---------------------------------------------------------------------------------------------------------------------#\0A\0A  uavcan.serial.*\0A\0APrefix reserved for future use.\0A\0A---------------------------------------------------------------------------------------------------------------------", extent_bits = 4120 : i64, fixed_port_id = 384 : i64, full_name = "uavcan.register.Access", header_path = "uavcan/register/Access_1_0.h", major = 1 : i32, minor = 0 : i32, sealed, service} {
    dsdl.field {c_name = "name", doc = "The name of the accessed register. Shall not be empty.\0AUse the List service to obtain the list of registers on the node.", name = "name", section = "request", type_name = "Name.1.0"}
    dsdl.field {c_name = "value", doc = "\0A\0AValue to be written. Empty if no write is required.", name = "value", section = "request", type_name = "Value.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___Access__Request__deserialize_", c_serialize_symbol = "uavcan__register___Access__Request__serialize_", c_type_name = "uavcan__register___Access__Request", extent_bits = 4120 : i64, max_bits = 4120 : i64, min_bits = 16 : i64, sealed, section = "request"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "name", cast_mode = "saturated", composite_c_type_name = "uavcan__register___Name", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.register.Name", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The name of the accessed register. Shall not be empty.\0AUse the List service to obtain the list of registers on the node.", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "name", scalar_category = "composite", type_name = "Name.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "value", cast_mode = "saturated", composite_c_type_name = "uavcan__register___Value", composite_extent_bits = 2072 : i64, composite_full_name = "uavcan.register.Value", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "\0A\0AValue to be written. Empty if no write is required.", kind = "field", max_bits = 2072 : i64, min_bits = 8 : i64, name = "value", scalar_category = "composite", type_name = "Value.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "timestamp", doc = "The moment of time when the register was read (not written).\0AZero if the server does not support timestamping.", name = "timestamp", section = "response", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "mutable", doc = "\0A\0AMutable means that the register can be written using this service.\0AImmutable registers cannot be written, but that doesn't imply that their values are constant (unchanging).", name = "mutable", section = "response", type_name = "bool"}
    dsdl.field {c_name = "persistent", doc = "\0A\0APersistence means that the register retains its value permanently across power cycles or any other changes\0Ain the state of the server, until it is explicitly overwritten (either via Cyphal, any other interface,\0Aor by the device itself).\0A\0AThe server is recommended to manage persistence automatically by committing changed register values to a\0Anon-volatile storage automatically as necessary. If automatic persistence management is not implemented, it\0Acan be controlled manually via the standard service uavcan.node.ExecuteCommand. The same service can be used\0Ato return the configuration to a factory-default state. Please refer to its definition for more information.\0A\0AConsider the following examples:\0A  - Configuration parameters are usually both mutable and persistent.\0A  - Diagnostic values are usually immutable and non-persisient.\0A  - Registers that trigger an activity when written are typically mutable but non-persisient.\0A  - Registers that contain factory-programmed values such as calibration coefficients that can't\0A    be changed are typically immutable but persistent.", name = "persistent", section = "response", type_name = "bool"}
    dsdl.field {c_name = "_", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A", name = "", padding, section = "response", type_name = "void6"}
    dsdl.field {c_name = "value", doc = "The value of the register when it was read (beware of race conditions).\0ARegisters never change their type and dimensionality while the node is running.\0AEmpty value means that the register does not exist (in this case the flags should be cleared/ignored).\0ABy comparing the returned value against the write request the caller can determine whether the register\0Awas written successfully, unless write was not requested.\0AAn empty value shall never be returned for an existing register.", name = "value", section = "response", type_name = "Value.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___Access__Response__deserialize_", c_serialize_symbol = "uavcan__register___Access__Response__serialize_", c_type_name = "uavcan__register___Access__Response", extent_bits = 2136 : i64, max_bits = 2136 : i64, min_bits = 72 : i64, sealed, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The moment of time when the register was read (not written).\0AZero if the server does not support timestamping.", kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "mutable", cast_mode = "saturated", doc = "\0A\0AMutable means that the register can be written using this service.\0AImmutable registers cannot be written, but that doesn't imply that their values are constant (unchanging).", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "mutable", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 1 : i64, c_name = "persistent", cast_mode = "saturated", doc = "\0A\0APersistence means that the register retains its value permanently across power cycles or any other changes\0Ain the state of the server, until it is explicitly overwritten (either via Cyphal, any other interface,\0Aor by the device itself).\0A\0AThe server is recommended to manage persistence automatically by committing changed register values to a\0Anon-volatile storage automatically as necessary. If automatic persistence management is not implemented, it\0Acan be controlled manually via the standard service uavcan.node.ExecuteCommand. The same service can be used\0Ato return the configuration to a factory-default state. Please refer to its definition for more information.\0A\0AConsider the following examples:\0A  - Configuration parameters are usually both mutable and persistent.\0A  - Diagnostic values are usually immutable and non-persisient.\0A  - Registers that trigger an activity when written are typically mutable but non-persisient.\0A  - Registers that contain factory-programmed values such as calibration coefficients that can't\0A    be changed are typically immutable but persistent.", kind = "field", max_bits = 1 : i64, min_bits = 1 : i64, name = "persistent", scalar_category = "bool", type_name = "bool", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 6 : i64, c_name = "_", cast_mode = "saturated", doc = "\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A", kind = "padding", max_bits = 6 : i64, min_bits = 6 : i64, name = "", scalar_category = "void", type_name = "void6", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "value", cast_mode = "saturated", composite_c_type_name = "uavcan__register___Value", composite_extent_bits = 2072 : i64, composite_full_name = "uavcan.register.Value", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "The value of the register when it was read (beware of race conditions).\0ARegisters never change their type and dimensionality while the node is running.\0AEmpty value means that the register does not exist (in this case the flags should be cleared/ignored).\0ABy comparing the returned value against the write request the caller can determine whether the register\0Awas written successfully, unless write was not requested.\0AAn empty value shall never be returned for an existing register.", kind = "field", max_bits = 2072 : i64, min_bits = 8 : i64, name = "value", scalar_category = "composite", type_name = "Value.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_register_List_1_0 attributes {c_type_name = "uavcan__register___List", doc = "This service allows the caller to discover the names of all registers available on the server\0Aby iterating the index field from zero until an empty name is returned.\0A\0AThe ordering of the registers shall remain constant while the server is running.\0AThe ordering is not guaranteed to remain unchanged when the server node is restarted.", extent_bits = 16 : i64, fixed_port_id = 385 : i64, full_name = "uavcan.register.List", header_path = "uavcan/register/List_1_0.h", major = 1 : i32, minor = 0 : i32, sealed, service} {
    dsdl.field {c_name = "index", name = "index", section = "request", type_name = "saturated uint16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___List__Request__deserialize_", c_serialize_symbol = "uavcan__register___List__Request__serialize_", c_type_name = "uavcan__register___List__Request", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed, section = "request"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "index", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "index", scalar_category = "unsigned", type_name = "saturated uint16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
    dsdl.field {c_name = "name", doc = "Empty name in response means that the index is out of bounds, i.e., discovery is finished.", name = "name", section = "response", type_name = "Name.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___List__Response__deserialize_", c_serialize_symbol = "uavcan__register___List__Response__serialize_", c_type_name = "uavcan__register___List__Response", extent_bits = 2048 : i64, max_bits = 2048 : i64, min_bits = 8 : i64, sealed, section = "response"} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "name", cast_mode = "saturated", composite_c_type_name = "uavcan__register___Name", composite_extent_bits = 2048 : i64, composite_full_name = "uavcan.register.Name", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Empty name in response means that the index is out of bounds, i.e., discovery is finished.", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "name", scalar_category = "composite", type_name = "Name.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_register_Name_1_0 attributes {c_type_name = "uavcan__register___Name", doc = "An UTF8-encoded register name.", extent_bits = 2048 : i64, full_name = "uavcan.register.Name", header_path = "uavcan/register/Name_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "name", name = "name", type_name = "saturated uint8[<256]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___Name__deserialize_", c_serialize_symbol = "uavcan__register___Name__serialize_", c_type_name = "uavcan__register___Name", extent_bits = 2048 : i64, max_bits = 2048 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 255 : i64, array_kind = "variable_exclusive", array_length_prefix_bits = 8 : i64, bit_length = 8 : i64, c_name = "name", cast_mode = "saturated", kind = "field", max_bits = 2048 : i64, min_bits = 8 : i64, name = "name", scalar_category = "unsigned", type_name = "saturated uint8[<256]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_register_Value_1_0 attributes {c_type_name = "uavcan__register___Value", doc = "This union contains all possible value types supported by the register protocol.\0ANumeric types can be either scalars or arrays; the former is a special case of the latter.", extent_bits = 2072 : i64, full_name = "uavcan.register.Value", header_path = "uavcan/register/Value_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "empty", doc = "Tag 0     Used to represent an undefined value", name = "empty", type_name = "uavcan.primitive.Empty.1.0"}
    dsdl.field {c_name = "string", doc = "Tag 1     UTF-8 encoded text", name = "string", type_name = "uavcan.primitive.String.1.0"}
    dsdl.field {c_name = "unstructured", doc = "Tag 2     Raw unstructured binary image", name = "unstructured", type_name = "uavcan.primitive.Unstructured.1.0"}
    dsdl.field {c_name = "bit", doc = "Tag 3     Bit array", name = "bit", type_name = "uavcan.primitive.array.Bit.1.0"}
    dsdl.field {c_name = "integer64", doc = "Tag 4", name = "integer64", type_name = "uavcan.primitive.array.Integer64.1.0"}
    dsdl.field {c_name = "integer32", doc = "Tag 5", name = "integer32", type_name = "uavcan.primitive.array.Integer32.1.0"}
    dsdl.field {c_name = "integer16", doc = "Tag 6", name = "integer16", type_name = "uavcan.primitive.array.Integer16.1.0"}
    dsdl.field {c_name = "integer8", doc = "Tag 7", name = "integer8", type_name = "uavcan.primitive.array.Integer8.1.0"}
    dsdl.field {c_name = "natural64", doc = "Tag 8", name = "natural64", type_name = "uavcan.primitive.array.Natural64.1.0"}
    dsdl.field {c_name = "natural32", doc = "Tag 9", name = "natural32", type_name = "uavcan.primitive.array.Natural32.1.0"}
    dsdl.field {c_name = "natural16", doc = "Tag 10", name = "natural16", type_name = "uavcan.primitive.array.Natural16.1.0"}
    dsdl.field {c_name = "natural8", doc = "Tag 11", name = "natural8", type_name = "uavcan.primitive.array.Natural8.1.0"}
    dsdl.field {c_name = "real64", doc = "Tag 12    Exactly representable integers: [-2**53,    +2**53]", name = "real64", type_name = "uavcan.primitive.array.Real64.1.0"}
    dsdl.field {c_name = "real32", doc = "Tag 13    Exactly representable integers: [-16777216, +16777216]", name = "real32", type_name = "uavcan.primitive.array.Real32.1.0"}
    dsdl.field {c_name = "real16", doc = "Tag 14    Exactly representable integers: [-2048,     +2048]", name = "real16", type_name = "uavcan.primitive.array.Real16.1.0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__register___Value__deserialize_", c_serialize_symbol = "uavcan__register___Value__serialize_", c_type_name = "uavcan__register___Value", extent_bits = 2072 : i64, is_union, max_bits = 2072 : i64, min_bits = 8 : i64, sealed, union_option_count = 15 : i64, union_tag_bits = 8 : i64} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "empty", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Empty", composite_extent_bits = 0 : i64, composite_full_name = "uavcan.primitive.Empty", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 0     Used to represent an undefined value", kind = "field", max_bits = 0 : i64, min_bits = 0 : i64, name = "empty", scalar_category = "composite", type_name = "uavcan.primitive.Empty.1.0", union_option_index = 0 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "string", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__String", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.String", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 1     UTF-8 encoded text", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "string", scalar_category = "composite", type_name = "uavcan.primitive.String.1.0", union_option_index = 1 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "unstructured", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__Unstructured", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.Unstructured", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 2     Raw unstructured binary image", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "unstructured", scalar_category = "composite", type_name = "uavcan.primitive.Unstructured.1.0", union_option_index = 2 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "bit", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Bit", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.array.Bit", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 3     Bit array", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "bit", scalar_category = "composite", type_name = "uavcan.primitive.array.Bit.1.0", union_option_index = 3 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "integer64", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Integer64", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Integer64", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 4", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "integer64", scalar_category = "composite", type_name = "uavcan.primitive.array.Integer64.1.0", union_option_index = 4 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "integer32", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Integer32", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Integer32", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 5", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "integer32", scalar_category = "composite", type_name = "uavcan.primitive.array.Integer32.1.0", union_option_index = 5 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "integer16", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Integer16", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Integer16", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 6", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "integer16", scalar_category = "composite", type_name = "uavcan.primitive.array.Integer16.1.0", union_option_index = 6 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "integer8", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Integer8", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.array.Integer8", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 7", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "integer8", scalar_category = "composite", type_name = "uavcan.primitive.array.Integer8.1.0", union_option_index = 7 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "natural64", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Natural64", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Natural64", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 8", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "natural64", scalar_category = "composite", type_name = "uavcan.primitive.array.Natural64.1.0", union_option_index = 8 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "natural32", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Natural32", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Natural32", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 9", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "natural32", scalar_category = "composite", type_name = "uavcan.primitive.array.Natural32.1.0", union_option_index = 9 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "natural16", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Natural16", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Natural16", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 10", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "natural16", scalar_category = "composite", type_name = "uavcan.primitive.array.Natural16.1.0", union_option_index = 10 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "natural8", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Natural8", composite_extent_bits = 2064 : i64, composite_full_name = "uavcan.primitive.array.Natural8", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 11", kind = "field", max_bits = 2064 : i64, min_bits = 16 : i64, name = "natural8", scalar_category = "composite", type_name = "uavcan.primitive.array.Natural8.1.0", union_option_index = 11 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "real64", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Real64", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Real64", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 12    Exactly representable integers: [-2**53,    +2**53]", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "real64", scalar_category = "composite", type_name = "uavcan.primitive.array.Real64.1.0", union_option_index = 12 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "real32", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Real32", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Real32", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 13    Exactly representable integers: [-16777216, +16777216]", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "real32", scalar_category = "composite", type_name = "uavcan.primitive.array.Real32.1.0", union_option_index = 13 : i64, union_tag_bits = 8 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "real16", cast_mode = "saturated", composite_c_type_name = "uavcan__primitive__array__Real16", composite_extent_bits = 2056 : i64, composite_full_name = "uavcan.primitive.array.Real16", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, doc = "Tag 14    Exactly representable integers: [-2048,     +2048]", kind = "field", max_bits = 2056 : i64, min_bits = 8 : i64, name = "real16", scalar_category = "composite", type_name = "uavcan.primitive.array.Real16.1.0", union_option_index = 14 : i64, union_tag_bits = 8 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_acceleration_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__acceleration__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.acceleration.Scalar", header_path = "uavcan/si/sample/acceleration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter_per_second_per_second", name = "meter_per_second_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__acceleration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__acceleration__Scalar__serialize_", c_type_name = "uavcan__si__sample__acceleration__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter_per_second_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_acceleration_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__acceleration__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.acceleration.Vector3", header_path = "uavcan/si/sample/acceleration/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter_per_second_per_second", name = "meter_per_second_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__acceleration__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__acceleration__Vector3__serialize_", c_type_name = "uavcan__si__sample__acceleration__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter_per_second_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_NarrowScalar_1_0 attributes {c_type_name = "uavcan__si__sample__angle__NarrowScalar", extent_bits = 72 : i64, full_name = "uavcan.si.sample.angle.NarrowScalar", header_path = "uavcan/si/sample/angle/NarrowScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__NarrowScalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__NarrowScalar__serialize_", c_type_name = "uavcan__si__sample__angle__NarrowScalar", extent_bits = 72 : i64, fixed_size, max_bits = 72 : i64, min_bits = 72 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "radian", scalar_category = "float", type_name = "saturated float16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_NarrowVector3_1_0 attributes {c_type_name = "uavcan__si__sample__angle__NarrowVector3", extent_bits = 104 : i64, full_name = "uavcan.si.sample.angle.NarrowVector3", header_path = "uavcan/si/sample/angle/NarrowVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float16[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__NarrowVector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__NarrowVector3__serialize_", c_type_name = "uavcan__si__sample__angle__NarrowVector3", extent_bits = 104 : i64, fixed_size, max_bits = 104 : i64, min_bits = 104 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "radian", scalar_category = "float", type_name = "saturated float16[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_Quaternion_1_0 attributes {c_type_name = "uavcan__si__sample__angle__Quaternion", extent_bits = 184 : i64, full_name = "uavcan.si.sample.angle.Quaternion", header_path = "uavcan/si/sample/angle/Quaternion_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "wxyz", name = "wxyz", type_name = "saturated float32[4]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__Quaternion__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__Quaternion__serialize_", c_type_name = "uavcan__si__sample__angle__Quaternion", extent_bits = 184 : i64, fixed_size, max_bits = 184 : i64, min_bits = 184 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 4 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "wxyz", cast_mode = "saturated", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "wxyz", scalar_category = "float", type_name = "saturated float32[4]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__angle__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.angle.Scalar", header_path = "uavcan/si/sample/angle/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__Scalar__serialize_", c_type_name = "uavcan__si__sample__angle__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__angle__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.angle.Vector3", header_path = "uavcan/si/sample/angle/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__Vector3__serialize_", c_type_name = "uavcan__si__sample__angle__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_WideScalar_1_0 attributes {c_type_name = "uavcan__si__sample__angle__WideScalar", extent_bits = 120 : i64, full_name = "uavcan.si.sample.angle.WideScalar", header_path = "uavcan/si/sample/angle/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__WideScalar__serialize_", c_type_name = "uavcan__si__sample__angle__WideScalar", extent_bits = 120 : i64, fixed_size, max_bits = 120 : i64, min_bits = 120 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "radian", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angle_WideVector3_1_0 attributes {c_type_name = "uavcan__si__sample__angle__WideVector3", extent_bits = 248 : i64, full_name = "uavcan.si.sample.angle.WideVector3", header_path = "uavcan/si/sample/angle/WideVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float64[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angle__WideVector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__angle__WideVector3__serialize_", c_type_name = "uavcan__si__sample__angle__WideVector3", extent_bits = 248 : i64, fixed_size, max_bits = 248 : i64, min_bits = 248 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 192 : i64, min_bits = 192 : i64, name = "radian", scalar_category = "float", type_name = "saturated float64[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angular_acceleration_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__angular_acceleration__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.angular_acceleration.Scalar", header_path = "uavcan/si/sample/angular_acceleration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian_per_second_per_second", name = "radian_per_second_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angular_acceleration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__angular_acceleration__Scalar__serialize_", c_type_name = "uavcan__si__sample__angular_acceleration__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian_per_second_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angular_acceleration_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__angular_acceleration__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.angular_acceleration.Vector3", header_path = "uavcan/si/sample/angular_acceleration/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian_per_second_per_second", name = "radian_per_second_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angular_acceleration__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__angular_acceleration__Vector3__serialize_", c_type_name = "uavcan__si__sample__angular_acceleration__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian_per_second_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angular_velocity_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__angular_velocity__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.angular_velocity.Scalar", header_path = "uavcan/si/sample/angular_velocity/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian_per_second", name = "radian_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angular_velocity__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__angular_velocity__Scalar__serialize_", c_type_name = "uavcan__si__sample__angular_velocity__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_angular_velocity_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__angular_velocity__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.angular_velocity.Vector3", header_path = "uavcan/si/sample/angular_velocity/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "radian_per_second", name = "radian_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__angular_velocity__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__angular_velocity__Vector3__serialize_", c_type_name = "uavcan__si__sample__angular_velocity__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_duration_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__duration__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.duration.Scalar", header_path = "uavcan/si/sample/duration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "second", name = "second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__duration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__duration__Scalar__serialize_", c_type_name = "uavcan__si__sample__duration__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_duration_WideScalar_1_0 attributes {c_type_name = "uavcan__si__sample__duration__WideScalar", extent_bits = 120 : i64, full_name = "uavcan.si.sample.duration.WideScalar", header_path = "uavcan/si/sample/duration/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "second", name = "second", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__duration__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__duration__WideScalar__serialize_", c_type_name = "uavcan__si__sample__duration__WideScalar", extent_bits = 120 : i64, fixed_size, max_bits = 120 : i64, min_bits = 120 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "second", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "second", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_electric_charge_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__electric_charge__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.electric_charge.Scalar", header_path = "uavcan/si/sample/electric_charge/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "coulomb", name = "coulomb", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__electric_charge__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__electric_charge__Scalar__serialize_", c_type_name = "uavcan__si__sample__electric_charge__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "coulomb", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "coulomb", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_electric_current_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__electric_current__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.electric_current.Scalar", header_path = "uavcan/si/sample/electric_current/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "ampere", name = "ampere", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__electric_current__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__electric_current__Scalar__serialize_", c_type_name = "uavcan__si__sample__electric_current__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "ampere", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_energy_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__energy__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.energy.Scalar", header_path = "uavcan/si/sample/energy/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "joule", name = "joule", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__energy__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__energy__Scalar__serialize_", c_type_name = "uavcan__si__sample__energy__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "joule", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "joule", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_force_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__force__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.force.Scalar", header_path = "uavcan/si/sample/force/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "newton", name = "newton", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__force__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__force__Scalar__serialize_", c_type_name = "uavcan__si__sample__force__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "newton", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_force_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__force__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.force.Vector3", header_path = "uavcan/si/sample/force/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "newton", name = "newton", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__force__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__force__Vector3__serialize_", c_type_name = "uavcan__si__sample__force__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "newton", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_frequency_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__frequency__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.frequency.Scalar", header_path = "uavcan/si/sample/frequency/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "hertz", name = "hertz", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__frequency__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__frequency__Scalar__serialize_", c_type_name = "uavcan__si__sample__frequency__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "hertz", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "hertz", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_NarrowScalar_1_0 attributes {c_type_name = "uavcan__si__sample__length__NarrowScalar", extent_bits = 72 : i64, full_name = "uavcan.si.sample.length.NarrowScalar", header_path = "uavcan/si/sample/length/NarrowScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__NarrowScalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__NarrowScalar__serialize_", c_type_name = "uavcan__si__sample__length__NarrowScalar", extent_bits = 72 : i64, fixed_size, max_bits = 72 : i64, min_bits = 72 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "meter", scalar_category = "float", type_name = "saturated float16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_NarrowVector3_1_0 attributes {c_type_name = "uavcan__si__sample__length__NarrowVector3", extent_bits = 104 : i64, full_name = "uavcan.si.sample.length.NarrowVector3", header_path = "uavcan/si/sample/length/NarrowVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float16[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__NarrowVector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__NarrowVector3__serialize_", c_type_name = "uavcan__si__sample__length__NarrowVector3", extent_bits = 104 : i64, fixed_size, max_bits = 104 : i64, min_bits = 104 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "meter", scalar_category = "float", type_name = "saturated float16[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__length__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.length.Scalar", header_path = "uavcan/si/sample/length/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__Scalar__serialize_", c_type_name = "uavcan__si__sample__length__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__length__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.length.Vector3", header_path = "uavcan/si/sample/length/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__Vector3__serialize_", c_type_name = "uavcan__si__sample__length__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_WideScalar_1_0 attributes {c_type_name = "uavcan__si__sample__length__WideScalar", extent_bits = 120 : i64, full_name = "uavcan.si.sample.length.WideScalar", header_path = "uavcan/si/sample/length/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__WideScalar__serialize_", c_type_name = "uavcan__si__sample__length__WideScalar", extent_bits = 120 : i64, fixed_size, max_bits = 120 : i64, min_bits = 120 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "meter", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_length_WideVector3_1_0 attributes {c_type_name = "uavcan__si__sample__length__WideVector3", extent_bits = 248 : i64, full_name = "uavcan.si.sample.length.WideVector3", header_path = "uavcan/si/sample/length/WideVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float64[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__length__WideVector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__length__WideVector3__serialize_", c_type_name = "uavcan__si__sample__length__WideVector3", extent_bits = 248 : i64, fixed_size, max_bits = 248 : i64, min_bits = 248 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 192 : i64, min_bits = 192 : i64, name = "meter", scalar_category = "float", type_name = "saturated float64[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_luminance_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__luminance__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.luminance.Scalar", header_path = "uavcan/si/sample/luminance/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "candela_per_square_meter", name = "candela_per_square_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__luminance__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__luminance__Scalar__serialize_", c_type_name = "uavcan__si__sample__luminance__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "candela_per_square_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "candela_per_square_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_field_strength_Scalar_1_1 attributes {c_type_name = "uavcan__si__sample__magnetic_field_strength__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.magnetic_field_strength.Scalar", header_path = "uavcan/si/sample/magnetic_field_strength/Scalar_1_1.h", major = 1 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "ampere_per_meter", name = "ampere_per_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_field_strength__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_field_strength__Scalar__serialize_", c_type_name = "uavcan__si__sample__magnetic_field_strength__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere_per_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "ampere_per_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_field_strength_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__magnetic_field_strength__Scalar", deprecated, extent_bits = 88 : i64, full_name = "uavcan.si.sample.magnetic_field_strength.Scalar", header_path = "uavcan/si/sample/magnetic_field_strength/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_field_strength__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_field_strength__Scalar__serialize_", c_type_name = "uavcan__si__sample__magnetic_field_strength__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_field_strength_Vector3_1_1 attributes {c_type_name = "uavcan__si__sample__magnetic_field_strength__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.magnetic_field_strength.Vector3", header_path = "uavcan/si/sample/magnetic_field_strength/Vector3_1_1.h", major = 1 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "ampere_per_meter", name = "ampere_per_meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_field_strength__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_field_strength__Vector3__serialize_", c_type_name = "uavcan__si__sample__magnetic_field_strength__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere_per_meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "ampere_per_meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_field_strength_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__magnetic_field_strength__Vector3", deprecated, extent_bits = 152 : i64, full_name = "uavcan.si.sample.magnetic_field_strength.Vector3", header_path = "uavcan/si/sample/magnetic_field_strength/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_field_strength__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_field_strength__Vector3__serialize_", c_type_name = "uavcan__si__sample__magnetic_field_strength__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_flux_density_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__magnetic_flux_density__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.magnetic_flux_density.Scalar", header_path = "uavcan/si/sample/magnetic_flux_density/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_flux_density__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_flux_density__Scalar__serialize_", c_type_name = "uavcan__si__sample__magnetic_flux_density__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_magnetic_flux_density_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__magnetic_flux_density__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.magnetic_flux_density.Vector3", header_path = "uavcan/si/sample/magnetic_flux_density/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__magnetic_flux_density__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__magnetic_flux_density__Vector3__serialize_", c_type_name = "uavcan__si__sample__magnetic_flux_density__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_mass_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__mass__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.mass.Scalar", header_path = "uavcan/si/sample/mass/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "kilogram", name = "kilogram", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__mass__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__mass__Scalar__serialize_", c_type_name = "uavcan__si__sample__mass__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "kilogram", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "kilogram", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_power_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__power__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.power.Scalar", header_path = "uavcan/si/sample/power/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "watt", name = "watt", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__power__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__power__Scalar__serialize_", c_type_name = "uavcan__si__sample__power__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "watt", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "watt", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_pressure_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__pressure__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.pressure.Scalar", header_path = "uavcan/si/sample/pressure/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "pascal", name = "pascal", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__pressure__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__pressure__Scalar__serialize_", c_type_name = "uavcan__si__sample__pressure__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "pascal", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "pascal", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_temperature_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__temperature__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.temperature.Scalar", header_path = "uavcan/si/sample/temperature/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "kelvin", name = "kelvin", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__temperature__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__temperature__Scalar__serialize_", c_type_name = "uavcan__si__sample__temperature__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "kelvin", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "kelvin", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_torque_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__torque__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.torque.Scalar", header_path = "uavcan/si/sample/torque/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "newton_meter", name = "newton_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__torque__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__torque__Scalar__serialize_", c_type_name = "uavcan__si__sample__torque__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "newton_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_torque_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__torque__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.torque.Vector3", header_path = "uavcan/si/sample/torque/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "newton_meter", name = "newton_meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__torque__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__torque__Vector3__serialize_", c_type_name = "uavcan__si__sample__torque__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton_meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "newton_meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_velocity_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__velocity__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.velocity.Scalar", header_path = "uavcan/si/sample/velocity/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter_per_second", name = "meter_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__velocity__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__velocity__Scalar__serialize_", c_type_name = "uavcan__si__sample__velocity__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_velocity_Vector3_1_0 attributes {c_type_name = "uavcan__si__sample__velocity__Vector3", extent_bits = 152 : i64, full_name = "uavcan.si.sample.velocity.Vector3", header_path = "uavcan/si/sample/velocity/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "meter_per_second", name = "meter_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__velocity__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__sample__velocity__Vector3__serialize_", c_type_name = "uavcan__si__sample__velocity__Vector3", extent_bits = 152 : i64, fixed_size, max_bits = 152 : i64, min_bits = 152 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_voltage_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__voltage__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.voltage.Scalar", header_path = "uavcan/si/sample/voltage/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "volt", name = "volt", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__voltage__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__voltage__Scalar__serialize_", c_type_name = "uavcan__si__sample__voltage__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "volt", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "volt", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_volume_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__volume__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.volume.Scalar", header_path = "uavcan/si/sample/volume/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "cubic_meter", name = "cubic_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__volume__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__volume__Scalar__serialize_", c_type_name = "uavcan__si__sample__volume__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "cubic_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "cubic_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_sample_volumetric_flow_rate_Scalar_1_0 attributes {c_type_name = "uavcan__si__sample__volumetric_flow_rate__Scalar", extent_bits = 88 : i64, full_name = "uavcan.si.sample.volumetric_flow_rate.Scalar", header_path = "uavcan/si/sample/volumetric_flow_rate/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "timestamp", name = "timestamp", type_name = "uavcan.time.SynchronizedTimestamp.1.0"}
    dsdl.field {c_name = "cubic_meter_per_second", name = "cubic_meter_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__sample__volumetric_flow_rate__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__sample__volumetric_flow_rate__Scalar__serialize_", c_type_name = "uavcan__si__sample__volumetric_flow_rate__Scalar", extent_bits = 88 : i64, fixed_size, max_bits = 88 : i64, min_bits = 88 : i64, sealed} {
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "timestamp", cast_mode = "saturated", composite_c_type_name = "uavcan__time__SynchronizedTimestamp", composite_extent_bits = 56 : i64, composite_full_name = "uavcan.time.SynchronizedTimestamp", composite_major = 1 : i64, composite_minor = 0 : i64, composite_sealed = true, kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "timestamp", scalar_category = "composite", type_name = "uavcan.time.SynchronizedTimestamp.1.0", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "cubic_meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "cubic_meter_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_acceleration_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__acceleration__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.acceleration.Scalar", header_path = "uavcan/si/unit/acceleration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter_per_second_per_second", name = "meter_per_second_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__acceleration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__acceleration__Scalar__serialize_", c_type_name = "uavcan__si__unit__acceleration__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter_per_second_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_acceleration_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__acceleration__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.acceleration.Vector3", header_path = "uavcan/si/unit/acceleration/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter_per_second_per_second", name = "meter_per_second_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__acceleration__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__acceleration__Vector3__serialize_", c_type_name = "uavcan__si__unit__acceleration__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter_per_second_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_NarrowScalar_1_0 attributes {c_type_name = "uavcan__si__unit__angle__NarrowScalar", extent_bits = 16 : i64, full_name = "uavcan.si.unit.angle.NarrowScalar", header_path = "uavcan/si/unit/angle/NarrowScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__NarrowScalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__NarrowScalar__serialize_", c_type_name = "uavcan__si__unit__angle__NarrowScalar", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "radian", scalar_category = "float", type_name = "saturated float16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_NarrowVector3_1_0 attributes {c_type_name = "uavcan__si__unit__angle__NarrowVector3", extent_bits = 48 : i64, full_name = "uavcan.si.unit.angle.NarrowVector3", header_path = "uavcan/si/unit/angle/NarrowVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float16[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__NarrowVector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__NarrowVector3__serialize_", c_type_name = "uavcan__si__unit__angle__NarrowVector3", extent_bits = 48 : i64, fixed_size, max_bits = 48 : i64, min_bits = 48 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "radian", scalar_category = "float", type_name = "saturated float16[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_Quaternion_1_0 attributes {c_type_name = "uavcan__si__unit__angle__Quaternion", extent_bits = 128 : i64, full_name = "uavcan.si.unit.angle.Quaternion", header_path = "uavcan/si/unit/angle/Quaternion_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "wxyz", name = "wxyz", type_name = "saturated float32[4]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__Quaternion__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__Quaternion__serialize_", c_type_name = "uavcan__si__unit__angle__Quaternion", extent_bits = 128 : i64, fixed_size, max_bits = 128 : i64, min_bits = 128 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 4 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "wxyz", cast_mode = "saturated", kind = "field", max_bits = 128 : i64, min_bits = 128 : i64, name = "wxyz", scalar_category = "float", type_name = "saturated float32[4]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__angle__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.angle.Scalar", header_path = "uavcan/si/unit/angle/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__Scalar__serialize_", c_type_name = "uavcan__si__unit__angle__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__angle__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.angle.Vector3", header_path = "uavcan/si/unit/angle/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__Vector3__serialize_", c_type_name = "uavcan__si__unit__angle__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_WideScalar_1_0 attributes {c_type_name = "uavcan__si__unit__angle__WideScalar", extent_bits = 64 : i64, full_name = "uavcan.si.unit.angle.WideScalar", header_path = "uavcan/si/unit/angle/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__WideScalar__serialize_", c_type_name = "uavcan__si__unit__angle__WideScalar", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "radian", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angle_WideVector3_1_0 attributes {c_type_name = "uavcan__si__unit__angle__WideVector3", extent_bits = 192 : i64, full_name = "uavcan.si.unit.angle.WideVector3", header_path = "uavcan/si/unit/angle/WideVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian", name = "radian", type_name = "saturated float64[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angle__WideVector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__angle__WideVector3__serialize_", c_type_name = "uavcan__si__unit__angle__WideVector3", extent_bits = 192 : i64, fixed_size, max_bits = 192 : i64, min_bits = 192 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "radian", cast_mode = "saturated", kind = "field", max_bits = 192 : i64, min_bits = 192 : i64, name = "radian", scalar_category = "float", type_name = "saturated float64[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angular_acceleration_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__angular_acceleration__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.angular_acceleration.Scalar", header_path = "uavcan/si/unit/angular_acceleration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian_per_second_per_second", name = "radian_per_second_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angular_acceleration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__angular_acceleration__Scalar__serialize_", c_type_name = "uavcan__si__unit__angular_acceleration__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian_per_second_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angular_acceleration_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__angular_acceleration__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.angular_acceleration.Vector3", header_path = "uavcan/si/unit/angular_acceleration/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian_per_second_per_second", name = "radian_per_second_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angular_acceleration__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__angular_acceleration__Vector3__serialize_", c_type_name = "uavcan__si__unit__angular_acceleration__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian_per_second_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angular_velocity_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__angular_velocity__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.angular_velocity.Scalar", header_path = "uavcan/si/unit/angular_velocity/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian_per_second", name = "radian_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angular_velocity__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__angular_velocity__Scalar__serialize_", c_type_name = "uavcan__si__unit__angular_velocity__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "radian_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_angular_velocity_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__angular_velocity__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.angular_velocity.Vector3", header_path = "uavcan/si/unit/angular_velocity/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "radian_per_second", name = "radian_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__angular_velocity__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__angular_velocity__Vector3__serialize_", c_type_name = "uavcan__si__unit__angular_velocity__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "radian_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "radian_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_duration_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__duration__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.duration.Scalar", header_path = "uavcan/si/unit/duration/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "second", name = "second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__duration__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__duration__Scalar__serialize_", c_type_name = "uavcan__si__unit__duration__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_duration_WideScalar_1_0 attributes {c_type_name = "uavcan__si__unit__duration__WideScalar", extent_bits = 64 : i64, full_name = "uavcan.si.unit.duration.WideScalar", header_path = "uavcan/si/unit/duration/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "second", name = "second", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__duration__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__duration__WideScalar__serialize_", c_type_name = "uavcan__si__unit__duration__WideScalar", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "second", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "second", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_electric_charge_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__electric_charge__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.electric_charge.Scalar", header_path = "uavcan/si/unit/electric_charge/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "coulomb", name = "coulomb", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__electric_charge__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__electric_charge__Scalar__serialize_", c_type_name = "uavcan__si__unit__electric_charge__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "coulomb", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "coulomb", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_electric_current_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__electric_current__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.electric_current.Scalar", header_path = "uavcan/si/unit/electric_current/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "ampere", name = "ampere", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__electric_current__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__electric_current__Scalar__serialize_", c_type_name = "uavcan__si__unit__electric_current__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "ampere", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_energy_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__energy__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.energy.Scalar", header_path = "uavcan/si/unit/energy/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "joule", name = "joule", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__energy__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__energy__Scalar__serialize_", c_type_name = "uavcan__si__unit__energy__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "joule", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "joule", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_force_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__force__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.force.Scalar", header_path = "uavcan/si/unit/force/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "newton", name = "newton", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__force__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__force__Scalar__serialize_", c_type_name = "uavcan__si__unit__force__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "newton", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_force_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__force__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.force.Vector3", header_path = "uavcan/si/unit/force/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "newton", name = "newton", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__force__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__force__Vector3__serialize_", c_type_name = "uavcan__si__unit__force__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "newton", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_frequency_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__frequency__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.frequency.Scalar", header_path = "uavcan/si/unit/frequency/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "hertz", name = "hertz", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__frequency__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__frequency__Scalar__serialize_", c_type_name = "uavcan__si__unit__frequency__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "hertz", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "hertz", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_NarrowScalar_1_0 attributes {c_type_name = "uavcan__si__unit__length__NarrowScalar", extent_bits = 16 : i64, full_name = "uavcan.si.unit.length.NarrowScalar", header_path = "uavcan/si/unit/length/NarrowScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float16"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__NarrowScalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__NarrowScalar__serialize_", c_type_name = "uavcan__si__unit__length__NarrowScalar", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "meter", scalar_category = "float", type_name = "saturated float16", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_NarrowVector3_1_0 attributes {c_type_name = "uavcan__si__unit__length__NarrowVector3", extent_bits = 48 : i64, full_name = "uavcan.si.unit.length.NarrowVector3", header_path = "uavcan/si/unit/length/NarrowVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float16[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__NarrowVector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__NarrowVector3__serialize_", c_type_name = "uavcan__si__unit__length__NarrowVector3", extent_bits = 48 : i64, fixed_size, max_bits = 48 : i64, min_bits = 48 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 16 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 48 : i64, min_bits = 48 : i64, name = "meter", scalar_category = "float", type_name = "saturated float16[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__length__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.length.Scalar", header_path = "uavcan/si/unit/length/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__Scalar__serialize_", c_type_name = "uavcan__si__unit__length__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__length__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.length.Vector3", header_path = "uavcan/si/unit/length/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__Vector3__serialize_", c_type_name = "uavcan__si__unit__length__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_WideScalar_1_0 attributes {c_type_name = "uavcan__si__unit__length__WideScalar", extent_bits = 64 : i64, full_name = "uavcan.si.unit.length.WideScalar", header_path = "uavcan/si/unit/length/WideScalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float64"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__WideScalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__WideScalar__serialize_", c_type_name = "uavcan__si__unit__length__WideScalar", extent_bits = 64 : i64, fixed_size, max_bits = 64 : i64, min_bits = 64 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 64 : i64, min_bits = 64 : i64, name = "meter", scalar_category = "float", type_name = "saturated float64", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_length_WideVector3_1_0 attributes {c_type_name = "uavcan__si__unit__length__WideVector3", extent_bits = 192 : i64, full_name = "uavcan.si.unit.length.WideVector3", header_path = "uavcan/si/unit/length/WideVector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter", name = "meter", type_name = "saturated float64[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__length__WideVector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__length__WideVector3__serialize_", c_type_name = "uavcan__si__unit__length__WideVector3", extent_bits = 192 : i64, fixed_size, max_bits = 192 : i64, min_bits = 192 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 64 : i64, c_name = "meter", cast_mode = "saturated", kind = "field", max_bits = 192 : i64, min_bits = 192 : i64, name = "meter", scalar_category = "float", type_name = "saturated float64[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_luminance_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__luminance__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.luminance.Scalar", header_path = "uavcan/si/unit/luminance/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "candela_per_square_meter", name = "candela_per_square_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__luminance__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__luminance__Scalar__serialize_", c_type_name = "uavcan__si__unit__luminance__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "candela_per_square_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "candela_per_square_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_field_strength_Scalar_1_1 attributes {c_type_name = "uavcan__si__unit__magnetic_field_strength__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.magnetic_field_strength.Scalar", header_path = "uavcan/si/unit/magnetic_field_strength/Scalar_1_1.h", major = 1 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "ampere_per_meter", name = "ampere_per_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_field_strength__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_field_strength__Scalar__serialize_", c_type_name = "uavcan__si__unit__magnetic_field_strength__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere_per_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "ampere_per_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_field_strength_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__magnetic_field_strength__Scalar", deprecated, extent_bits = 32 : i64, full_name = "uavcan.si.unit.magnetic_field_strength.Scalar", header_path = "uavcan/si/unit/magnetic_field_strength/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_field_strength__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_field_strength__Scalar__serialize_", c_type_name = "uavcan__si__unit__magnetic_field_strength__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_field_strength_Vector3_1_1 attributes {c_type_name = "uavcan__si__unit__magnetic_field_strength__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.magnetic_field_strength.Vector3", header_path = "uavcan/si/unit/magnetic_field_strength/Vector3_1_1.h", major = 1 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "ampere_per_meter", name = "ampere_per_meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_field_strength__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_field_strength__Vector3__serialize_", c_type_name = "uavcan__si__unit__magnetic_field_strength__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "ampere_per_meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "ampere_per_meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_field_strength_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__magnetic_field_strength__Vector3", deprecated, extent_bits = 96 : i64, full_name = "uavcan.si.unit.magnetic_field_strength.Vector3", header_path = "uavcan/si/unit/magnetic_field_strength/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_field_strength__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_field_strength__Vector3__serialize_", c_type_name = "uavcan__si__unit__magnetic_field_strength__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_flux_density_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__magnetic_flux_density__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.magnetic_flux_density.Scalar", header_path = "uavcan/si/unit/magnetic_flux_density/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_flux_density__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_flux_density__Scalar__serialize_", c_type_name = "uavcan__si__unit__magnetic_flux_density__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_magnetic_flux_density_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__magnetic_flux_density__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.magnetic_flux_density.Vector3", header_path = "uavcan/si/unit/magnetic_flux_density/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "tesla", name = "tesla", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__magnetic_flux_density__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__magnetic_flux_density__Vector3__serialize_", c_type_name = "uavcan__si__unit__magnetic_flux_density__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "tesla", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "tesla", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_mass_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__mass__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.mass.Scalar", header_path = "uavcan/si/unit/mass/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "kilogram", name = "kilogram", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__mass__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__mass__Scalar__serialize_", c_type_name = "uavcan__si__unit__mass__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "kilogram", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "kilogram", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_power_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__power__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.power.Scalar", header_path = "uavcan/si/unit/power/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "watt", name = "watt", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__power__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__power__Scalar__serialize_", c_type_name = "uavcan__si__unit__power__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "watt", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "watt", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_pressure_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__pressure__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.pressure.Scalar", header_path = "uavcan/si/unit/pressure/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "pascal", name = "pascal", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__pressure__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__pressure__Scalar__serialize_", c_type_name = "uavcan__si__unit__pressure__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "pascal", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "pascal", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_temperature_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__temperature__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.temperature.Scalar", header_path = "uavcan/si/unit/temperature/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "kelvin", name = "kelvin", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__temperature__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__temperature__Scalar__serialize_", c_type_name = "uavcan__si__unit__temperature__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "kelvin", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "kelvin", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_torque_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__torque__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.torque.Scalar", header_path = "uavcan/si/unit/torque/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "newton_meter", name = "newton_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__torque__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__torque__Scalar__serialize_", c_type_name = "uavcan__si__unit__torque__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "newton_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_torque_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__torque__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.torque.Vector3", header_path = "uavcan/si/unit/torque/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "newton_meter", name = "newton_meter", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__torque__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__torque__Vector3__serialize_", c_type_name = "uavcan__si__unit__torque__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "newton_meter", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "newton_meter", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_velocity_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__velocity__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.velocity.Scalar", header_path = "uavcan/si/unit/velocity/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter_per_second", name = "meter_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__velocity__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__velocity__Scalar__serialize_", c_type_name = "uavcan__si__unit__velocity__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "meter_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_velocity_Vector3_1_0 attributes {c_type_name = "uavcan__si__unit__velocity__Vector3", extent_bits = 96 : i64, full_name = "uavcan.si.unit.velocity.Vector3", header_path = "uavcan/si/unit/velocity/Vector3_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "meter_per_second", name = "meter_per_second", type_name = "saturated float32[3]"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__velocity__Vector3__deserialize_", c_serialize_symbol = "uavcan__si__unit__velocity__Vector3__serialize_", c_type_name = "uavcan__si__unit__velocity__Vector3", extent_bits = 96 : i64, fixed_size, max_bits = 96 : i64, min_bits = 96 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 3 : i64, array_kind = "fixed", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 96 : i64, min_bits = 96 : i64, name = "meter_per_second", scalar_category = "float", type_name = "saturated float32[3]", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_voltage_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__voltage__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.voltage.Scalar", header_path = "uavcan/si/unit/voltage/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "volt", name = "volt", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__voltage__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__voltage__Scalar__serialize_", c_type_name = "uavcan__si__unit__voltage__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "volt", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "volt", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_volume_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__volume__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.volume.Scalar", header_path = "uavcan/si/unit/volume/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "cubic_meter", name = "cubic_meter", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__volume__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__volume__Scalar__serialize_", c_type_name = "uavcan__si__unit__volume__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "cubic_meter", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "cubic_meter", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_si_unit_volumetric_flow_rate_Scalar_1_0 attributes {c_type_name = "uavcan__si__unit__volumetric_flow_rate__Scalar", extent_bits = 32 : i64, full_name = "uavcan.si.unit.volumetric_flow_rate.Scalar", header_path = "uavcan/si/unit/volumetric_flow_rate/Scalar_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "cubic_meter_per_second", name = "cubic_meter_per_second", type_name = "saturated float32"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__si__unit__volumetric_flow_rate__Scalar__deserialize_", c_serialize_symbol = "uavcan__si__unit__volumetric_flow_rate__Scalar__serialize_", c_type_name = "uavcan__si__unit__volumetric_flow_rate__Scalar", extent_bits = 32 : i64, fixed_size, max_bits = 32 : i64, min_bits = 32 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "cubic_meter_per_second", cast_mode = "saturated", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "cubic_meter_per_second", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_time_GetSynchronizationMasterInfo_0_1 attributes {c_type_name = "uavcan__time__GetSynchronizationMasterInfo", doc = "Every node that acts as a time synchronization master, or is capable of acting as such,\0Ashould support this service.\0AIts objective is to provide information about which time system is currently used in the network.\0A\0AOnce a time system is chosen, it cannot be changed as long as at least one node on the network is running.\0AIn other words, the time system cannot be changed while the network is operating.\0AAn implication of this is that if there are redundant time synchronization masters, they all shall\0Ause the same time system always.", extent_bits = 384 : i64, fixed_port_id = 510 : i64, full_name = "uavcan.time.GetSynchronizationMasterInfo", header_path = "uavcan/time/GetSynchronizationMasterInfo_0_1.h", major = 0 : i32, minor = 1 : i32, service} {
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__GetSynchronizationMasterInfo__Request__deserialize_", c_serialize_symbol = "uavcan__time__GetSynchronizationMasterInfo__Request__serialize_", c_type_name = "uavcan__time__GetSynchronizationMasterInfo__Request", extent_bits = 384 : i64, fixed_size, max_bits = 0 : i64, min_bits = 0 : i64, section = "request"} {
      dsdl.align {bits = 1 : i32}
    }
    dsdl.field {c_name = "error_variance", doc = "[second^2]\0AError variance, in second^2, of the time value reported by this master.\0AThis value is allowed to change freely while the master is running.\0AFor example, if the master's own clock is synchronized with a GNSS, the error variance is expected to increase\0Aas signal reception deteriorates. If the signal is lost, this value is expected to grow steadily, the rate of\0Agrowth would be dependent on the quality of the time keeping hardware available locally (bad hardware yields\0Afaster growth). Once the signal is regained, this value would drop back to nominal.", name = "error_variance", section = "response", type_name = "saturated float32"}
    dsdl.field {c_name = "time_system", doc = "\0A\0A\0A\0A\0A\0ATime system currently in use by the master.\0ACannot be changed while the network is operating.", name = "time_system", section = "response", type_name = "TimeSystem.0.1"}
    dsdl.field {c_name = "tai_info", doc = "\0A\0AActual information about TAI provided by this master, if supported.\0AThe fields in this data type are optional.", name = "tai_info", section = "response", type_name = "TAIInfo.0.1"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__GetSynchronizationMasterInfo__Response__deserialize_", c_serialize_symbol = "uavcan__time__GetSynchronizationMasterInfo__Response__serialize_", c_type_name = "uavcan__time__GetSynchronizationMasterInfo__Response", extent_bits = 1536 : i64, fixed_size, max_bits = 56 : i64, min_bits = 56 : i64, section = "response"} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 32 : i64, c_name = "error_variance", cast_mode = "saturated", doc = "[second^2]\0AError variance, in second^2, of the time value reported by this master.\0AThis value is allowed to change freely while the master is running.\0AFor example, if the master's own clock is synchronized with a GNSS, the error variance is expected to increase\0Aas signal reception deteriorates. If the signal is lost, this value is expected to grow steadily, the rate of\0Agrowth would be dependent on the quality of the time keeping hardware available locally (bad hardware yields\0Afaster growth). Once the signal is regained, this value would drop back to nominal.", kind = "field", max_bits = 32 : i64, min_bits = 32 : i64, name = "error_variance", scalar_category = "float", type_name = "saturated float32", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "time_system", cast_mode = "saturated", composite_c_type_name = "uavcan__time__TimeSystem", composite_extent_bits = 8 : i64, composite_full_name = "uavcan.time.TimeSystem", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "\0A\0A\0A\0A\0A\0ATime system currently in use by the master.\0ACannot be changed while the network is operating.", kind = "field", max_bits = 8 : i64, min_bits = 8 : i64, name = "time_system", scalar_category = "composite", type_name = "TimeSystem.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
      dsdl.align {bits = 8 : i32}
      dsdl.io {alignment_bits = 8 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 0 : i64, c_name = "tai_info", cast_mode = "saturated", composite_c_type_name = "uavcan__time__TAIInfo", composite_extent_bits = 16 : i64, composite_full_name = "uavcan.time.TAIInfo", composite_major = 0 : i64, composite_minor = 1 : i64, composite_sealed = true, doc = "\0A\0AActual information about TAI provided by this master, if supported.\0AThe fields in this data type are optional.", kind = "field", max_bits = 16 : i64, min_bits = 16 : i64, name = "tai_info", scalar_category = "composite", type_name = "TAIInfo.0.1", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_time_Synchronization_1_0 attributes {c_type_name = "uavcan__time__Synchronization", doc = "Network-wide time synchronization message.\0AAny node that publishes timestamped data should use this time reference.\0A\0AThe time synchronization algorithm is based on the work\0A\22Implementing a Distributed High-Resolution Real-Time Clock using the CAN-Bus\22 by M. Gergeleit and H. Streich.\0AThe general idea of the algorithm is to have one or more nodes that periodically publish a message of this type\0Acontaining the exact timestamp of the PREVIOUS transmission of this message.\0AA node that publishes this message periodically is referred to as a \22time synchronization master\22,\0Awhereas nodes that synchronize their clocks with the master are referred to as \22time synchronization slaves\22.\0A\0AOnce a time base is chosen, it cannot be changed as long as at least one node on the network is running.\0AIn other words, the time base cannot be changed while the network is operating.\0AAn implication of this is that if there are redundant time synchronization masters, they all shall\0Ause the same time base.\0A\0AThe resolution is dependent on the transport and its physical layer, but generally it can be assumed\0Ato be close to one bit time but not better than one microsecond (e.g., for a 500 kbps CAN bus,\0Athe resolution is two microseconds). The maximum accuracy is achievable only if the transport layer\0Asupports precise timestamping in hardware; otherwise, the accuracy may be degraded.\0A\0AThis algorithm allows the slaves to precisely estimate the difference (i.e., phase error) between their\0Alocal time and the master clock they are synchronized with. The algorithm for clock rate adjustment\0Ais entirely implementation-defined (for example, a simple phase-locked loop or a PID rate controller can be used).\0A\0AThe network can accommodate more than one time synchronization master for purposes of increased reliability:\0Aif one master fails, the others will continue to provide the network with accurate and consistent time information.\0AThe risk of undesirable transients while the masters are swapped is mitigated by the requirement that all masters\0Ause the same time base at all times, as described above.\0A\0AThe master with the lowest node-ID is called the \22dominant master\22. The current dominant master ceases to be one\0Aif its last synchronization message was published more than 3X seconds ago, where X is the time interval\0Abetween the last and the previous messages published by it. In this case, the master with the next-higher node-ID\0Awill take over as the new dominant master. The current dominant master will be displaced immediately as soon as\0Athe first message from a new master with a lower node-ID is seen on the bus.\0A\0AIn the presence of multiple masters, they all publish their time synchronization messages concurrently at all times.\0AThe slaves shall listen to the master with the lowest node-ID and ignore the messages published by masters with\0Ahigher node-ID values.\0A\0ACurrently, there is a work underway to develop and validate a highly robust fault-operational time synchronization\0Aalgorithm where the slaves select the median time base among all available masters rather than using only the\0Aone with the lowest node-ID value. Follow the work at https://forum.opencyphal.org. When complete, this algorithm\0Awill be added in a backward-compatible way as an option for high-reliability systems.\0A\0AFor networks with redundant transports, the timestamp value published on different interfaces is likely to be\0Adifferent, since different transports are generally not expected to be synchronized. Synchronization slaves\0Aare allowed to use any of the available redundant interfaces for synchronization at their discretion.\0A\0AThe following pseudocode shows the logic of a time synchronization master. This example assumes that the master\0Adoes not need to synchronize its own clock with other masters on the bus, which is the case if the current master\0Ais the only master, or if all masters synchronize their clocks with a robust external source, e.g., a GNSS system.\0AIf several masters need to synchronize their clock through the bus, their logic will be extended with the\0Aslave-side behavior explained later.\0A\0A      // State variables\0A      transfer_id := 0;\0A      previous_tx_timestamp_per_iface[NUM_IFACES] := {0};\0A\0A      // This function publishes a message with a specified transfer-ID using only one transport interface.\0A      function publishMessage(transfer_id, iface_index, msg);\0A\0A      // This callback is invoked when the transport layer completes the transmission of a time sync message.\0A      // Observe that the time sync message is always a single-frame message by virtue of its small size.\0A      // The tx_timestamp argument contains the exact timestamp when the transport frame was delivered to the bus.\0A      function messageTxTimestampCallback(iface_index, tx_timestamp)\0A      {\0A          previous_tx_timestamp_per_iface[iface_index] := tx_timestamp;\0A      }\0A\0A      // Publishes messages of type uavcan.time.Synchronization to each available transport interface.\0A      // It is assumed that this function is invoked with a fixed frequency not lower than 1 hertz.\0A      function publishTimeSync()\0A      {\0A          for (i := 0; i < NUM_IFACES; i++)\0A          {\0A              message := uavcan.time.Synchronization();\0A              message.previous_transmission_timestamp_usec := previous_tx_timestamp_per_iface[i];\0A              previous_tx_timestamp_per_iface[i] := 0;\0A              publishMessage(transfer_id, i, message);\0A          }\0A          transfer_id++; // Overflow shall be handled correctly\0A      }\0A\0A(end of the master-side logic pseudocode)\0AThe following pseudocode describes the logic of a time synchronization slave.\0A\0A      // State variables:\0A      previous_rx_real_timestamp := 0;            // This clock is being synchronized\0A      previous_rx_monotonic_timestamp := 0;       // Monotonic time -- doesn't leap or change rate\0A      previous_transfer_id := 0;\0A      state := STATE_UPDATE;                      // Variants: STATE_UPDATE, STATE_ADJUST\0A      master_node_id := -1;                       // Invalid value\0A      iface_index := -1;                          // Invalid value\0A\0A      // This function adjusts the local clock by the specified amount\0A      function adjustLocalTime(phase_error);\0A\0A      function adjust(message)\0A      {\0A          // Clock adjustment will be performed every second message\0A          local_time_phase_error := previous_rx_real_timestamp - msg.previous_transmission_timestamp_microsecond;\0A          adjustLocalTime(local_time_phase_error);\0A          state := STATE_UPDATE;\0A      }\0A\0A      function update(message)\0A      {\0A          // A message is assumed to have two timestamps:\0A          //   Real      - sampled from the clock that is being synchronized\0A          //   Monotonic - clock that never leaps and never changes rate\0A          previous_rx_real_timestamp := message.rx_real_timestamp;\0A          previous_rx_monotonic_timestamp := message.rx_monotonic_timestamp;\0A          master_node_id := message.source_node_id;\0A          iface_index := message.iface_index;\0A          previous_transfer_id := message.transfer_id;\0A          state := STATE_ADJUST;\0A      }\0A\0A      // Accepts the message of type uavcan.time.Synchronization\0A      function handleReceivedTimeSyncMessage(message)\0A      {\0A          time_since_previous_msg := message.monotonic_timestamp - previous_rx_monotonic_timestamp;\0A\0A          needs_init := (master_node_id < 0) or (iface_index < 0);\0A          switch_master := message.source_node_id < master_node_id;\0A\0A          // The value publisher_timeout is computed as described in the specification (3x interval)\0A          publisher_timed_out := time_since_previous_msg > publisher_timeout;\0A\0A          if (needs_init or switch_master or publisher_timed_out)\0A          {\0A              update(message);\0A          }\0A          else if ((message.iface_index == iface_index) and (message.source_node_id == master_node_id))\0A          {\0A              // Revert the state to STATE_UPDATE if needed\0A              if (state == STATE_ADJUST)\0A              {\0A                  msg_invalid := message.previous_transmission_timestamp_microsecond == 0;\0A                  // Overflow shall be handled correctly\0A                  wrong_tid := message.transfer_id != (previous_transfer_id + 1);\0A                  wrong_timing := time_since_previous_msg > MAX_PUBLICATION_PERIOD;\0A                  if (msg_invalid or wrong_tid or wrong_timing)\0A                  {\0A                      state := STATE_UPDATE;\0A                  }\0A              }\0A              // Handle the current state\0A              if (state == STATE_ADJUST)\0A              {\0A                  adjust(message);\0A              }\0A              else\0A              {\0A                  update(message);\0A              }\0A          }   // else ignore\0A      }\0A\0A(end of the slave-side logic pseudocode)", extent_bits = 56 : i64, fixed_port_id = 7168 : i64, full_name = "uavcan.time.Synchronization", header_path = "uavcan/time/Synchronization_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "previous_transmission_timestamp_microsecond", doc = "\0A\0A\0A\0A\0A\0AThe time when the PREVIOUS message was transmitted from the current publisher, in microseconds.\0AIf this message is published for the first time, or if the previous transmission was more than\0Aone second ago, this field shall be zero.", name = "previous_transmission_timestamp_microsecond", type_name = "truncated uint56"}
    dsdl.constant {doc = "[second]\0APublication period limits.\0AA master should not change its publication period while running.", name = "MAX_PUBLICATION_PERIOD", type_name = "saturated uint8", value_text = "1"}
    dsdl.constant {doc = "\0A\0ASynchronization slaves should normally switch to a new master if the current master was silent\0Afor thrice the interval between the reception of the last two messages published by it.\0AFor example, imagine that the last message was received at the time X, and the previous message\0Awas received at the time (X - 0.5 seconds); the period is 0.5 seconds, and therefore the publisher\0Atimeout is (0.5 seconds * 3) = 1.5 seconds. If there was no message from the current master in\0Athis amount of time, all slaves will synchronize with another master with the next-higher node-ID.", name = "PUBLISHER_TIMEOUT_PERIOD_MULTIPLIER", type_name = "saturated uint8", value_text = "3"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__Synchronization__deserialize_", c_serialize_symbol = "uavcan__time__Synchronization__serialize_", c_type_name = "uavcan__time__Synchronization", extent_bits = 56 : i64, fixed_size, max_bits = 56 : i64, min_bits = 56 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 56 : i64, c_name = "previous_transmission_timestamp_microsecond", cast_mode = "truncated", doc = "\0A\0A\0A\0A\0A\0AThe time when the PREVIOUS message was transmitted from the current publisher, in microseconds.\0AIf this message is published for the first time, or if the previous transmission was more than\0Aone second ago, this field shall be zero.", kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "previous_transmission_timestamp_microsecond", scalar_category = "unsigned", type_name = "truncated uint56", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_time_SynchronizedTimestamp_1_0 attributes {c_type_name = "uavcan__time__SynchronizedTimestamp", doc = "Nested data type used for representing a network-wide synchronized timestamp with microsecond resolution.\0AThis data type is highly recommended for use both in standard and vendor-specific messages alike.", extent_bits = 56 : i64, full_name = "uavcan.time.SynchronizedTimestamp", header_path = "uavcan/time/SynchronizedTimestamp_1_0.h", major = 1 : i32, minor = 0 : i32, sealed} {
    dsdl.field {c_name = "microsecond", doc = "The number of microseconds that have passed since some arbitrary moment in the past.\0AThe moment of origin (i.e., the time base) is defined per-application. The current time base in use\0Acan be requested from the time synchronization master, see the corresponding service definition.\0A\0AThis value is to never overflow. The value is 56-bit wide because:\0A\0A  - 2^56 microseconds is about 2285 years, which is plenty. A 64-bit microsecond counter would be\0A    unnecessarily wide and its overflow interval of 585 thousand years induces a mild existential crisis.\0A\0A  - Classic-CAN (not FD) transports carry up to 7 bytes of payload per frame.\0A    Time sync messages shall use single-frame transfers, which means that the value can't be wider than 56 bits.", name = "microsecond", type_name = "truncated uint56"}
    dsdl.constant {doc = "Zero means that the time is not known.", name = "UNKNOWN", type_name = "saturated uint56", value_text = "0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__SynchronizedTimestamp__deserialize_", c_serialize_symbol = "uavcan__time__SynchronizedTimestamp__serialize_", c_type_name = "uavcan__time__SynchronizedTimestamp", extent_bits = 56 : i64, fixed_size, max_bits = 56 : i64, min_bits = 56 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 56 : i64, c_name = "microsecond", cast_mode = "truncated", doc = "The number of microseconds that have passed since some arbitrary moment in the past.\0AThe moment of origin (i.e., the time base) is defined per-application. The current time base in use\0Acan be requested from the time synchronization master, see the corresponding service definition.\0A\0AThis value is to never overflow. The value is 56-bit wide because:\0A\0A  - 2^56 microseconds is about 2285 years, which is plenty. A 64-bit microsecond counter would be\0A    unnecessarily wide and its overflow interval of 585 thousand years induces a mild existential crisis.\0A\0A  - Classic-CAN (not FD) transports carry up to 7 bytes of payload per frame.\0A    Time sync messages shall use single-frame transfers, which means that the value can't be wider than 56 bits.", kind = "field", max_bits = 56 : i64, min_bits = 56 : i64, name = "microsecond", scalar_category = "unsigned", type_name = "truncated uint56", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_time_TAIInfo_0_1 attributes {c_type_name = "uavcan__time__TAIInfo", doc = "This data types defines constants and runtime values pertaining to the International Atomic Time, also known as TAI.\0ASee https://en.wikipedia.org/wiki/International_Atomic_Time.\0A\0AThe relationship between the three major time systems -- TAI, GPS, and UTC -- is as follows:\0A\0A  TAI = GPS + 19 seconds\0A  TAI = UTC + LS + 10 seconds\0A\0AWhere \22LS\22 is the current number of leap seconds: https://en.wikipedia.org/wiki/Leap_second.\0A\0ACyphal applications should only rely on TAI whenever a global time system is needed.\0AGPS time is strongly discouraged for reasons of consistency across different positioning systems and applications.", extent_bits = 16 : i64, full_name = "uavcan.time.TAIInfo", header_path = "uavcan/time/TAIInfo_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "difference_tai_minus_utc", doc = "The current difference between TAI and UTC, if known. If unknown, set to zero.\0A\0AThis value may change states between known and unknown while the master is running,\0Adepending on its ability to obtain robust values from external sources.\0A\0AThis value may change twice a year, possibly while the system is running; https://en.wikipedia.org/wiki/Leap_second.\0ASince the rotation of Earth is decelerating, this value may only be positive. Do not use outside Earth.\0A\0AFor reference, here is the full list of recorded TAI-UTC difference values, valid at the time of writing:\0A\0A    Date     | TAI-UTC difference [second]\0A   ----------|-----------------------------\0A    Jan 1972 | 10\0A    Jul 1972 | 11\0A    Jan 1973 | 12\0A    Jan 1974 | 13\0A    Jan 1975 | 14\0A    Jan 1976 | 15\0A    Jan 1977 | 16\0A    Jan 1978 | 17\0A    Jan 1979 | 18\0A    Jan 1980 | 19\0A    Jul 1981 | 20\0A    Jul 1982 | 21\0A    Jul 1983 | 22\0A    Jul 1985 | 23\0A    Jan 1988 | 24\0A    Jan 1990 | 25\0A    Jan 1991 | 26\0A    Jul 1992 | 27\0A    Jul 1993 | 28\0A    Jul 1994 | 29\0A    Jan 1996 | 30\0A    Jul 1997 | 31\0A    Jan 1999 | 32\0A    Jan 2006 | 33\0A    Jan 2009 | 34\0A    Jul 2012 | 35\0A    Jul 2015 | 36\0A    Jan 2017 | 37\0A\0AAs of 2020, the future of the leap second and the relation between UTC and TAI remains uncertain.", name = "difference_tai_minus_utc", type_name = "saturated uint10"}
    dsdl.constant {doc = "[second]\0AThe fixed difference, in seconds, between TAI and GPS time. Does not change ever.\0ASystems that use GPS time as a reference should convert that to TAI by adding this difference.", name = "DIFFERENCE_TAI_MINUS_GPS", type_name = "saturated uint8", value_text = "19"}
    dsdl.constant {doc = "\0A", name = "DIFFERENCE_TAI_MINUS_UTC_UNKNOWN", type_name = "saturated uint10", value_text = "0"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__TAIInfo__deserialize_", c_serialize_symbol = "uavcan__time__TAIInfo__serialize_", c_type_name = "uavcan__time__TAIInfo", extent_bits = 16 : i64, fixed_size, max_bits = 16 : i64, min_bits = 16 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 10 : i64, c_name = "difference_tai_minus_utc", cast_mode = "saturated", doc = "The current difference between TAI and UTC, if known. If unknown, set to zero.\0A\0AThis value may change states between known and unknown while the master is running,\0Adepending on its ability to obtain robust values from external sources.\0A\0AThis value may change twice a year, possibly while the system is running; https://en.wikipedia.org/wiki/Leap_second.\0ASince the rotation of Earth is decelerating, this value may only be positive. Do not use outside Earth.\0A\0AFor reference, here is the full list of recorded TAI-UTC difference values, valid at the time of writing:\0A\0A    Date     | TAI-UTC difference [second]\0A   ----------|-----------------------------\0A    Jan 1972 | 10\0A    Jul 1972 | 11\0A    Jan 1973 | 12\0A    Jan 1974 | 13\0A    Jan 1975 | 14\0A    Jan 1976 | 15\0A    Jan 1977 | 16\0A    Jan 1978 | 17\0A    Jan 1979 | 18\0A    Jan 1980 | 19\0A    Jul 1981 | 20\0A    Jul 1982 | 21\0A    Jul 1983 | 22\0A    Jul 1985 | 23\0A    Jan 1988 | 24\0A    Jan 1990 | 25\0A    Jan 1991 | 26\0A    Jul 1992 | 27\0A    Jul 1993 | 28\0A    Jul 1994 | 29\0A    Jan 1996 | 30\0A    Jul 1997 | 31\0A    Jan 1999 | 32\0A    Jan 2006 | 33\0A    Jan 2009 | 34\0A    Jul 2012 | 35\0A    Jul 2015 | 36\0A    Jan 2017 | 37\0A\0AAs of 2020, the future of the leap second and the relation between UTC and TAI remains uncertain.", kind = "field", max_bits = 10 : i64, min_bits = 10 : i64, name = "difference_tai_minus_utc", scalar_category = "unsigned", type_name = "saturated uint10", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
  dsdl.schema @uavcan_time_TimeSystem_0_1 attributes {c_type_name = "uavcan__time__TimeSystem", doc = "Time system enumeration.\0AThe time system shall be the same for all masters in the network.\0AIt cannot be changed while the network is running.", extent_bits = 8 : i64, full_name = "uavcan.time.TimeSystem", header_path = "uavcan/time/TimeSystem_0_1.h", major = 0 : i32, minor = 1 : i32, sealed} {
    dsdl.field {c_name = "value", name = "value", type_name = "truncated uint4"}
    dsdl.constant {doc = "Monotonic time since boot.\0AMonotonic time is a time reference that doesn't change rate or make leaps.", name = "MONOTONIC_SINCE_BOOT", type_name = "saturated uint4", value_text = "0"}
    dsdl.constant {doc = "\0A\0AInternational Atomic Time; https://en.wikipedia.org/wiki/International_Atomic_Time.\0AThe timestamp value contains the number of microseconds elapsed since 1970-01-01T00:00:00Z TAI.\0ATAI is always a fixed integer number of seconds ahead of GPS time.\0ASystems that use GPS time as a reference should convert that to TAI by adding the fixed difference.\0AGPS time is not supported for reasons of consistency across different positioning systems and applications.", name = "TAI", type_name = "saturated uint4", value_text = "1"}
    dsdl.constant {doc = "\0A\0A\0A\0A\0AApplication-specific time system of unknown properties.", name = "APPLICATION_SPECIFIC", type_name = "saturated uint4", value_text = "15"}
    dsdl.serialization_plan attributes {c_deserialize_symbol = "uavcan__time__TimeSystem__deserialize_", c_serialize_symbol = "uavcan__time__TimeSystem__serialize_", c_type_name = "uavcan__time__TimeSystem", extent_bits = 8 : i64, fixed_size, max_bits = 8 : i64, min_bits = 8 : i64, sealed} {
      dsdl.align {bits = 1 : i32}
      dsdl.io {alignment_bits = 1 : i64, array_capacity = 0 : i64, array_kind = "none", array_length_prefix_bits = 0 : i64, bit_length = 4 : i64, c_name = "value", cast_mode = "truncated", kind = "field", max_bits = 4 : i64, min_bits = 4 : i64, name = "value", scalar_category = "unsigned", type_name = "truncated uint4", union_option_index = 0 : i64, union_tag_bits = 0 : i64}
    }
  }
}

)LLVMDSDL_UAVCAN";
}  // namespace llvmdsdl::uavcan_embedded_mlir
