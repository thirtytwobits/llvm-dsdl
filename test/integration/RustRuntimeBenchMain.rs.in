use llvmdsdl_runtime_bench::benchrust::payload_1_0::benchrust_Payload_1_0;
use std::env;
use std::fs;
use std::path::PathBuf;
use std::time::Instant;

const MODE: &str = "@RUST_BENCH_MODE@";
const INLINE_THRESHOLD_BYTES: usize = @RUST_INLINE_THRESHOLD_BYTES@;
const ITERATIONS_SMALL: u64 = @BENCH_ITERATIONS_SMALL@;
const ITERATIONS_MEDIUM: u64 = @BENCH_ITERATIONS_MEDIUM@;
const ITERATIONS_LARGE: u64 = @BENCH_ITERATIONS_LARGE@;

const CHECKSUM_SEED: u64 = 0xcbf29ce484222325;
const CHECKSUM_PRIME: u64 = 0x100000001b3;

#[derive(Clone, Copy)]
struct OperationMetrics {
    elapsed_sec: f64,
    payload_bytes: u64,
    operations: u64,
    operations_per_sec: f64,
    throughput_mib_per_sec: f64,
    checksum: u64,
}

#[derive(Clone, Copy)]
struct FamilyMetrics {
    payload_len: usize,
    iterations: u64,
    estimated_pool_alloc_calls: u64,
    encode: OperationMetrics,
    decode: OperationMetrics,
}

#[derive(Clone, Copy)]
struct FamilySpec {
    name: &'static str,
    payload_len: usize,
    iterations: u64,
}

fn fmt_f64(value: f64) -> String {
    format!("{value:.9}")
}

fn checksum_update(mut checksum: u64, payload: &[u8], iteration: u64) -> u64 {
    checksum ^= iteration.wrapping_mul(1315423911);
    checksum = checksum.wrapping_mul(CHECKSUM_PRIME);
    checksum ^= payload.len() as u64;
    checksum = checksum.wrapping_mul(CHECKSUM_PRIME);
    if let Some(first) = payload.first() {
        checksum ^= *first as u64;
        checksum = checksum.wrapping_mul(CHECKSUM_PRIME);
    }
    if let Some(last) = payload.last() {
        checksum ^= *last as u64;
        checksum = checksum.wrapping_mul(CHECKSUM_PRIME);
    }
    checksum
}

fn throughput_mib_per_sec(payload_bytes: u64, elapsed_sec: f64) -> f64 {
    if elapsed_sec <= 0.0 {
        0.0
    } else {
        (payload_bytes as f64) / (1024.0 * 1024.0) / elapsed_sec
    }
}

fn make_payload(seed: u64, payload_len: usize) -> benchrust_Payload_1_0 {
    let mut value = benchrust_Payload_1_0::default();
    value.bytes.clear();
    value.bytes.reserve(payload_len);
    for index in 0..payload_len {
        let byte = (seed
            .wrapping_mul(131)
            .wrapping_add((index as u64).wrapping_mul(17))
            .wrapping_add(29)
            & 0xFF) as u8;
        value.bytes.push(byte);
    }
    value
}

fn run_encode(iterations: u64, payload_len: usize) -> OperationMetrics {
    let value = make_payload(0x51, payload_len);
    let mut buffer = vec![0u8; benchrust_Payload_1_0::SERIALIZATION_BUFFER_SIZE_BYTES];
    let mut payload_bytes: u64 = 0;
    let mut checksum = CHECKSUM_SEED;

    let start = Instant::now();
    for iter in 0..iterations {
        let used = value.serialize(&mut buffer).expect("serialize benchmark payload");
        payload_bytes = payload_bytes.saturating_add(used as u64);
        checksum = checksum_update(checksum, &buffer[..used], iter);
    }
    let elapsed_sec = start.elapsed().as_secs_f64();

    OperationMetrics {
        elapsed_sec,
        payload_bytes,
        operations: iterations,
        operations_per_sec: if elapsed_sec > 0.0 {
            (iterations as f64) / elapsed_sec
        } else {
            0.0
        },
        throughput_mib_per_sec: throughput_mib_per_sec(payload_bytes, elapsed_sec),
        checksum,
    }
}

fn run_decode(iterations: u64, payload_len: usize) -> OperationMetrics {
    let seed_value = make_payload(0xA7, payload_len);
    let sample_bytes = seed_value.to_bytes().expect("serialize decode seed payload");
    let expected_used = sample_bytes.len();
    let mut payload_bytes: u64 = 0;
    let mut checksum = CHECKSUM_SEED;

    let start = Instant::now();
    for iter in 0..iterations {
        let (decoded, used) = benchrust_Payload_1_0::from_bytes(&sample_bytes)
            .expect("deserialize benchmark payload");
        assert_eq!(used, expected_used);
        payload_bytes = payload_bytes.saturating_add(used as u64);
        checksum = checksum_update(checksum, decoded.bytes.as_slice(), iter);
    }
    let elapsed_sec = start.elapsed().as_secs_f64();

    OperationMetrics {
        elapsed_sec,
        payload_bytes,
        operations: iterations,
        operations_per_sec: if elapsed_sec > 0.0 {
            (iterations as f64) / elapsed_sec
        } else {
            0.0
        },
        throughput_mib_per_sec: throughput_mib_per_sec(payload_bytes, elapsed_sec),
        checksum,
    }
}

fn estimated_pool_alloc_calls(payload_len: usize, iterations: u64) -> u64 {
    if MODE == "inline-then-pool" && payload_len > INLINE_THRESHOLD_BYTES {
        iterations
    } else {
        0
    }
}

fn operation_json(op: OperationMetrics) -> String {
    format!(
        "{{\"elapsed_sec\":{},\"payload_bytes\":{},\"operations\":{},\"operations_per_sec\":{},\"throughput_mib_per_sec\":{},\"checksum\":{}}}",
        fmt_f64(op.elapsed_sec),
        op.payload_bytes,
        op.operations,
        fmt_f64(op.operations_per_sec),
        fmt_f64(op.throughput_mib_per_sec),
        op.checksum
    )
}

fn family_json(family: FamilyMetrics) -> String {
    format!(
        "{{\"payload_len\":{},\"iterations\":{},\"estimated_pool_alloc_calls\":{},\"encode\":{},\"decode\":{}}}",
        family.payload_len,
        family.iterations,
        family.estimated_pool_alloc_calls,
        operation_json(family.encode),
        operation_json(family.decode)
    )
}

fn report_path() -> PathBuf {
    let value = env::var("LLVMDSDL_RUST_BENCH_REPORT_JSON")
        .expect("LLVMDSDL_RUST_BENCH_REPORT_JSON must be set by benchmark driver");
    PathBuf::from(value)
}

fn main() {
    let families = [
        FamilySpec {
            name: "small",
            payload_len: 32,
            iterations: ITERATIONS_SMALL,
        },
        FamilySpec {
            name: "medium",
            payload_len: 512,
            iterations: ITERATIONS_MEDIUM,
        },
        FamilySpec {
            name: "large",
            payload_len: 3072,
            iterations: ITERATIONS_LARGE,
        },
    ];

    let mut rows: Vec<(&'static str, FamilyMetrics)> = Vec::with_capacity(families.len());
    let mut total_elapsed = 0.0_f64;
    let mut total_payload_bytes: u64 = 0;
    let mut total_operations: u64 = 0;
    let mut aggregate_checksum = CHECKSUM_SEED;

    for spec in families {
        let encode = run_encode(spec.iterations, spec.payload_len);
        let decode = run_decode(spec.iterations, spec.payload_len);
        let estimated_alloc_calls = estimated_pool_alloc_calls(spec.payload_len, spec.iterations);
        let metrics = FamilyMetrics {
            payload_len: spec.payload_len,
            iterations: spec.iterations,
            estimated_pool_alloc_calls: estimated_alloc_calls,
            encode,
            decode,
        };
        println!(
            "rust-bench mode={} family={} payload={} iter={} encode_sec={} decode_sec={} encode_mibps={} decode_mibps={} estimated_pool_alloc_calls={}",
            MODE,
            spec.name,
            spec.payload_len,
            spec.iterations,
            fmt_f64(encode.elapsed_sec),
            fmt_f64(decode.elapsed_sec),
            fmt_f64(encode.throughput_mib_per_sec),
            fmt_f64(decode.throughput_mib_per_sec),
            estimated_alloc_calls
        );

        total_elapsed += encode.elapsed_sec + decode.elapsed_sec;
        total_payload_bytes = total_payload_bytes
            .saturating_add(encode.payload_bytes)
            .saturating_add(decode.payload_bytes);
        total_operations = total_operations
            .saturating_add(encode.operations)
            .saturating_add(decode.operations);
        aggregate_checksum = checksum_update(aggregate_checksum, &[encode.checksum as u8], spec.iterations);
        aggregate_checksum = checksum_update(aggregate_checksum, &[decode.checksum as u8], spec.iterations);
        rows.push((spec.name, metrics));
    }

    let total_ops_per_sec = if total_elapsed > 0.0 {
        (total_operations as f64) / total_elapsed
    } else {
        0.0
    };
    let total_throughput_mib_per_sec = throughput_mib_per_sec(total_payload_bytes, total_elapsed);

    let mut json = String::new();
    json.push_str("{\n");
    json.push_str("  \"schema_version\": 1,\n");
    json.push_str(&format!("  \"mode\": \"{}\",\n", MODE));
    json.push_str(&format!(
        "  \"inline_threshold_bytes\": {},\n",
        INLINE_THRESHOLD_BYTES
    ));
    json.push_str("  \"families\": {\n");
    for (index, (name, metrics)) in rows.iter().enumerate() {
        let comma = if index + 1 == rows.len() { "" } else { "," };
        json.push_str(&format!(
            "    \"{}\": {}{}\n",
            name,
            family_json(*metrics),
            comma
        ));
    }
    json.push_str("  },\n");
    json.push_str("  \"totals\": {\n");
    json.push_str(&format!(
        "    \"elapsed_sec\": {},\n",
        fmt_f64(total_elapsed)
    ));
    json.push_str(&format!("    \"payload_bytes\": {},\n", total_payload_bytes));
    json.push_str(&format!("    \"operations\": {},\n", total_operations));
    json.push_str(&format!(
        "    \"operations_per_sec\": {},\n",
        fmt_f64(total_ops_per_sec)
    ));
    json.push_str(&format!(
        "    \"throughput_mib_per_sec\": {},\n",
        fmt_f64(total_throughput_mib_per_sec)
    ));
    json.push_str(&format!("    \"checksum\": {}\n", aggregate_checksum));
    json.push_str("  }\n");
    json.push_str("}\n");

    let path = report_path();
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            fs::create_dir_all(parent).expect("create benchmark report parent directory");
        }
    }
    fs::write(&path, json).expect("write rust benchmark report");
    println!("rust-bench mode={} report={}", MODE, path.display());
}
