#include "DifferentialParityABI.h"

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern const DifferentialCaseInfo g_ours_case_heartbeat;
extern const DifferentialCaseInfo g_ours_case_execute_command_request;
extern const DifferentialCaseInfo g_ours_case_execute_command_response;
extern const DifferentialCaseInfo g_ours_case_register_value;
extern const DifferentialCaseInfo g_ours_case_can_frame;
extern const DifferentialCaseInfo g_ours_case_real32_array;

extern const DifferentialCaseInfo g_nv_case_heartbeat;
extern const DifferentialCaseInfo g_nv_case_execute_command_request;
extern const DifferentialCaseInfo g_nv_case_execute_command_response;
extern const DifferentialCaseInfo g_nv_case_register_value;
extern const DifferentialCaseInfo g_nv_case_can_frame;
extern const DifferentialCaseInfo g_nv_case_real32_array;

typedef struct {
  const char *name;
  const DifferentialCaseInfo *ours;
  const DifferentialCaseInfo *nv;
  bool compareBytes;
} CasePair;

static const CasePair kCases[] = {
    {"uavcan.node.Heartbeat.1.0", &g_ours_case_heartbeat, &g_nv_case_heartbeat, true},
    {"uavcan.node.ExecuteCommand.Request.1.3",
     &g_ours_case_execute_command_request,
     &g_nv_case_execute_command_request, true},
    {"uavcan.node.ExecuteCommand.Response.1.3",
     &g_ours_case_execute_command_response,
     &g_nv_case_execute_command_response, true},
    {"uavcan.register.Value.1.0", &g_ours_case_register_value,
     &g_nv_case_register_value, false},
    {"uavcan.metatransport.can.Frame.0.2", &g_ours_case_can_frame,
     &g_nv_case_can_frame, true},
    {"uavcan.primitive.array.Real32.1.0", &g_ours_case_real32_array,
     &g_nv_case_real32_array, false},
};

static uint64_t g_rng_state = UINT64_C(0x9E3779B97F4A7C15);

static uint32_t nextRandomU32(void) {
  g_rng_state ^= g_rng_state << 13U;
  g_rng_state ^= g_rng_state >> 7U;
  g_rng_state ^= g_rng_state << 17U;
  return (uint32_t)(g_rng_state & UINT64_C(0xFFFFFFFF));
}

static void fillRandomBytes(uint8_t *const dst, const size_t size) {
  for (size_t i = 0; i < size; ++i) {
    dst[i] = (uint8_t)(nextRandomU32() & 0xFFU);
  }
}

static size_t maxSize(const size_t a, const size_t b) {
  return (a > b) ? a : b;
}

static void dumpBytes(const char *const label, const uint8_t *const data,
                      const size_t size) {
  fprintf(stderr, "%s (%zu):", label, size);
  for (size_t i = 0; i < size; ++i) {
    fprintf(stderr, " %02X", data[i]);
  }
  fprintf(stderr, "\n");
}

static int runCase(const CasePair *const testCase, const size_t iterations,
                   const bool strictFloatByteParity) {
  uint8_t input[2048];
  uint8_t oursObject[4096];
  uint8_t nvObject[4096];
  uint8_t oursSerialized[2048];
  uint8_t nvSerialized[2048];

  if (testCase->ours->object_size > sizeof(oursObject) ||
      testCase->nv->object_size > sizeof(nvObject)) {
    fprintf(stderr, "Case %s object exceeds harness buffer size\n", testCase->name);
    return 1;
  }

  const size_t maxInput =
      maxSize(testCase->ours->max_serialized_size,
              testCase->nv->max_serialized_size) +
      16U;
  const size_t maxOutput = 1024U;
  if (maxInput > sizeof(input) || maxOutput > sizeof(oursSerialized) ||
      maxOutput > sizeof(nvSerialized)) {
    fprintf(stderr, "Case %s requires larger I/O buffers in harness\n", testCase->name);
    return 1;
  }

  for (size_t i = 0; i < iterations; ++i) {
    const size_t inputSize = (size_t)(nextRandomU32() % (uint32_t)(maxInput + 1U));
    fillRandomBytes(input, inputSize);
    memset(oursObject, 0, testCase->ours->object_size);
    memset(nvObject, 0, testCase->nv->object_size);

    size_t oursConsumed = inputSize;
    size_t nvConsumed = inputSize;
    const int8_t oursDesResult =
        testCase->ours->deserialize(oursObject, input, &oursConsumed);
    const int8_t nvDesResult =
        testCase->nv->deserialize(nvObject, input, &nvConsumed);

    if ((oursDesResult != nvDesResult) || (oursConsumed != nvConsumed)) {
      fprintf(stderr,
              "Deserialize mismatch in %s iter=%zu input_size=%zu ours(rc=%d,consumed=%zu) "
              "nv(rc=%d,consumed=%zu)\n",
              testCase->name, i, inputSize, (int)oursDesResult, oursConsumed,
              (int)nvDesResult, nvConsumed);
      return 1;
    }

    if (oursDesResult >= 0) {
      memset(oursSerialized, 0xA5, maxOutput);
      memset(nvSerialized, 0x5A, maxOutput);
      size_t oursOutSize = maxOutput;
      size_t nvOutSize = maxOutput;
      const int8_t oursSerResult =
          testCase->ours->serialize(oursObject, oursSerialized, &oursOutSize);
      const int8_t nvSerResult =
          testCase->nv->serialize(nvObject, nvSerialized, &nvOutSize);
      const bool shouldCompareBytes =
          testCase->compareBytes || strictFloatByteParity;
      const bool byteMismatch =
          shouldCompareBytes &&
          (memcmp(oursSerialized, nvSerialized, oursOutSize) != 0);
      if ((oursSerResult != nvSerResult) || (oursOutSize != nvOutSize) ||
          byteMismatch) {
        fprintf(stderr,
                "Serialize mismatch in %s iter=%zu ours(rc=%d,size=%zu) nv(rc=%d,size=%zu)\n",
                testCase->name, i, (int)oursSerResult, oursOutSize,
                (int)nvSerResult, nvOutSize);
        dumpBytes("input", input, inputSize);
        dumpBytes("ours", oursSerialized, oursOutSize);
        dumpBytes("nunavut", nvSerialized, nvOutSize);
        return 1;
      }
    }
  }

  printf("PASS %s (%zu iterations)\n", testCase->name, iterations);
  return 0;
}

int main(int argc, char **argv) {
  size_t iterations = 128U;
  bool strictFloatByteParity = false;
  if (argc > 1) {
    char *endptr = NULL;
    const unsigned long parsed = strtoul(argv[1], &endptr, 10);
    if ((endptr == NULL) || (*endptr != '\0') || (parsed == 0UL)) {
      fprintf(stderr, "Invalid iteration count: %s\n", argv[1]);
      return 2;
    }
    iterations = (size_t)parsed;
  }
  if (argc > 2) {
    if (strcmp(argv[2], "--strict-float-byte-parity") == 0) {
      strictFloatByteParity = true;
    } else {
      fprintf(stderr, "Unknown option: %s\n", argv[2]);
      return 2;
    }
  }

  const size_t caseCount = sizeof(kCases) / sizeof(kCases[0]);
  for (size_t i = 0; i < caseCount; ++i) {
    if (runCase(&kCases[i], iterations, strictFloatByteParity) != 0) {
      return 1;
    }
  }
  printf("Differential parity PASS (%zu cases)\n", caseCount);
  return 0;
}
