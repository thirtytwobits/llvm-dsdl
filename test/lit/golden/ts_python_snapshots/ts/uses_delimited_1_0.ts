// Generated by llvmdsdl (TypeScript backend).
import * as dsdlRuntime from "../../dsdl_runtime";

import { deserializeDelimited_1_0, serializeDelimited_1_0 } from "./delimited_1_0";
import type { Delimited_1_0 } from "./delimited_1_0";
export const DSDL_FULL_NAME = "fixtures.vendor.UsesDelimited";
export const DSDL_VERSION_MAJOR = 1;
export const DSDL_VERSION_MINOR = 0;

export interface UsesDelimited_1_0 {
  nested: Delimited_1_0;
}


export function serializeUsesDelimited_1_0(value: UsesDelimited_1_0): Uint8Array {
  const out = new Uint8Array(12);
  let offsetBits = 0;
  const mlir___llvmdsdl_plan_capacity_check__fixtures_vendor_UsesDelimited_1_0 = (capacityBits: number): boolean => 96 <= capacityBits;
  const mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1 = (payloadBytes: number, remainingBytes: number): boolean => (payloadBytes >= 0) && (payloadBytes <= remainingBytes);
  
  if (!mlir___llvmdsdl_plan_capacity_check__fixtures_vendor_UsesDelimited_1_0(out.length * 8)) {
    throw new Error("serialization buffer too small");
  }
  const nestedAlignedOffsetBits = Math.trunc((offsetBits + 7) / 8) * 8;
  for (let nestedAlignBit = offsetBits; nestedAlignBit < nestedAlignedOffsetBits; ++nestedAlignBit) {
    dsdlRuntime.setBit(out, nestedAlignBit, false);
  }
  offsetBits = nestedAlignedOffsetBits;
  const nestedBytes = serializeDelimited_1_0(value.nested);
  const nestedSizeBytes = nestedBytes.length;
  if (nestedSizeBytes > 12) {
    throw new Error("encoded payload for composite field 'nested' exceeds max payload bytes 12");
  }
  const nestedRemainingBytes = out.length - Math.min(Math.trunc(offsetBits / 8), out.length);
  if (nestedSizeBytes > nestedRemainingBytes) {
    throw new Error("encoded payload for composite field 'nested' exceeds remaining buffer space");
  }
  dsdlRuntime.writeUnsigned(out, offsetBits, 32, nestedSizeBytes, false);
  offsetBits += 32;
  dsdlRuntime.copyBits(out, offsetBits, nestedBytes, 0, nestedSizeBytes * 8);
  offsetBits += nestedSizeBytes * 8;
  const usedBytes = dsdlRuntime.byteLengthForBits(offsetBits);
  return out.subarray(0, usedBytes);
}

export function deserializeUsesDelimited_1_0(bytes: Uint8Array): { value: UsesDelimited_1_0; consumed: number } {
  const mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1 = (payloadBytes: number, remainingBytes: number): boolean => (payloadBytes >= 0) && (payloadBytes <= remainingBytes);
  
  const value = {} as UsesDelimited_1_0;
  let offsetBits = 0;
  offsetBits = Math.trunc((offsetBits + 7) / 8) * 8;
  const nestedSizeBytes = Math.trunc(dsdlRuntime.readUnsigned(bytes, offsetBits, 32));
  offsetBits += 32;
  const nestedRemainingBytes = bytes.length - Math.min(Math.trunc(offsetBits / 8), bytes.length);
  if (!mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1(nestedSizeBytes, nestedRemainingBytes)) {
    throw new Error("decoded payload size for composite field 'nested' exceeds remaining buffer space");
  }
  const nestedStartByte = Math.min(Math.trunc(offsetBits / 8), bytes.length);
  const nestedEndByte = Math.min(nestedStartByte + nestedSizeBytes, bytes.length);
  const nestedBytes = bytes.subarray(nestedStartByte, nestedEndByte);
  value.nested = deserializeDelimited_1_0(nestedBytes).value;
  offsetBits += nestedSizeBytes * 8;
  const consumed = Math.min(bytes.length, dsdlRuntime.byteLengthForBits(offsetBits));
  return { value, consumed };
}
