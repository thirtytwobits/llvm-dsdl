# Generated by llvmdsdl (Python backend).
from __future__ import annotations

from dataclasses import dataclass, field

from fixtures_snapshot_py._runtime_loader import runtime as dsdl_runtime
from fixtures_snapshot_py.fixtures.vendor.delimited_1_0 import Delimited_1_0

DSDL_FULL_NAME = "fixtures.vendor.UsesDelimited"
DSDL_VERSION_MAJOR = 1
DSDL_VERSION_MINOR = 0

@dataclass(slots=True)
class UsesDelimited_1_0:
    nested: Delimited_1_0 = field(default_factory=Delimited_1_0)

    def serialize(self) -> bytes:
        return _serialize_UsesDelimited_1_0(self)

    @classmethod
    def deserialize(cls, data: bytes | bytearray | memoryview) -> "UsesDelimited_1_0":
        value, _consumed = _deserialize_UsesDelimited_1_0(bytes(data))
        return value

    def _serialize_to(self, writer: object) -> None:
        writer.write(self.serialize())

    @classmethod
    def _deserialize_from(cls, reader: object) -> "UsesDelimited_1_0":
        return cls.deserialize(reader.read())

def _serialize_UsesDelimited_1_0(value: UsesDelimited_1_0) -> bytes:
    out = bytearray(12)
    offset_bits = 0
    def mlir___llvmdsdl_plan_capacity_check__fixtures_vendor_UsesDelimited_1_0(capacity_bits: int) -> bool:
        return 96 <= capacity_bits
    def mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1(payload_bytes: int, remaining_bytes: int) -> bool:
        return (payload_bytes >= 0) and (payload_bytes <= remaining_bytes)
    
    if not mlir___llvmdsdl_plan_capacity_check__fixtures_vendor_UsesDelimited_1_0(len(out) * 8):
        raise ValueError("serialization buffer too small")
    nested_aligned_offset_bits = ((offset_bits + 7) // 8) * 8
    for nested_align_bit in range(offset_bits, nested_aligned_offset_bits):
        dsdl_runtime.set_bit(out, nested_align_bit, False)
    offset_bits = nested_aligned_offset_bits
    nested_bytes = value.nested.serialize()
    nested_size_bytes = len(nested_bytes)
    if nested_size_bytes > 12:
        raise ValueError("encoded payload for composite field 'nested' exceeds max payload bytes 12")
    nested_remaining_bytes = len(out) - min(offset_bits // 8, len(out))
    if nested_size_bytes > nested_remaining_bytes:
        raise ValueError("encoded payload for composite field 'nested' exceeds remaining buffer space")
    dsdl_runtime.write_unsigned(out, offset_bits, 32, nested_size_bytes, False)
    offset_bits += 32
    dsdl_runtime.copy_bits(out, offset_bits, nested_bytes, 0, nested_size_bytes * 8)
    offset_bits += nested_size_bytes * 8
    used_bytes = dsdl_runtime.byte_length_for_bits(offset_bits)
    return bytes(out[:used_bytes])

def _deserialize_UsesDelimited_1_0(data: bytes | bytearray | memoryview) -> tuple[UsesDelimited_1_0, int]:
    data = bytes(data)
    def mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1(payload_bytes: int, remaining_bytes: int) -> bool:
        return (payload_bytes >= 0) and (payload_bytes <= remaining_bytes)
    
    value = UsesDelimited_1_0()
    offset_bits = 0
    offset_bits = ((offset_bits + 7) // 8) * 8
    nested_size_bytes = int(dsdl_runtime.read_unsigned(data, offset_bits, 32))
    offset_bits += 32
    nested_remaining_bytes = len(data) - min(offset_bits // 8, len(data))
    if not mlir___llvmdsdl_plan_validate_delimiter_header__fixtures_vendor_UsesDelimited_1_0__1(nested_size_bytes, nested_remaining_bytes):
        raise ValueError("decoded payload size for composite field 'nested' exceeds remaining buffer space")
    nested_start_byte = min(offset_bits // 8, len(data))
    nested_end_byte = min(nested_start_byte + nested_size_bytes, len(data))
    nested_bytes = data[nested_start_byte:nested_end_byte]
    value.nested = Delimited_1_0.deserialize(nested_bytes)
    offset_bits += nested_size_bytes * 8
    consumed = min(len(data), dsdl_runtime.byte_length_for_bits(offset_bits))
    return value, consumed
